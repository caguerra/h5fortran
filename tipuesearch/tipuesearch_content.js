var tipuesearch = {"pages":[{"title":" Object-oriented Fortran 2008 HDF5 interface ","text":"Object-oriented Fortran 2008 HDF5 interface Developer Info Michael Hirsch, Ph.D.","tags":"home","loc":"index.html"},{"title":"attributes.f90 – Object-oriented Fortran 2008 HDF5 interface","text":"Contents Submodules attributes Source Code attributes.f90 Source Code submodule ( h5fortran ) attributes use h5lt , only : h5ltset_attribute_string_f , h5ltset_attribute_float_f , h5ltset_attribute_double_f , h5ltset_attribute_int_f , & h5ltget_attribute_string_f , h5ltget_attribute_float_f , h5ltget_attribute_double_f , h5ltget_attribute_int_f , & h5ltget_attribute_ndims_f , h5ltget_attribute_info_f implicit none ( type , external ) contains module procedure readattr_char !! NOTE: HDF5 character attributes are scalar. integer :: ier if (. not . self % is_open ) error stop 'h5fortran:readattr: file handle is not open' block character ( len ( attrval )) :: buf call h5ltget_attribute_string_f ( self % lid , dname , attr , buf , ier ) attrval = buf end block if ( present ( ierr )) ierr = ier if ( check ( ier , self % filename , dname )) then if ( present ( ierr )) return error stop endif end procedure readattr_char module procedure readattr_num !! NOTE: HDF5 has 1D vector attributes for integer, float and double. integer :: ier if (. not . self % is_open ) error stop 'h5fortran:readattr: file handle is not open' call attr_shape_check ( self , dname , attr , size ( attrval ), ier ) if ( ier == 0 ) then select type ( attrval ) type is ( real ( real32 )) call h5ltget_attribute_float_f ( self % lid , dname , attr , attrval , ier ) type is ( real ( real64 )) call h5ltget_attribute_double_f ( self % lid , dname , attr , attrval , ier ) type is ( integer ( int32 )) call h5ltget_attribute_int_f ( self % lid , dname , attr , attrval , ier ) class default ier = 6 end select endif if ( present ( ierr )) ierr = ier if ( check ( ier , self % filename , dname )) then if ( present ( ierr )) return error stop endif end procedure readattr_num module procedure writeattr_char !! NOTE: HDF5 character attributes are scalar. integer :: ier if (. not . self % is_open ) error stop 'h5fortran:writeattr: file handle is not open' call h5ltset_attribute_string_f ( self % lid , dname , attr , attrval , ier ) if ( present ( ierr )) ierr = ier if ( check ( ier , self % filename , dname )) then if ( present ( ierr )) return error stop endif end procedure writeattr_char module procedure writeattr_num !! NOTE: HDF5 has 1D vector attributes for integer, float and double. integer :: ier integer ( size_t ) :: dsize if (. not . self % is_open ) error stop 'h5fortran:writeattr: file handle is not open' dsize = size ( attrval ) select type ( attrval ) type is ( real ( real32 )) call h5ltset_attribute_float_f ( self % lid , dname , attr , attrval , dsize , ier ) type is ( real ( real64 )) call h5ltset_attribute_double_f ( self % lid , dname , attr , attrval , dsize , ier ) type is ( integer ( int32 )) call h5ltset_attribute_int_f ( self % lid , dname , attr , attrval , dsize , ier ) class default ier = 6 end select if ( present ( ierr )) ierr = ier if ( check ( ier , self % filename , dname )) then if ( present ( ierr )) return error stop endif end procedure writeattr_num module procedure writeattr_char_lt type ( hdf5_file ) :: h integer :: ier call h % initialize ( filename , ier , status = 'old' ) call h % writeattr_char ( dname , attr , attrval , ier ) if ( ier == 0 ) call h % finalize ( ier ) if ( present ( ierr )) ierr = ier if ( check ( ier , filename , dname )) then if ( present ( ierr )) return error stop endif end procedure writeattr_char_lt module procedure writeattr_num_lt type ( hdf5_file ) :: h integer :: ier call h % initialize ( filename , ier , status = 'old' ) call h % writeattr_num ( dname , attr , attrval , ier ) if ( ier == 0 ) call h % finalize ( ier ) if ( present ( ierr )) ierr = ier if ( check ( ier , filename , dname )) then if ( present ( ierr )) return error stop endif end procedure writeattr_num_lt module procedure readattr_char_lt type ( hdf5_file ) :: h integer :: ier call h % initialize ( filename , ier , status = 'old' ) call h % readattr_char ( dname , attr , attrval , ier ) if ( ier == 0 ) call h % finalize ( ier ) if ( present ( ierr )) ierr = ier if ( check ( ier , filename , dname )) then if ( present ( ierr )) return error stop endif end procedure readattr_char_lt module procedure readattr_num_lt type ( hdf5_file ) :: h integer :: ier call h % initialize ( filename , ier , status = 'old' ) call h % readattr_num ( dname , attr , attrval , ier ) if ( ier == 0 ) call h % finalize ( ier ) if ( present ( ierr )) ierr = ier if ( check ( ier , filename , dname )) then if ( present ( ierr )) return error stop endif end procedure readattr_num_lt subroutine attr_shape_check ( self , dname , attr , asize , ierr ) class ( hdf5_file ), intent ( in ) :: self character ( * ), intent ( in ) :: dname , attr integer , intent ( in ) :: asize integer , intent ( out ) :: ierr integer :: arank , atype integer ( size_t ) :: attr_bytes integer ( hsize_t ) :: adims ( 1 ) if (. not . self % is_open ) error stop 'h5fortran:attr_shape: file handle is not open' if (. not . self % exist ( dname )) then write ( stderr , * ) 'ERROR: ' // dname // ' attribute ' // attr // ' does not exist in ' // self % filename ierr = - 1 return endif !> check for matching rank, else bad reads can occur--doesn't always crash without this check call h5ltget_attribute_ndims_f ( self % lid , dname , attr , arank , ierr ) if ( check ( ierr , 'ERROR:get_attribute_ndims: ' // dname // ' ' // self % filename )) return if ( arank /= 1 ) then write ( stderr , '(A,I6,A,I6)' ) 'ERROR: attribute rank mismatch ' // dname // ' attribute \"' // attr // '\" = ' , & arank , '  should be 1' ierr = - 1 return endif !> check for matching size, else bad reads can occur. call h5ltget_attribute_info_f ( self % lid , dname , attr , adims , atype , attr_bytes , ierr ) if ( check ( ierr , 'ERROR: get_attribute_info' // dname // ' read ' // self % filename )) return if (. not . all ( asize == adims )) then write ( stderr , * ) 'ERROR: shape mismatch ' // dname // ' attribute \"' // attr // '\" = ' , adims , '  shape =' , asize ierr = - 1 return endif end subroutine attr_shape_check end submodule attributes","tags":"","loc":"sourcefile/attributes.f90.html"},{"title":"interface.f90 – Object-oriented Fortran 2008 HDF5 interface","text":"Contents Modules h5fortran Source Code interface.f90 Source Code module h5fortran !! HDF5 object-oriented polymorphic interface use , intrinsic :: iso_c_binding , only : c_ptr , c_loc use , intrinsic :: iso_fortran_env , only : real32 , real64 , int64 , int32 , stderr => error_unit use hdf5 , only : HID_T , SIZE_T , HSIZE_T , H5F_ACC_RDONLY_F , H5F_ACC_RDWR_F , H5F_ACC_TRUNC_F , & H5S_ALL_F , H5S_SELECT_SET_F , & H5D_CONTIGUOUS_F , H5D_CHUNKED_F , H5D_COMPACT_F , & H5T_NATIVE_DOUBLE , H5T_NATIVE_REAL , H5T_NATIVE_INTEGER , H5T_NATIVE_CHARACTER , H5F_SCOPE_GLOBAL_F , & h5open_f , h5close_f , & h5dopen_f , h5dclose_f , h5dget_space_f , & h5gcreate_f , h5gclose_f , & h5fopen_f , h5fcreate_f , h5fclose_f , h5fis_hdf5_f , & h5lexists_f , & h5sclose_f , h5sselect_hyperslab_f , h5screate_simple_f , & h5get_libversion_f , h5eset_auto_f , h5fflush_f use h5lt , only : h5ltget_dataset_ndims_f , h5ltget_dataset_info_f implicit none ( type , external ) private public :: hdf5_file , hdf5_close , h5write , h5read , h5exist , is_hdf5 , h5write_attr , h5read_attr , & check , hdf_shape_check , hdf_get_slice , hdf_wrapup , & !< for submodules only HSIZE_T , HID_T , H5T_NATIVE_DOUBLE , H5T_NATIVE_REAL , H5T_NATIVE_INTEGER !< HDF5 types for end users !> main type type :: hdf5_file character (:), allocatable :: filename integer ( HID_T ) :: lid = 0 , & !< location ID gid , & !< group ID glid !< group location ID integer :: comp_lvl = 0 !< compression level (1-9)  0: disable compression logical :: verbose = . true . logical :: debug = . false . logical :: is_open = . false . logical :: is_scratch = . false . !! will be auto-deleted on close integer :: libversion ( 3 ) !< major, minor, rel contains !> define methods (procedures) that don't need generic procedure procedure , public :: initialize => hdf_initialize , finalize => hdf_finalize , & write_group , create => hdf_create , & open => hdf_open_group , close => hdf_close_group , flush => hdf_flush , & ndims => hdf_get_ndims , & shape => hdf_get_shape , layout => hdf_get_layout , chunks => hdf_get_chunk , & exist => hdf_check_exist , exists => hdf_check_exist , & is_contig => hdf_is_contig , is_chunked => hdf_is_chunked , is_compact => hdf_is_compact , & softlink => create_softlink !> below are procedure that need generic mapping (type or rank agnostic) !> write group or dataset integer/real generic , public :: write => hdf_write_scalar , hdf_write_1d , hdf_write_2d , hdf_write_3d , & hdf_write_4d , hdf_write_5d , hdf_write_6d , hdf_write_7d !> write attributes generic , public :: writeattr => writeattr_char , writeattr_num !> read attributes generic , public :: readattr => readattr_char , readattr_num !> read dataset generic , public :: read => & hdf_read_scalar , hdf_read_1d , hdf_read_2d , hdf_read_3d , hdf_read_4d , hdf_read_5d , hdf_read_6d , hdf_read_7d !> private methods !! each method must be declared here, and above as a generic, public procedure , private :: & hdf_write_scalar , hdf_write_1d , hdf_write_2d , hdf_write_3d , hdf_write_4d , hdf_write_5d , hdf_write_6d , hdf_write_7d , & hdf_read_scalar , hdf_read_1d , hdf_read_2d , hdf_read_3d , hdf_read_4d , hdf_read_5d , hdf_read_6d , hdf_read_7d , & writeattr_char , writeattr_num , readattr_char , readattr_num end type hdf5_file interface h5write procedure lt0write , lt1write , lt2write , lt3write , lt4write , lt5write , lt6write , lt7write end interface h5write interface h5read procedure lt0read , lt1read , lt2read , lt3read , lt4read , lt5read , lt6read , lt7read end interface h5read interface h5write_attr procedure writeattr_num_lt , writeattr_char_lt end interface h5write_attr interface h5read_attr procedure readattr_num_lt , readattr_char_lt end interface h5read_attr !> Submodules interface !< pathlib.f90 module logical function std_unlink ( filename ) character ( * ), intent ( in ) :: filename end function std_unlink module logical function is_absolute_path ( path ) character ( * ), intent ( in ) :: path end function is_absolute_path module function get_tempdir () character (:), allocatable :: get_tempdir end function end interface interface !< write.f90 module subroutine hdf_create ( self , dname , dtype , dims , sid , did , chunk_size , istart , iend , stride , compact ) class ( hdf5_file ), intent ( inout ) :: self character ( * ), intent ( in ) :: dname integer ( HID_T ), intent ( in ) :: dtype class ( * ), intent ( in ) :: dims (:) !< this can be class(*) to allow int4 or int8 in future integer ( HID_T ), intent ( out ), optional :: sid , did integer , intent ( in ), optional :: chunk_size (:), istart (:), iend (:), stride (:) logical , intent ( in ), optional :: compact !! keep istart, iend, stride for future slice shape check end subroutine hdf_create module subroutine hdf_open_group ( self , gname , ierr ) class ( hdf5_file ), intent ( inout ) :: self character ( * ), intent ( in ) :: gname integer , intent ( out ), optional :: ierr end subroutine hdf_open_group module subroutine hdf_close_group ( self , ierr ) class ( hdf5_file ), intent ( inout ) :: self integer , intent ( out ), optional :: ierr end subroutine hdf_close_group module subroutine create_softlink ( self , target , link ) class ( hdf5_file ), intent ( inout ) :: self character ( * ), intent ( in ) :: target , & !< target path to link link !< soft link path to create end subroutine create_softlink end interface interface !< writer_lt.f90 module logical function h5exist ( filename , dname ) character ( * ), intent ( in ) :: filename , dname end function h5exist module subroutine lt0write ( filename , dname , value , ierr ) character ( * ), intent ( in ) :: filename , dname class ( * ), intent ( in ) :: value integer , intent ( out ), optional :: ierr end subroutine lt0write module subroutine lt1write ( filename , dname , value , ierr ) character ( * ), intent ( in ) :: filename , dname class ( * ), intent ( in ) :: value (:) integer , intent ( out ), optional :: ierr end subroutine lt1write module subroutine lt2write ( filename , dname , value , ierr ) character ( * ), intent ( in ) :: filename , dname class ( * ), intent ( in ) :: value (:,:) integer , intent ( out ), optional :: ierr end subroutine lt2write module subroutine lt3write ( filename , dname , value , ierr ) character ( * ), intent ( in ) :: filename , dname class ( * ), intent ( in ) :: value (:,:,:) integer , intent ( out ), optional :: ierr end subroutine lt3write module subroutine lt4write ( filename , dname , value , ierr ) character ( * ), intent ( in ) :: filename , dname class ( * ), intent ( in ) :: value (:,:,:,:) integer , intent ( out ), optional :: ierr end subroutine lt4write module subroutine lt5write ( filename , dname , value , ierr ) character ( * ), intent ( in ) :: filename , dname class ( * ), intent ( in ) :: value (:,:,:,:,:) integer , intent ( out ), optional :: ierr end subroutine lt5write module subroutine lt6write ( filename , dname , value , ierr ) character ( * ), intent ( in ) :: filename , dname class ( * ), intent ( in ) :: value (:,:,:,:,:,:) integer , intent ( out ), optional :: ierr end subroutine lt6write module subroutine lt7write ( filename , dname , value , ierr ) character ( * ), intent ( in ) :: filename , dname class ( * ), intent ( in ) :: value (:,:,:,:,:,:,:) integer , intent ( out ), optional :: ierr end subroutine lt7write end interface interface !< reader_lt.f90 module subroutine lt0read ( filename , dname , value , ierr ) character ( * ), intent ( in ) :: filename , dname class ( * ), intent ( out ) :: value integer , intent ( out ), optional :: ierr end subroutine lt0read module subroutine lt1read ( filename , dname , value , ierr ) character ( * ), intent ( in ) :: filename , dname class ( * ), intent ( out ) :: value (:) integer , intent ( out ), optional :: ierr end subroutine lt1read module subroutine lt2read ( filename , dname , value , ierr ) character ( * ), intent ( in ) :: filename , dname class ( * ), intent ( out ) :: value (:,:) integer , intent ( out ), optional :: ierr end subroutine lt2read module subroutine lt3read ( filename , dname , value , ierr ) character ( * ), intent ( in ) :: filename , dname class ( * ), intent ( out ) :: value (:,:,:) integer , intent ( out ), optional :: ierr end subroutine lt3read module subroutine lt4read ( filename , dname , value , ierr ) character ( * ), intent ( in ) :: filename , dname class ( * ), intent ( out ) :: value (:,:,:,:) integer , intent ( out ), optional :: ierr end subroutine lt4read module subroutine lt5read ( filename , dname , value , ierr ) character ( * ), intent ( in ) :: filename , dname class ( * ), intent ( out ) :: value (:,:,:,:,:) integer , intent ( out ), optional :: ierr end subroutine lt5read module subroutine lt6read ( filename , dname , value , ierr ) character ( * ), intent ( in ) :: filename , dname class ( * ), intent ( out ) :: value (:,:,:,:,:,:) integer , intent ( out ), optional :: ierr end subroutine lt6read module subroutine lt7read ( filename , dname , value , ierr ) character ( * ), intent ( in ) :: filename , dname class ( * ), intent ( out ) :: value (:,:,:,:,:,:,:) integer , intent ( out ), optional :: ierr end subroutine lt7read end interface interface !< writer.f90 module subroutine hdf_write_scalar ( self , dname , value , ierr , compact ) class ( hdf5_file ), intent ( inout ) :: self character ( * ), intent ( in ) :: dname class ( * ), intent ( in ) :: value logical , intent ( in ), optional :: compact integer , intent ( out ), optional :: ierr end subroutine hdf_write_scalar module subroutine hdf_write_1d ( self , dname , value , ierr , chunk_size , istart , iend , stride , compact ) class ( hdf5_file ), intent ( inout ) :: self character ( * ), intent ( in ) :: dname class ( * ), intent ( in ) :: value (:) integer , intent ( in ), optional :: chunk_size ( 1 ) integer , intent ( in ), optional , dimension (:) :: istart , iend , stride logical , intent ( in ), optional :: compact integer , intent ( out ), optional :: ierr end subroutine hdf_write_1d module subroutine hdf_write_2d ( self , dname , value , ierr , chunk_size , istart , iend , stride , compact ) class ( hdf5_file ), intent ( inout ) :: self character ( * ), intent ( in ) :: dname class ( * ), intent ( in ) :: value (:,:) integer , intent ( in ), optional :: chunk_size ( 2 ) integer , intent ( in ), optional , dimension (:) :: istart , iend , stride logical , intent ( in ), optional :: compact integer , intent ( out ), optional :: ierr end subroutine hdf_write_2d module subroutine hdf_write_3d ( self , dname , value , ierr , chunk_size , istart , iend , stride , compact ) class ( hdf5_file ), intent ( inout ) :: self character ( * ), intent ( in ) :: dname class ( * ), intent ( in ) :: value (:,:,:) integer , intent ( in ), optional :: chunk_size ( 3 ) integer , intent ( in ), optional , dimension (:) :: istart , iend , stride logical , intent ( in ), optional :: compact integer , intent ( out ), optional :: ierr end subroutine hdf_write_3d module subroutine hdf_write_4d ( self , dname , value , ierr , chunk_size , istart , iend , stride , compact ) class ( hdf5_file ), intent ( inout ) :: self character ( * ), intent ( in ) :: dname class ( * ), intent ( in ) :: value (:,:,:,:) integer , intent ( in ), optional :: chunk_size ( 4 ) integer , intent ( in ), optional , dimension (:) :: istart , iend , stride logical , intent ( in ), optional :: compact integer , intent ( out ), optional :: ierr end subroutine hdf_write_4d module subroutine hdf_write_5d ( self , dname , value , ierr , chunk_size , istart , iend , stride , compact ) class ( hdf5_file ), intent ( inout ) :: self character ( * ), intent ( in ) :: dname class ( * ), intent ( in ) :: value (:,:,:,:,:) integer , intent ( in ), optional :: chunk_size ( 5 ) integer , intent ( in ), optional , dimension (:) :: istart , iend , stride logical , intent ( in ), optional :: compact integer , intent ( out ), optional :: ierr end subroutine hdf_write_5d module subroutine hdf_write_6d ( self , dname , value , ierr , chunk_size , istart , iend , stride , compact ) class ( hdf5_file ), intent ( inout ) :: self character ( * ), intent ( in ) :: dname class ( * ), intent ( in ) :: value (:,:,:,:,:,:) integer , intent ( in ), optional :: chunk_size ( 6 ) integer , intent ( in ), optional , dimension (:) :: istart , iend , stride logical , intent ( in ), optional :: compact integer , intent ( out ), optional :: ierr end subroutine hdf_write_6d module subroutine hdf_write_7d ( self , dname , value , ierr , chunk_size , istart , iend , stride , compact ) class ( hdf5_file ), intent ( inout ) :: self character ( * ), intent ( in ) :: dname class ( * ), intent ( in ) :: value (:,:,:,:,:,:,:) integer , intent ( in ), optional :: chunk_size ( 7 ) integer , intent ( in ), optional , dimension (:) :: istart , iend , stride logical , intent ( in ), optional :: compact integer , intent ( out ), optional :: ierr end subroutine hdf_write_7d end interface interface !< read.f90 module integer function hdf_get_ndims ( self , dname ) result ( drank ) class ( hdf5_file ), intent ( in ) :: self character ( * ), intent ( in ) :: dname end function hdf_get_ndims module subroutine hdf_get_shape ( self , dname , dims , ierr ) class ( hdf5_file ), intent ( in ) :: self character ( * ), intent ( in ) :: dname integer ( HSIZE_T ), intent ( out ), allocatable :: dims (:) integer , intent ( out ), optional :: ierr end subroutine hdf_get_shape module integer function hdf_get_layout ( self , dname ) result ( layout ) !! H5D_CONTIGUOUS_F, H5D_CHUNKED_F, H5D_VIRTUAL_F, H5D_COMPACT_F class ( hdf5_file ), intent ( in ) :: self character ( * ), intent ( in ) :: dname end function hdf_get_layout module subroutine hdf_get_chunk ( self , dname , chunk_size ) class ( hdf5_file ), intent ( in ) :: self character ( * ), intent ( in ) :: dname integer ( hsize_t ), intent ( out ) :: chunk_size (:) end subroutine hdf_get_chunk module logical function hdf_check_exist ( self , dname ) result ( exists ) class ( hdf5_file ), intent ( in ) :: self character ( * ), intent ( in ) :: dname end function hdf_check_exist end interface interface !< reader.f90 module subroutine hdf_read_scalar ( self , dname , value , ierr ) class ( hdf5_file ), intent ( in ) :: self character ( * ), intent ( in ) :: dname class ( * ), intent ( inout ) :: value !! intent(inout) for character integer , intent ( out ), optional :: ierr end subroutine hdf_read_scalar module subroutine hdf_read_1d ( self , dname , value , ierr , istart , iend , stride ) class ( hdf5_file ), intent ( in ) :: self character ( * ), intent ( in ) :: dname class ( * ), intent ( out ) :: value (:) integer , intent ( out ), optional :: ierr integer , intent ( in ), optional , dimension (:) :: istart , iend , stride end subroutine hdf_read_1d module subroutine hdf_read_2d ( self , dname , value , ierr , istart , iend , stride ) class ( hdf5_file ), intent ( in ) :: self character ( * ), intent ( in ) :: dname class ( * ), intent ( out ) :: value (:,:) integer , intent ( out ), optional :: ierr integer , intent ( in ), optional , dimension (:) :: istart , iend , stride end subroutine hdf_read_2d module subroutine hdf_read_3d ( self , dname , value , ierr , istart , iend , stride ) class ( hdf5_file ), intent ( in ) :: self character ( * ), intent ( in ) :: dname class ( * ), intent ( out ) :: value (:,:,:) integer , intent ( out ), optional :: ierr integer , intent ( in ), optional , dimension (:) :: istart , iend , stride end subroutine hdf_read_3d module subroutine hdf_read_4d ( self , dname , value , ierr , istart , iend , stride ) class ( hdf5_file ), intent ( in ) :: self character ( * ), intent ( in ) :: dname class ( * ), intent ( out ) :: value (:,:,:,:) integer , intent ( out ), optional :: ierr integer , intent ( in ), optional , dimension (:) :: istart , iend , stride end subroutine hdf_read_4d module subroutine hdf_read_5d ( self , dname , value , ierr , istart , iend , stride ) class ( hdf5_file ), intent ( in ) :: self character ( * ), intent ( in ) :: dname class ( * ), intent ( out ) :: value (:,:,:,:,:) integer , intent ( out ), optional :: ierr integer , intent ( in ), optional , dimension (:) :: istart , iend , stride end subroutine hdf_read_5d module subroutine hdf_read_6d ( self , dname , value , ierr , istart , iend , stride ) class ( hdf5_file ), intent ( in ) :: self character ( * ), intent ( in ) :: dname class ( * ), intent ( out ) :: value (:,:,:,:,:,:) integer , intent ( out ), optional :: ierr integer , intent ( in ), optional , dimension (:) :: istart , iend , stride end subroutine hdf_read_6d module subroutine hdf_read_7d ( self , dname , value , ierr , istart , iend , stride ) class ( hdf5_file ), intent ( in ) :: self character ( * ), intent ( in ) :: dname class ( * ), intent ( out ) :: value (:,:,:,:,:,:,:) integer , intent ( out ), optional :: ierr integer , intent ( in ), optional , dimension (:) :: istart , iend , stride end subroutine hdf_read_7d end interface interface !< attributes.f90 module subroutine readattr_char ( self , dname , attr , attrval , ierr ) class ( hdf5_file ), intent ( in ) :: self character ( * ), intent ( in ) :: dname , attr character ( * ), intent ( inout ) :: attrval !! intent(inout) for character integer , intent ( out ), optional :: ierr end subroutine readattr_char module subroutine readattr_num ( self , dname , attr , attrval , ierr ) class ( hdf5_file ), intent ( in ) :: self character ( * ), intent ( in ) :: dname , attr class ( * ), intent ( out ) :: attrval (:) integer , intent ( out ), optional :: ierr end subroutine readattr_num module subroutine writeattr_char ( self , dname , attr , attrval , ierr ) class ( hdf5_file ), intent ( in ) :: self character ( * ), intent ( in ) :: dname , attr character ( * ), intent ( in ) :: attrval integer , intent ( out ), optional :: ierr end subroutine writeattr_char module subroutine writeattr_num ( self , dname , attr , attrval , ierr ) class ( hdf5_file ), intent ( in ) :: self character ( * ), intent ( in ) :: dname , attr class ( * ), intent ( in ) :: attrval (:) integer , intent ( out ), optional :: ierr end subroutine writeattr_num module subroutine writeattr_char_lt ( filename , dname , attr , attrval , ierr ) character ( * ), intent ( in ) :: filename character ( * ), intent ( in ) :: dname , attr character ( * ), intent ( in ) :: attrval integer , intent ( out ), optional :: ierr end subroutine writeattr_char_lt module subroutine writeattr_num_lt ( filename , dname , attr , attrval , ierr ) character ( * ), intent ( in ) :: filename character ( * ), intent ( in ) :: dname , attr class ( * ), intent ( in ) :: attrval (:) integer , intent ( out ), optional :: ierr end subroutine writeattr_num_lt module subroutine readattr_char_lt ( filename , dname , attr , attrval , ierr ) character ( * ), intent ( in ) :: filename character ( * ), intent ( in ) :: dname , attr character ( * ), intent ( inout ) :: attrval !! intent(inout) for character integer , intent ( out ), optional :: ierr end subroutine readattr_char_lt module subroutine readattr_num_lt ( filename , dname , attr , attrval , ierr ) character ( * ), intent ( in ) :: filename character ( * ), intent ( in ) :: dname , attr class ( * ), intent ( out ) :: attrval (:) integer , intent ( out ), optional :: ierr end subroutine readattr_num_lt end interface contains subroutine hdf_initialize ( self , filename , ierr , status , action , comp_lvl , verbose , debug ) !! Opens hdf5 file class ( hdf5_file ), intent ( inout ) :: self character ( * ), intent ( in ) :: filename integer , intent ( out ), optional :: ierr character ( * ), intent ( in ), optional :: status character ( * ), intent ( in ), optional :: action integer , intent ( in ), optional :: comp_lvl logical , intent ( in ), optional :: verbose , debug character (:), allocatable :: lstatus , laction integer :: ier if ( self % is_open ) then write ( stderr , * ) 'WARNING:h5fortran:initialize: file handle already open: ' // self % filename return endif self % filename = filename if ( present ( comp_lvl )) self % comp_lvl = comp_lvl if ( present ( verbose )) self % verbose = verbose if ( present ( debug )) self % debug = debug !> Initialize FORTRAN interface. call h5open_f ( ier ) if ( present ( ierr )) ierr = ier if ( check ( ier , 'ERROR: HDF5 library initialize' )) then if ( present ( ierr )) return error stop endif !> get library version call h5get_libversion_f ( self % libversion ( 1 ), self % libversion ( 2 ), self % libversion ( 3 ), ier ) if ( self % debug ) print '(A,3I3)' , 'HDF5 version: ' , self % libversion if ( present ( ierr )) ierr = ier if ( check ( ier , 'ERROR: HDF5 library get version' )) then if ( present ( ierr )) return error stop endif if ( self % verbose ) then call h5eset_auto_f ( 1 , ier ) else call h5eset_auto_f ( 0 , ier ) endif if ( present ( ierr )) ierr = ier if ( check ( ier , 'ERROR: HDF5 library set traceback' )) then if ( present ( ierr )) return error stop endif lstatus = 'unknown' if ( present ( status )) lstatus = status laction = 'rw' if ( present ( action )) laction = action select case ( lstatus ) case ( 'old' , 'unknown' ) select case ( laction ) case ( 'read' , 'r' ) call h5fopen_f ( filename , H5F_ACC_RDONLY_F , self % lid , ier ) case ( 'r+' ) call h5fopen_f ( filename , H5F_ACC_RDWR_F , self % lid , ier ) case ( 'readwrite' , 'rw' , 'append' , 'a' ) if ( is_hdf5 ( filename )) then call h5fopen_f ( filename , H5F_ACC_RDWR_F , self % lid , ier ) else call h5fcreate_f ( filename , H5F_ACC_TRUNC_F , self % lid , ier ) endif case ( 'w' , 'write' ) call h5fcreate_f ( filename , H5F_ACC_TRUNC_F , self % lid , ier ) case default write ( stderr , * ) 'Unsupported action -> ' // laction error stop 128 end select case ( 'new' , 'replace' ) call h5fcreate_f ( filename , H5F_ACC_TRUNC_F , self % lid , ier ) case ( 'scratch' ) call h5fcreate_f ( filename , H5F_ACC_TRUNC_F , self % lid , ier ) self % is_scratch = . true . if (. not . is_absolute_path ( filename )) self % filename = get_tempdir () // '/' // filename case default write ( stderr , * ) 'Unsupported status -> ' // lstatus error stop 128 end select if ( present ( ierr )) ierr = ier if ( check ( ier , filename )) then if ( present ( ierr )) return error stop endif self % is_open = . true . end subroutine hdf_initialize subroutine hdf_finalize ( self , ierr , close_hdf5_interface ) !! This must be called on each HDF5 file to flush buffers to disk !! data loss can occur if program terminates before this procedure !! !! We don't reference count because applications might also invoke HDF5 !! directly. !! close_hdf5_interface is when you know you have exactly one HDF5 file in your !! application, if true it closes ALL files, even those invoked directly from HDF5. class ( hdf5_file ), intent ( inout ) :: self logical , intent ( in ), optional :: close_hdf5_interface integer , intent ( out ), optional :: ierr integer :: ier if (. not . self % is_open ) then write ( stderr , * ) 'WARNING:h5fortran:finalize: file handle is already closed: ' // self % filename return endif !> close hdf5 file call h5fclose_f ( self % lid , ier ) if ( present ( ierr )) ierr = ier if ( check ( ier , 'ERROR:finalize: HDF5 file close: ' // self % filename )) then if ( present ( ierr )) return error stop endif if ( present ( close_hdf5_interface )) then if ( close_hdf5_interface ) then call h5close_f ( ier ) if ( present ( ierr )) ierr = ier if ( check ( ier , 'ERROR: HDF5 library close' )) then if ( present ( ierr )) return error stop endif endif endif !> sentinel lid self % lid = 0 if ( self % is_scratch ) then if ( std_unlink ( self % filename )) write ( stderr , * ) 'WARNING: could not delete scratch file: ' // self % filename endif self % is_open = . false . end subroutine hdf_finalize subroutine hdf_flush ( self , ierr ) class ( hdf5_file ), intent ( in ) :: self integer , intent ( out ), optional :: ierr integer :: ier call h5fflush_f ( self % lid , H5F_SCOPE_GLOBAL_F , ier ) if ( present ( ierr )) ierr = ier if ( check ( ier , 'ERROR: HDF5 flush ' // self % filename ) . and . . not . present ( ierr )) error stop end subroutine hdf_flush subroutine hdf5_close ( ierr ) !! this subroutine will close ALL existing file handles !! only call it at end of your program !! \"Flushes all data to disk, closes all open identifiers, and cleans up memory.\" !! \"Should be called by all HDF5 Fortran programs\" integer , intent ( out ), optional :: ierr integer :: ier call h5close_f ( ier ) if ( present ( ierr )) ierr = ier if ( check ( ier , 'ERROR: HDF5 library close' ) . and . . not . present ( ierr )) error stop end subroutine hdf5_close logical function hdf_is_contig ( self , dname ) class ( hdf5_file ), intent ( in ) :: self character ( * ), intent ( in ) :: dname hdf_is_contig = self % layout ( dname ) == H5D_CONTIGUOUS_F end function hdf_is_contig logical function hdf_is_compact ( self , dname ) class ( hdf5_file ), intent ( in ) :: self character ( * ), intent ( in ) :: dname hdf_is_compact = self % layout ( dname ) == H5D_COMPACT_F end function hdf_is_compact logical function hdf_is_chunked ( self , dname ) class ( hdf5_file ), intent ( in ) :: self character ( * ), intent ( in ) :: dname hdf_is_chunked = self % layout ( dname ) == H5D_CHUNKED_F end function hdf_is_chunked logical function is_hdf5 ( filename ) !! is this file HDF5? character ( * ), intent ( in ) :: filename integer :: ierr inquire ( file = filename , exist = is_hdf5 ) !! avoid warning/error messages if (. not . is_hdf5 ) return call h5fis_hdf5_f ( filename , is_hdf5 , ierr ) if ( ierr /= 0 ) is_hdf5 = . false . !! sometimes h5fis_hdf5_f is .true. for missing file end function is_hdf5 subroutine write_group ( self , gname , ierr ) class ( hdf5_file ), intent ( in ) :: self character ( * ), intent ( in ) :: gname !< relative path to group integer , intent ( out ), optional :: ierr integer ( HID_T ) :: gid integer :: ier integer :: sp , ep , sl logical :: gexist if (. not . self % is_open ) error stop 'h5fortran:write_group: file handle is not open' sl = len ( gname ) sp = 1 ep = 0 do ep = index ( gname ( sp + 1 : sl ), \"/\" ) ! no subgroup found if ( ep == 0 ) exit ! check subgroup exists sp = sp + ep call h5lexists_f ( self % lid , gname ( 1 : sp - 1 ), gexist , ier ) if ( present ( ierr )) ierr = ier if ( check ( ier , self % filename , gname )) then if ( present ( ierr )) return error stop endif if (. not . gexist ) then call h5gcreate_f ( self % lid , gname ( 1 : sp - 1 ), gid , ier ) if ( present ( ierr )) ierr = ier if ( check ( ier , self % filename , gname )) then if ( present ( ierr )) return error stop endif call h5gclose_f ( gid , ier ) if ( present ( ierr )) ierr = ier if ( check ( ier , self % filename , gname )) then if ( present ( ierr )) return error stop endif endif end do end subroutine write_group logical function check ( ierr , filename , dname ) integer , intent ( in ) :: ierr character ( * ), intent ( in ), optional :: filename , dname character (:), allocatable :: fn , dn check = . true . fn = \"\" dn = \"\" if ( present ( filename )) fn = filename if ( present ( dname )) dn = dname select case ( ierr ) case ( 0 ) check = . false . return case ( 6 ) write ( stderr , * ) 'ERROR: ' // fn // ':' // dname // ' datatype is not handled by h5fortran.' case ( 128 ) write ( stderr , * ) 'ERROR:initialize ' // fn // ' could not be opened or created' case default write ( stderr , * ) 'ERROR: ' // fn // ':' // dn // ' error code ' , ierr end select end function check subroutine hdf_wrapup ( did , sid , ierr ) integer ( HID_T ), intent ( in ) :: sid , did integer , intent ( out ) :: ierr if ( sid /= 0 ) then call h5sclose_f ( sid , ierr ) if ( check ( ierr , 'ERROR:h5sclose dataspace' )) return endif if ( did /= 0 ) then call h5dclose_f ( did , ierr ) if ( check ( ierr , 'ERROR:h5dclose dataset' )) return endif end subroutine hdf_wrapup subroutine hdf_get_slice ( self , dname , did , sid , mem_sid , i0 , i1 , i2 ) !! setup array slices for read and write class ( hdf5_file ), intent ( in ) :: self character ( * ), intent ( in ) :: dname integer ( HID_T ), intent ( inout ) :: did !< inout for sentinel value integer ( hid_t ), intent ( out ) :: sid , mem_sid class ( * ), intent ( in ), dimension (:) :: i0 , i1 class ( * ), intent ( in ), optional , dimension (:) :: i2 integer ( hsize_t ), dimension ( size ( i0 )) :: istart , iend , stride , mem_dims integer :: ierr if ( size ( i0 ) /= size ( i1 )) error stop \"istart and iend must have equal length\" if ( present ( i2 )) then if ( size ( i0 ) /= size ( i2 )) error stop \"istride must be same length as istart and iend\" endif if (. not . self % is_open ) error stop 'h5fortran:slice: file handle is not open' !! istart select type ( i0 ) type is ( integer ( int32 )) istart = int ( i0 , int64 ) type is ( integer ( hsize_t )) istart = i0 class default write ( stderr , * ) 'ERROR:h5fortran:slice: wrong type for istart: ' , dname , self % filename error stop 5 end select !! iend select type ( i1 ) type is ( integer ( int32 )) iend = int ( i1 , int64 ) type is ( integer ( hsize_t )) iend = i1 class default write ( stderr , * ) 'ERROR:h5fortran:slice: wrong type for iend: ' , dname , self % filename error stop 5 end select !! stride if ( present ( i2 )) then select type ( i2 ) type is ( integer ( int32 )) stride = int ( i2 , int64 ) type is ( integer ( hsize_t )) stride = i2 class default write ( stderr , * ) 'ERROR:h5fortran:slice: wrong type for stride: ' , dname , self % filename error stop 5 end select if ( self % debug ) print * , 'DEBUG: user-stride:' , stride else stride = 1 if ( self % debug ) print * , 'DEBUG: auto-stride' , stride endif !! compensate for 0-based hyperslab vs. 1-based Fortran istart = istart - 1 mem_dims = iend - istart !> some callers have already opened the dataset. 0 is a sentinel saying not opened yet. if ( did == 0 ) then call h5dopen_f ( self % lid , dname , did , ierr ) if ( ierr /= 0 ) then write ( stderr , * ) 'h5fortran:get_slice:H5Dopen: ' // dname // ' ' // self % filename error stop endif endif call h5dget_space_f ( did , sid , ierr ) if ( ierr /= 0 ) error stop 'h5fortran:get_slice could not get dataset' call h5sselect_hyperslab_f ( sid , H5S_SELECT_SET_F , istart , mem_dims , ierr , stride = stride ) if ( ierr /= 0 ) error stop 'h5fortran:get_slice could not assign hyperslab' call h5screate_simple_f ( size ( mem_dims ), mem_dims , mem_sid , ierr ) if ( ierr /= 0 ) error stop 'h5fortran:get_slice could not create dataspace' end subroutine hdf_get_slice subroutine hdf_shape_check ( self , dname , dims ) class ( hdf5_file ), intent ( in ) :: self character ( * ), intent ( in ) :: dname class ( * ), intent ( in ) :: dims (:) integer :: ierr integer ( SIZE_T ) :: dsize integer ( HSIZE_T ), dimension ( size ( dims )) :: ddims , vdims integer :: dtype , drank if (. not . self % is_open ) error stop 'h5fortran:shape: file handle is not open' if (. not . self % exist ( dname )) then write ( stderr , * ) 'ERROR: ' // dname // ' does not exist in ' // self % filename error stop endif !> allow user to specify int4 or int8 dims select type ( dims ) type is ( integer ( int32 )) vdims = int ( dims , int64 ) type is ( integer ( hsize_t )) vdims = dims class default write ( stderr , * ) 'ERROR:h5fortran:shape_check: wrong type for dims: ' , dname , self % filename error stop 5 end select !> check for matching rank, else bad reads can occur--doesn't always crash without this check call h5ltget_dataset_ndims_f ( self % lid , dname , drank , ierr ) if ( ierr /= 0 ) then write ( stderr , * ) 'ERROR:h5fortran:shape_check: get_dataset_ndim ' // dname // ' read ' // self % filename error stop endif if ( drank /= size ( vdims )) then write ( stderr , '(A,I6,A,I6)' ) 'ERROR:h5fortran:shape_check: rank mismatch ' // dname // ' = ' , drank , '  variable rank =' , size ( vdims ) error stop endif !> check for matching size, else bad reads can occur. call h5ltget_dataset_info_f ( self % lid , dname , ddims , dtype , dsize , ierr ) if ( ierr /= 0 ) then write ( stderr , * ) 'ERROR:h5fortran:shape_check: get_dataset_info ' // dname // ' read ' // self % filename error stop endif if (. not . all ( vdims == ddims )) then write ( stderr , * ) 'ERROR:h5fortran:shape_check: shape mismatch ' // dname // ' = ' , ddims , '  variable shape =' , vdims error stop endif end subroutine hdf_shape_check end module h5fortran","tags":"","loc":"sourcefile/interface.f90.html"},{"title":"pathlib.in.f90 – Object-oriented Fortran 2008 HDF5 interface","text":"Contents Submodules pathlib Source Code pathlib.in.f90 Source Code submodule ( h5fortran ) pathlib !! vendored from Michael Hirsch's Fortran pathlib implicit none ( type , external ) contains module procedure get_tempdir character ( 1024 ) :: argv integer :: L , i call get_environment_variable ( \"TMP\" , argv , L , i ) if ( L == 0 . or . i /= 0 ) call get_environment_variable ( \"TEMP\" , argv , L , i ) if ( L == 0 . or . i /= 0 ) call get_environment_variable ( \"TMPDIR\" , argv , L , i ) if ( L == 0 . or . i /= 0 ) argv = \"/tmp\" get_tempdir = trim ( argv ) end procedure get_tempdir module procedure is_absolute_path !! heuristic to determine if is absolute path is_absolute_path = . false . if ( @ is_windows @ ) then if ( lge ( path ( 1 : 1 ), 'A' ) . and . lle ( path ( 1 : 1 ), 'z' ) . and . path ( 2 : 2 ) == ':' ) is_absolute_path = . true . else if ( path ( 1 : 1 ) == '/' ) is_absolute_path = . true . endif end procedure is_absolute_path module procedure std_unlink !! deletes file in Fortran standard manner. integer :: i , u open ( newunit = u , file = filename , iostat = i ) close ( u , status = 'delete' , iostat = i ) inquire ( file = filename , exist = std_unlink ) end procedure std_unlink end submodule pathlib","tags":"","loc":"sourcefile/pathlib.in.f90.html"},{"title":"file_image.f90 – Object-oriented Fortran 2008 HDF5 interface","text":"Contents Programs test_file_image Modules file_image Source Code file_image.f90 Source Code module file_image !! HDF5 file images are an in-RAM fast HDF5 virtual file. !! there are many caveats to their use and they might never be included in h5fortran use , intrinsic :: iso_fortran_env , only : stderr => error_unit , real32 , real64 , int32 use , intrinsic :: iso_c_binding , only : c_ptr , c_loc , c_sizeof , c_associated use hdf5 , only : h5pcreate_f , h5pclose_f , & h5pset_file_image_f , h5pget_file_image_f , & H5P_FILE_ACCESS_F , hid_t , size_t , & h5open_f , h5close_f !  use h5lt, only : H5LTopen_file_image_f !! h5ltopen_file_image_f does NOT exist yet as of HDF5 1.12.0. The API was specified for HDF5 1.8.9, !! but never implemented (yet). implicit none ( type , external ) private public :: hid_t , create_file_image , close_file_image , write_file_image , read_file_image contains subroutine create_file_image ( fapl_id ) integer ( hid_t ), intent ( out ) :: fapl_id integer ( size_t ) :: b_size integer :: ier type ( C_PTR ) :: f_ptr ( 1 : 1 ) !> open HDF5 library call h5open_f ( ier ) if ( ier /= 0 ) error stop 'could not open HDF5 library' !> create file property ID \"fapl_id\" call h5pcreate_f ( H5P_FILE_ACCESS_F , fapl_id , ier ) if ( ier /= 0 ) error stop 'h5pcreate_f' !> create and check empty buffer call h5pget_file_image_f ( fapl_id , f_ptr , b_size , ier ) if ( ier /= 0 ) error stop 'h5pget_file_image: create buffer' if ( b_size /= 0 ) error stop 'expected empty buffer' end subroutine create_file_image subroutine write_file_image ( data , fapl_id ) !! polymorphic in future implementation integer ( hid_t ), intent ( in ) :: fapl_id integer , intent ( in ) :: data (:) integer , dimension ( 1 : size ( data )), target :: buffer type ( c_ptr ) :: f_ptr integer :: ier !> write data to HDF5 file image buffer = data f_ptr = c_loc ( buffer ( 1 )) call h5pset_file_image_f ( fapl_id , f_ptr , c_sizeof ( buffer ), ier ) if ( ier /= 0 ) error stop 'h5pset_file_image_f: set buffer size' end subroutine write_file_image subroutine read_file_image ( buffer , fapl_id ) integer ( hid_t ), intent ( in ) :: fapl_id integer , dimension (:), intent ( out ), target :: buffer type ( c_ptr ) :: f_ptr ( 1 : size ( buffer )) integer ( size_t ) :: b_size integer :: i , buffer_size buffer_size = size ( buffer ) * storage_size ( int32 ) / 8 do i = 1 , size ( buffer ) f_ptr ( i ) = C_LOC ( buffer ( i )) enddo call h5pget_file_image_f ( fapl_id , f_ptr , b_size , i ) if ( i /= 0 ) error stop 'read_file_image: could not read buffer' if ( b_size /= buffer_size ) then write ( stderr , * ) \"variable size: \" , buffer_size , \" /= file_image size: \" , b_size error stop 'read_file_image: variable size /= file_image size' endif end subroutine read_file_image subroutine close_file_image ( fapl_id ) integer ( hid_t ), intent ( in ) :: fapl_id integer :: i !> close file image and library call h5pclose_f ( fapl_id , i ) if ( i /= 0 ) error stop 'problem closing file image' call h5close_f ( i ) if ( i /= 0 ) error stop 'problem closing HDF5 library' end subroutine close_file_image end module file_image program test_file_image use , intrinsic :: iso_fortran_env , only : stderr => error_unit use file_image , only : create_file_image , write_file_image , read_file_image , close_file_image , hid_t implicit none ( type , external ) integer ( hid_t ) :: fapl_id integer , dimension ( 1 : 8 ) :: in , out !! arbitrary user data in = [ 1 , 3 , 7 , 13 , 129 , - 13 , 23 , 42 ] call create_file_image ( fapl_id ) call write_file_image ( in , fapl_id ) call read_file_image ( out , fapl_id ) call close_file_image ( fapl_id ) if ( any ( in /= out )) then write ( stderr , * ) 'in=' , in write ( stderr , * ) 'out=' , out error stop 'output data does not match input data' endif print * , 'OK: file image prototype' end program","tags":"","loc":"sourcefile/file_image.f90.html"},{"title":"h5compact.f90 – Object-oriented Fortran 2008 HDF5 interface","text":"Example of compact vs. contiguous datasets, requires HDF5 >= 1.8\n for convenience of comparison we create two files,\n though distinct dataset types can exist in the same file. The file size saving isn't so much, but the advantage is in speed of access\n particularly when small datasets are frequently read/write Contents Programs compact Modules h5layout Source Code h5compact.f90 Source Code !! Example of compact vs. contiguous datasets, requires HDF5 >= 1.8 !! for convenience of comparison we create two files, !! though distinct dataset types can exist in the same file. !! !! The file size saving isn't so much, but the advantage is in speed of access !! particularly when small datasets are frequently read/write module h5layout use , intrinsic :: iso_fortran_env , only : REAL64 , INT64 , stderr => error_unit use hdf5 use h5lt , only : h5ltread_dataset_float_f implicit none ( type , external ) private public :: print_layout , write_layout , sysclock2ms , unlink , bench_write , bench_read contains subroutine print_layout ( filename , ds_name ) !! prints dataset (variable) layout in a file character ( * ), intent ( in ) :: filename , ds_name integer :: ierr , layout integer ( hid_t ) :: f_id , ds_id , prp_id INTEGER ( HSIZE_T ) :: fsize CALL h5fopen_f ( filename , H5F_ACC_RDONLY_F , f_id , ierr ) !> get file size. CALL h5fget_filesize_f ( f_id , fsize , ierr ) print * , filename , \" size in bytes: \" , fsize !> get dataset storage layout CALL h5dopen_f ( f_id , ds_name , ds_id , ierr ) if ( ierr /= 0 ) error stop \"problem opening dataset\" CALL h5dget_create_plist_f ( ds_id , prp_id , ierr ) CALL h5pget_layout_f ( prp_id , layout , ierr ) !> not truly constants, so select case doesn't work if ( layout == H5D_COMPACT_F ) then print * , ds_name , \" layout: COMPACT\" elseif ( layout == H5D_CONTIGUOUS_F ) then print * , ds_name , \" layout: CONTIGUOUS\" elseif ( layout == H5D_CHUNKED_F ) then print * , ds_name , \" layout: CHUNKED\" else error stop \"could not determine layout\" end if call h5pclose_f ( prp_id , ierr ) call h5dclose_f ( ds_id , ierr ) call h5fclose_f ( f_id , ierr ) CALL h5close_f ( ierr ) end subroutine print_layout subroutine write_layout ( file_id , ds_name , layout , dat ) !! write real data with HDF5 layout type specified integer ( hid_t ), intent ( in ) :: file_id character ( * ), intent ( in ) :: ds_name integer , intent ( in ) :: layout real , intent ( in ) :: dat (:) integer :: ierr integer ( hid_t ) :: ds_id , prp_id , space_id integer ( HSIZE_T ) :: dims ( rank ( dat )) dims = shape ( dat ) !> create dataspace call h5screate_simple_f ( size ( dims ), dims , space_id , ierr ) if ( ierr /= 0 ) error stop \"problem creating dataspace\" !> create dataset property list call h5pcreate_f ( H5P_DATASET_CREATE_F , prp_id , ierr ) if ( ierr /= 0 ) error stop \"problem creating property list\" !> config for dataset call h5pset_layout_f ( prp_id , layout , ierr ) if ( ierr /= 0 ) error stop \"problem creating layout\" if ( layout == H5D_CHUNKED_F ) then !! normally chunk size set more effectively for actual large datasets. call h5pset_chunk_f ( prp_id , size ( dims ), int ( shape ( dat ), hsize_t ), ierr ) if ( ierr /= 0 ) error stop \"problem setting chunk size\" endif !> create dataset call h5dcreate_f ( file_id , ds_name , H5T_NATIVE_REAL , space_id , ds_id , ierr , dcpl_id = prp_id ) if ( ierr /= 0 ) error stop \"problem creating dataset\" !> write data CALL h5dwrite_f ( ds_id , H5T_NATIVE_REAL , dat , dims , ierr ) !> close call h5pclose_f ( prp_id , ierr ) call h5dclose_f ( ds_id , ierr ) call h5sclose_f ( space_id , ierr ) end subroutine write_layout impure elemental real ( real64 ) function sysclock2ms ( t ) !! Convert a number of clock ticks, as returned by system_clock() called !! with integer(int64) arguments, to milliseconds integer ( int64 ), intent ( in ) :: t integer ( int64 ) :: rate call system_clock ( count_rate = rate ) sysclock2ms = t * 100 0._real64 / rate end function sysclock2ms subroutine std_unlink ( file ) character ( * ), intent ( in ) :: file integer :: u open ( newunit = u , file = file ) close ( u , status = \"delete\" ) end subroutine std_unlink subroutine bench_write ( file , layout , dat , N ) character ( * ), intent ( in ) :: file integer , intent ( in ) :: layout , N real , intent ( in ) :: dat (:) integer ( hid_t ) :: file_id integer ( int64 ) :: tic , toc integer :: ierr , i character ( 6 ) :: name CALL h5fcreate_f ( file , H5F_ACC_TRUNC_F , file_id , ierr ) if ( ierr /= 0 ) error stop \"problem creating \" // file call system_clock ( count = tic ) do i = 1 , N write ( name , '(A2,I0.4)' ) '/x' , i call write_layout ( file_id , name , layout , dat ) end do call system_clock ( count = toc ) print * , file , N , \"variables: elapsed millisec:\" , sysclock2ms ( toc - tic ) CALL h5fclose_f ( file_id , ierr ) end subroutine bench_write subroutine bench_read ( file , N , dat ) character ( * ), intent ( in ) :: file integer , intent ( in ) :: N real , intent ( out ), optional :: dat (:) integer ( hid_t ) :: file_id integer ( int64 ) :: tic , toc integer ( HSIZE_T ) :: dims ( rank ( dat )) integer :: ierr , i character ( 6 ) :: name real , allocatable :: dbuf (:) allocate ( dbuf ( N )) dims = shape ( dbuf ) CALL h5fopen_f ( file , H5F_ACC_RDONLY_F , file_id , ierr ) if ( ierr /= 0 ) error stop \"problem opening \" // file call system_clock ( count = tic ) do i = 1 , N write ( name , '(A2,I0.4)' ) '/x' , i call h5ltread_dataset_float_f ( file_id , name , dbuf , dims , ierr ) end do call system_clock ( count = toc ) print * , file , N , \"variables: elapsed millisec:\" , sysclock2ms ( toc - tic ) CALL h5fclose_f ( file_id , ierr ) end subroutine bench_read end module h5layout program compact use hdf5 use h5layout , only : bench_read , bench_write , std_unlink implicit none ( type , external ) integer :: N , M , ierr character (:), allocatable :: fn1 , fn2 , fn3 real , allocatable :: x (:) !< dummy data, could be any TKR N = 1000 M = 100 fn1 = \"bench_compact.h5\" fn2 = \"bench_contiguous.h5\" fn3 = \"bench_chunked.h5\" !> dummy data allocate ( x ( M )) !> Fortran interface CALL h5open_f ( ierr ) !------- compact call bench_write ( fn1 , H5D_COMPACT_F , x , N ) call bench_read ( fn1 , N ) !------- contiguous call bench_write ( fn2 , H5D_CONTIGUOUS_F , x , N ) call bench_read ( fn2 , N ) !-------- chunked call bench_write ( fn3 , H5D_CHUNKED_F , x , N ) call bench_read ( fn3 , N ) !---- cleanup call h5close_f ( ierr ) end program","tags":"","loc":"sourcefile/h5compact.f90.html"},{"title":"int64.f90 – Object-oriented Fortran 2008 HDF5 interface","text":"Contents Programs main_int64 Source Code int64.f90 Source Code program main_int64 !! hdf5 fortran interface can also read/write int64, but it's not in the h5lt interface use hdf5 use , intrinsic :: iso_fortran_env , only : int64 implicit none ( type , external ) integer :: ierr character (:), allocatable :: filename filename = \"int64.h5\" !> initialize fortran interface and file call h5open_f ( ierr ) call write_data ( filename ) call verify_data ( filename ) call h5close_f ( ierr ) contains subroutine verify_data ( filename ) character ( * ), intent ( in ) :: filename integer ( hid_t ) :: fid integer :: ierr call h5fopen_f ( filename , h5f_acc_rdonly_f , fid , ierr ) if ( read_int64 ( fid , \"/example\" ) /= 12345 ) error stop \"example not match\" if ( read_int64 ( fid , \"/big\" ) /= huge ( 0_int64 )) error stop \"huge not match\" call h5fclose_f ( fid , ierr ) end subroutine verify_data integer ( int64 ) function read_int64 ( fid , name ) result ( i ) integer ( hid_t ), intent ( in ) :: fid character ( * ), intent ( in ) :: name integer ( hid_t ) :: dsid call h5dopen_f ( fid , name , dsid , ierr ) if ( ierr /= 0 ) error stop \"dataset not opened: \" // name // \" in file: \" // filename CALL h5dread_f ( dsid , h5kind_to_type ( int64 , h5_integer_kind ), i , int ( shape ( i ), hsize_t ), ierr ) if ( ierr /= 0 ) error stop \"dataset not read: \" // name // \" in file: \" // filename call h5dclose_f ( dsid , ierr ) end function read_int64 subroutine write_data ( filename ) character ( * ), intent ( in ) :: filename integer ( hid_t ) :: fid integer :: ierr call h5fcreate_f ( filename , h5f_acc_trunc_f , fid , ierr ) call write_int64 ( fid , 12345_int64 , \"example\" ) call write_int64 ( fid , huge ( 0_int64 ), \"big\" ) !< 9223372036854775807 call h5fclose_f ( fid , ierr ) end subroutine write_data subroutine write_int64 ( fid , i , name ) integer ( hid_t ) :: fid integer ( int64 ), intent ( in ) :: i character ( * ), intent ( in ) :: name integer ( hid_t ) :: h5_kind_int64 , sid , dsid h5_kind_int64 = h5kind_to_type ( int64 , h5_integer_kind ) !> dataspace call h5screate_f ( h5s_scalar_f , sid , ierr ) !> create the dataset. call h5dcreate_f ( fid , name , h5_kind_int64 , sid , dsid , ierr ) !> write data call h5dwrite_f ( dsid , h5_kind_int64 , i , int ( shape ( i ), hsize_t ), ierr ) !> close handles call h5dclose_f ( dsid , ierr ) call h5sclose_f ( sid , ierr ) end subroutine write_int64 end program","tags":"","loc":"sourcefile/int64.f90.html"},{"title":"read.f90 – Object-oriented Fortran 2008 HDF5 interface","text":"Contents Submodules read Source Code read.f90 Source Code submodule ( h5fortran ) read !! This submodule is for reading HDF5 via submodules use hdf5 , only : h5dget_create_plist_f , & h5pget_layout_f , h5pget_chunk_f , & h5dget_type_f , h5tget_native_type_f , h5tget_class_f , H5Tget_order_f , h5tclose_f , h5tget_size_f , & H5T_DIR_ASCEND_F , H5T_INTEGER_F , H5T_FLOAT_F , H5T_STRING_F , H5T_STD_I64LE use H5LT , only : h5ltpath_valid_f implicit none ( type , external ) contains integer ( hid_t ) function get_native_dtype ( ds_id , dname , filename ) result ( native_dtype ) integer ( hid_t ), intent ( in ) :: ds_id character ( * ), intent ( in ) :: dname , filename integer ( hid_t ) :: dtype_id , native_dtype_id integer :: class integer :: ierr ! integer :: order, machine_order integer ( size_t ) :: size_bytes !> get the dataset variable type !! the \"type\" and \"native_type\" are just IDs, the final native type is composed from: !! * enddianness !! * generic type call h5dget_type_f ( ds_id , dtype_id , ierr ) if ( ierr /= 0 ) error stop 'h5fortran:reader: get internal dtype ' // dname // ' from ' // filename call h5tget_native_type_f ( dtype_id , H5T_DIR_ASCEND_F , native_dtype_id , ierr ) if ( ierr /= 0 ) error stop 'h5fortran:reader: get native dtype id ' // dname // ' from ' // filename !> we think endianness is handled by HDF5 ... ? ! call h5tget_order_f(native_dtype_id, order, ierr) ! if(ierr/=0) error stop 'h5fortran:reader: get endianness ' // dname // ' from ' // filename ! !> check dataset endianness matches machine (in future, could swap endianness if needed) ! call h5tget_order_f(H5T_NATIVE_INTEGER, machine_order, ierr) ! if(order /= machine_order) error stop 'h5fortran:reader: endianness does not match machine native ' // dname // ' from ' // filename !> compose datatype inferred call h5tget_class_f ( native_dtype_id , class , ierr ) if ( ierr /= 0 ) error stop 'h5fortran:reader: get class ' // dname // ' from ' // filename call h5tget_size_f ( native_dtype_id , size_bytes , ierr ) if ( ierr /= 0 ) error stop 'h5fortran:reader: get byte size ' // dname // ' from ' // filename call h5tclose_f ( dtype_id , ierr ) if ( ierr /= 0 ) error stop 'h5fortran:reader: closing dtype ' // dname // ' from ' // filename if ( class == H5T_INTEGER_F ) then if ( size_bytes == 4 ) then native_dtype = H5T_NATIVE_INTEGER elseif ( size_bytes == 8 ) then native_dtype = H5T_STD_I64LE else error stop \"h5fortran:reader: expected 32-bit or 64-bit integer:\" // dname // ' from ' // filename endif elseif ( class == H5T_FLOAT_F ) then if ( size_bytes == 4 ) then native_dtype = H5T_NATIVE_REAL elseif ( size_bytes == 8 ) then native_dtype = H5T_NATIVE_DOUBLE else error stop \"h5fortran:reader: expected 32-bit or 64-bit real:\" // dname // ' from ' // filename endif elseif ( class == H5T_STRING_F ) then native_dtype = H5T_NATIVE_CHARACTER else error stop \"h5fortran:reader: non-handled datatype: \" // dname // \" from \" // filename endif end function get_native_dtype module procedure hdf_get_ndims !! get rank or \"ndims\" integer :: ier if (. not . self % is_open ) error stop 'h5fortran:read: file handle is not open' drank = - 1 if ( self % exist ( dname )) then call h5ltget_dataset_ndims_f ( self % lid , dname , drank , ier ) else write ( stderr , * ) 'ERROR:get_ndims: ' // dname // ' does not exist in ' // self % filename endif end procedure hdf_get_ndims module procedure hdf_get_shape !! must get dims before info, as \"dims\" must be allocated or segfault occurs. integer ( SIZE_T ) :: dsize integer :: dtype , drank , ier if (. not . self % is_open ) error stop 'h5fortran:get_shape: file handle is not open' ier = - 1 if ( self % exist ( dname )) then call h5ltget_dataset_ndims_f ( self % lid , dname , drank , ier ) else write ( stderr , * ) 'ERROR:get_shape: ' // dname // ' does not exist in ' // self % filename endif if ( ier == 0 ) then allocate ( dims ( drank )) call h5ltget_dataset_info_f ( self % lid , dname , dims , dtype , dsize , ier ) endif if ( present ( ierr )) ierr = ier if ( ier /= 0 ) then if ( present ( ierr )) return error stop endif end procedure hdf_get_shape module procedure hdf_get_chunk integer :: ierr , drank integer ( HID_T ) :: pid , did if (. not . self % is_open ) error stop 'h5fortran:read: file handle is not open' chunk_size = - 1 if (. not . self % exist ( dname )) then write ( stderr , * ) 'ERROR:get_chunk: ' // dname // ' does not exist in ' // self % filename ierr = - 1 return endif if (. not . self % is_chunked ( dname )) return call h5ltget_dataset_ndims_f ( self % lid , dname , drank , ierr ) if ( check ( ierr , 'ERROR:get_chunk: get rank ' // dname // ' ' // self % filename )) return call h5dopen_f ( self % lid , dname , did , ierr ) if ( check ( ierr , 'ERROR:get_chunk: open dataset ' // dname // ' ' // self % filename )) return call h5dget_create_plist_f ( did , pid , ierr ) if ( check ( ierr , 'ERROR:get_chunk: get property list ID ' // dname // ' ' // self % filename )) return call h5pget_chunk_f ( pid , drank , chunk_size , ierr ) if ( ierr /= drank ) then write ( stderr , * ) 'ERROR:get_chunk read ' // dname // ' ' // self % filename return endif call h5dclose_f ( did , ierr ) if ( check ( ierr , 'ERROR:get_chunk: close dataset: ' // dname // ' ' // self % filename )) return end procedure hdf_get_chunk module procedure hdf_get_layout integer ( HID_T ) :: pid , did integer :: ierr if (. not . self % is_open ) error stop 'h5fortran:read: file handle is not open' layout = - 1 if (. not . self % exist ( dname )) then write ( stderr , * ) 'ERROR:get_layout: ' // dname // ' does not exist in ' // self % filename return endif call h5dopen_f ( self % lid , dname , did , ierr ) if ( check ( ierr , 'ERROR:get_layout: open dataset ' // dname // ' ' // self % filename )) return call h5dget_create_plist_f ( did , pid , ierr ) if ( check ( ierr , 'ERROR:get_layout: get property list ID ' // dname // ' ' // self % filename )) return call h5pget_layout_f ( pid , layout , ierr ) if ( check ( ierr , 'ERROR:get_layout read ' // dname // ' ' // self % filename )) return call h5dclose_f ( did , ierr ) if ( check ( ierr , 'ERROR:get_layout: close dataset: ' // dname // ' ' // self % filename )) return end procedure hdf_get_layout module procedure hdf_check_exist integer :: ierr exists = . false . if (. not . self % is_open ) error stop 'h5fortran:exist: file handle is not open' call h5ltpath_valid_f ( self % lid , dname , . true ., exists , ierr ) !! h5lexists_f can false error with groups--just use h5ltpath_valid if ( ierr /= 0 ) then write ( stderr , * ) 'ERROR:h5fortran:check_exist: could not determine status of ' // dname // ' in ' // self % filename return endif end procedure hdf_check_exist end submodule read","tags":"","loc":"sourcefile/read.f90.html"},{"title":"reader.f90 – Object-oriented Fortran 2008 HDF5 interface","text":"Contents Submodules reader Source Code reader.f90 Source Code submodule ( h5fortran : read ) reader !! This submodule is for reading 0-D..7-D data use hdf5 , only : h5dread_f use h5lt , only : h5ltread_dataset_string_f implicit none ( type , external ) contains module procedure hdf_read_scalar real ( real32 ) :: buf_r32 real ( real64 ) :: buf_r64 integer ( int32 ) :: buf_i32 integer ( int64 ) :: buf_i64 integer ( HSIZE_T ) :: dims ( rank ( value )) integer ( hid_t ) :: ds_id , space_id , native_dtype integer :: ier if (. not . self % is_open ) error stop 'h5fortran:reader: file handle is not open' space_id = 0 if (. not . self % exist ( dname )) error stop 'h5fortran:reader: ' // dname // ' does not exist in ' // self % filename call h5dopen_f ( self % lid , dname , ds_id , ier ) if ( ier /= 0 ) error stop 'h5fortran:reader: ' // dname // ' could not be opened in ' // self % filename native_dtype = get_native_dtype ( ds_id , dname , self % filename ) select type ( value ) type is ( character ( * )) call hdf_wrapup ( ds_id , space_id , ier ) !< FIXME: till character is treated same as other types if ( native_dtype /= H5T_NATIVE_CHARACTER ) error stop \"h5fortran:reader: non-character variable: \" // dname // \" in \" // self % filename block character ( len ( value )) :: buf call h5ltread_dataset_string_f ( self % lid , dname , buf , ier ) value = buf end block return end select !> cast the dataset read from disk to the variable type presented by user h5f%read(\"/my_dataset\", x) !> We only cast when needed to save memory. if ( native_dtype == H5T_NATIVE_DOUBLE ) then !! select case doesn't allow H5T_* select type ( value ) type is ( real ( real64 )) call h5dread_f ( ds_id , H5T_NATIVE_DOUBLE , value , dims , ier ) type is ( real ( real32 )) call h5dread_f ( ds_id , H5T_NATIVE_DOUBLE , buf_r64 , dims , ier ) value = real ( buf_r64 , real32 ) type is ( integer ( int32 )) call h5dread_f ( ds_id , H5T_NATIVE_DOUBLE , buf_r64 , dims , ier ) value = int ( buf_r64 , int32 ) type is ( integer ( int64 )) call h5dread_f ( ds_id , H5T_NATIVE_DOUBLE , buf_r64 , dims , ier ) value = int ( buf_r64 , int64 ) class default error stop 'unknown variable type' end select elseif ( native_dtype == H5T_NATIVE_REAL ) then select type ( value ) type is ( real ( real64 )) call h5dread_f ( ds_id , H5T_NATIVE_REAL , buf_r32 , dims , ier ) value = real ( buf_r32 , real64 ) type is ( real ( real32 )) call h5dread_f ( ds_id , H5T_NATIVE_REAL , value , dims , ier ) type is ( integer ( int32 )) call h5dread_f ( ds_id , H5T_NATIVE_REAL , buf_r32 , dims , ier ) value = int ( buf_r32 , int32 ) type is ( integer ( int64 )) call h5dread_f ( ds_id , H5T_NATIVE_REAL , buf_r32 , dims , ier ) value = int ( buf_r32 , int64 ) class default error stop 'unknown variable type' end select elseif ( native_dtype == H5T_NATIVE_INTEGER ) then select type ( value ) type is ( real ( real64 )) call h5dread_f ( ds_id , H5T_NATIVE_INTEGER , buf_i32 , dims , ier ) value = real ( buf_i32 , real64 ) type is ( real ( real32 )) call h5dread_f ( ds_id , H5T_NATIVE_INTEGER , buf_i32 , dims , ier ) value = real ( buf_i32 , real32 ) type is ( integer ( int32 )) call h5dread_f ( ds_id , H5T_NATIVE_INTEGER , value , dims , ier ) type is ( integer ( int64 )) call h5dread_f ( ds_id , H5T_NATIVE_INTEGER , buf_i32 , dims , ier ) value = int ( buf_i32 , int64 ) class default error stop 'unknown variable type' end select elseif ( native_dtype == H5T_STD_I64LE ) then select type ( value ) type is ( real ( real64 )) call h5dread_f ( ds_id , H5T_STD_I64LE , buf_i64 , dims , ier ) value = real ( buf_i64 , real64 ) type is ( real ( real32 )) call h5dread_f ( ds_id , H5T_STD_I64LE , buf_i64 , dims , ier ) value = real ( buf_i64 , real32 ) type is ( integer ( int32 )) call h5dread_f ( ds_id , H5T_STD_I64LE , buf_i64 , dims , ier ) value = int ( buf_i64 , int32 ) type is ( integer ( int64 )) call h5dread_f ( ds_id , H5T_STD_I64LE , value , dims , ier ) class default error stop 'unknown variable type' end select else error stop 'h5fortran:reader: non-handled datatype--please reach out to developers.' end if if ( ier /= 0 ) error stop 'h5fortran:reader: reading ' // dname // ' from ' // self % filename call hdf_wrapup ( ds_id , space_id , ier ) if ( present ( ierr )) ierr = ier if ( check ( ier , self % filename , dname ) . and . . not . present ( ierr )) error stop end procedure hdf_read_scalar module procedure hdf_read_1d real ( real32 ), allocatable :: buf_r32 (:) real ( real64 ), allocatable :: buf_r64 (:) integer ( int32 ), allocatable :: buf_i32 (:) integer ( int64 ), allocatable :: buf_i64 (:) integer ( HSIZE_T ) :: dims ( rank ( value )) integer ( HID_T ) :: ds_id , space_id , mem_space_id , native_dtype integer :: ier ds_id = 0 !< sentinel space_id = H5S_ALL_F mem_space_id = H5S_ALL_F dims = shape ( value ) if ( present ( istart ) . and . present ( iend )) then if ( present ( stride )) then !! necessary to use this present check for Intel and GCC call hdf_get_slice ( self , dname , ds_id , space_id , mem_space_id , istart , iend , stride ) else call hdf_get_slice ( self , dname , ds_id , space_id , mem_space_id , istart , iend ) endif else call hdf_shape_check ( self , dname , dims ) call h5dopen_f ( self % lid , dname , ds_id , ier ) if ( ier /= 0 ) error stop 'h5fortran:reader: setup read ' // dname // ' from ' // self % filename endif native_dtype = get_native_dtype ( ds_id , dname , self % filename ) !> cast the dataset read from disk to the variable type presented by user h5f%read(\"/my_dataset\", x) !> We only cast when needed to save memory. if ( native_dtype == H5T_NATIVE_DOUBLE ) then !! select case doesn't allow H5T_* select type ( value ) type is ( real ( real64 )) call h5dread_f ( ds_id , H5T_NATIVE_DOUBLE , value , dims , ier , mem_space_id , space_id ) type is ( real ( real32 )) allocate ( buf_r64 ( size ( value , 1 ))) call h5dread_f ( ds_id , H5T_NATIVE_DOUBLE , buf_r64 , dims , ier , mem_space_id , space_id ) value = real ( buf_r64 , real32 ) type is ( integer ( int32 )) allocate ( buf_r64 ( size ( value , 1 ))) call h5dread_f ( ds_id , H5T_NATIVE_DOUBLE , buf_r64 , dims , ier , mem_space_id , space_id ) value = int ( buf_r64 , int32 ) type is ( integer ( int64 )) allocate ( buf_r64 ( size ( value , 1 ))) call h5dread_f ( ds_id , H5T_NATIVE_DOUBLE , buf_r64 , dims , ier , mem_space_id , space_id ) value = int ( buf_r64 , int64 ) class default error stop 'unknown variable type' end select elseif ( native_dtype == H5T_NATIVE_REAL ) then select type ( value ) type is ( real ( real64 )) allocate ( buf_r32 ( size ( value , 1 ))) call h5dread_f ( ds_id , H5T_NATIVE_REAL , buf_r32 , dims , ier , mem_space_id , space_id ) value = real ( buf_r32 , real64 ) type is ( real ( real32 )) call h5dread_f ( ds_id , H5T_NATIVE_REAL , value , dims , ier , mem_space_id , space_id ) type is ( integer ( int32 )) allocate ( buf_r32 ( size ( value , 1 ))) call h5dread_f ( ds_id , H5T_NATIVE_REAL , buf_r32 , dims , ier , mem_space_id , space_id ) value = int ( buf_r32 , int32 ) type is ( integer ( int64 )) allocate ( buf_r32 ( size ( value , 1 ))) call h5dread_f ( ds_id , H5T_NATIVE_REAL , buf_r32 , dims , ier , mem_space_id , space_id ) value = int ( buf_r32 , int64 ) class default error stop 'unknown variable type' end select elseif ( native_dtype == H5T_NATIVE_INTEGER ) then select type ( value ) type is ( real ( real64 )) allocate ( buf_i32 ( size ( value , 1 ))) call h5dread_f ( ds_id , H5T_NATIVE_INTEGER , buf_i32 , dims , ier , mem_space_id , space_id ) value = real ( buf_i32 , real64 ) type is ( real ( real32 )) allocate ( buf_i32 ( size ( value , 1 ))) call h5dread_f ( ds_id , H5T_NATIVE_INTEGER , buf_i32 , dims , ier , mem_space_id , space_id ) value = real ( buf_i32 , real32 ) type is ( integer ( int32 )) call h5dread_f ( ds_id , H5T_NATIVE_INTEGER , value , dims , ier , mem_space_id , space_id ) type is ( integer ( int64 )) allocate ( buf_i32 ( size ( value , 1 ))) call h5dread_f ( ds_id , H5T_NATIVE_INTEGER , buf_i32 , dims , ier , mem_space_id , space_id ) value = int ( buf_i32 , int64 ) class default error stop 'unknown variable type' end select elseif ( native_dtype == H5T_STD_I64LE ) then select type ( value ) type is ( real ( real64 )) allocate ( buf_i64 ( size ( value , 1 ))) call h5dread_f ( ds_id , H5T_STD_I64LE , buf_i64 , dims , ier , mem_space_id , space_id ) value = real ( buf_i64 , real64 ) type is ( real ( real32 )) allocate ( buf_i64 ( size ( value , 1 ))) call h5dread_f ( ds_id , H5T_STD_I64LE , buf_i64 , dims , ier , mem_space_id , space_id ) value = real ( buf_i64 , real32 ) type is ( integer ( int32 )) allocate ( buf_i64 ( size ( value , 1 ))) call h5dread_f ( ds_id , H5T_STD_I64LE , buf_i64 , dims , ier , mem_space_id , space_id ) value = int ( buf_i64 , int32 ) type is ( integer ( int64 )) call h5dread_f ( ds_id , H5T_STD_I64LE , value , dims , ier , mem_space_id , space_id ) class default error stop 'unknown variable type' end select else error stop 'h5fortran:reader: non-handled datatype--please reach out to developers.' end if if ( ier /= 0 ) error stop 'h5fortran:reader: reading ' // dname // ' from ' // self % filename call hdf_wrapup ( ds_id , space_id , ier ) if ( present ( ierr )) ierr = ier if ( check ( ier , self % filename , dname ) . and . . not . present ( ierr )) error stop end procedure hdf_read_1d module procedure hdf_read_2d real ( real32 ), allocatable :: buf_r32 (:,:) real ( real64 ), allocatable :: buf_r64 (:,:) integer ( int32 ), allocatable :: buf_i32 (:,:) integer ( int64 ), allocatable :: buf_i64 (:,:) integer ( HSIZE_T ) :: dims ( rank ( value )) integer ( HID_T ) :: ds_id , space_id , mem_space_id , native_dtype integer :: ier ds_id = 0 !< sentinel space_id = H5S_ALL_F mem_space_id = H5S_ALL_F dims = shape ( value ) if ( present ( istart ) . and . present ( iend )) then if ( present ( stride )) then !! necessary to use this present check for Intel and GCC call hdf_get_slice ( self , dname , ds_id , space_id , mem_space_id , istart , iend , stride ) else call hdf_get_slice ( self , dname , ds_id , space_id , mem_space_id , istart , iend ) endif else call hdf_shape_check ( self , dname , dims ) call h5dopen_f ( self % lid , dname , ds_id , ier ) if ( ier /= 0 ) error stop 'h5fortran:reader: setup read ' // dname // ' from ' // self % filename endif native_dtype = get_native_dtype ( ds_id , dname , self % filename ) !> cast the dataset read from disk to the variable type presented by user h5f%read(\"/my_dataset\", x) !> We only cast when needed to save memory. if ( native_dtype == H5T_NATIVE_DOUBLE ) then !! select case doesn't allow H5T_* select type ( value ) type is ( real ( real64 )) call h5dread_f ( ds_id , H5T_NATIVE_DOUBLE , value , dims , ier , mem_space_id , space_id ) type is ( real ( real32 )) allocate ( buf_r64 ( size ( value , 1 ), size ( value , 2 ))) call h5dread_f ( ds_id , H5T_NATIVE_DOUBLE , buf_r64 , dims , ier , mem_space_id , space_id ) value = real ( buf_r64 , real32 ) type is ( integer ( int32 )) allocate ( buf_r64 ( size ( value , 1 ), size ( value , 2 ))) call h5dread_f ( ds_id , H5T_NATIVE_DOUBLE , buf_r64 , dims , ier , mem_space_id , space_id ) value = int ( buf_r64 , int32 ) type is ( integer ( int64 )) allocate ( buf_r64 ( size ( value , 1 ), size ( value , 2 ))) call h5dread_f ( ds_id , H5T_NATIVE_DOUBLE , buf_r64 , dims , ier , mem_space_id , space_id ) value = int ( buf_r64 , int64 ) class default error stop 'unknown variable type' end select elseif ( native_dtype == H5T_NATIVE_REAL ) then select type ( value ) type is ( real ( real64 )) allocate ( buf_r32 ( size ( value , 1 ), size ( value , 2 ))) call h5dread_f ( ds_id , H5T_NATIVE_REAL , buf_r32 , dims , ier , mem_space_id , space_id ) value = real ( buf_r32 , real64 ) type is ( real ( real32 )) call h5dread_f ( ds_id , H5T_NATIVE_REAL , value , dims , ier , mem_space_id , space_id ) type is ( integer ( int32 )) allocate ( buf_r32 ( size ( value , 1 ), size ( value , 2 ))) call h5dread_f ( ds_id , H5T_NATIVE_REAL , buf_r32 , dims , ier , mem_space_id , space_id ) value = int ( buf_r32 , int32 ) type is ( integer ( int64 )) allocate ( buf_r32 ( size ( value , 1 ), size ( value , 2 ))) call h5dread_f ( ds_id , H5T_NATIVE_REAL , buf_r32 , dims , ier , mem_space_id , space_id ) value = int ( buf_r32 , int64 ) class default error stop 'unknown variable type' end select elseif ( native_dtype == H5T_NATIVE_INTEGER ) then select type ( value ) type is ( real ( real64 )) allocate ( buf_i32 ( size ( value , 1 ), size ( value , 2 ))) call h5dread_f ( ds_id , H5T_NATIVE_INTEGER , buf_i32 , dims , ier , mem_space_id , space_id ) value = real ( buf_i32 , real64 ) type is ( real ( real32 )) allocate ( buf_i32 ( size ( value , 1 ), size ( value , 2 ))) call h5dread_f ( ds_id , H5T_NATIVE_INTEGER , buf_i32 , dims , ier , mem_space_id , space_id ) value = real ( buf_i32 , real32 ) type is ( integer ( int32 )) call h5dread_f ( ds_id , H5T_NATIVE_INTEGER , value , dims , ier , mem_space_id , space_id ) type is ( integer ( int64 )) allocate ( buf_i32 ( size ( value , 1 ), size ( value , 2 ))) call h5dread_f ( ds_id , H5T_NATIVE_INTEGER , buf_i32 , dims , ier , mem_space_id , space_id ) value = int ( buf_i32 , int64 ) class default error stop 'unknown variable type' end select elseif ( native_dtype == H5T_STD_I64LE ) then select type ( value ) type is ( real ( real64 )) allocate ( buf_i64 ( size ( value , 1 ), size ( value , 2 ))) call h5dread_f ( ds_id , H5T_STD_I64LE , buf_i64 , dims , ier , mem_space_id , space_id ) value = real ( buf_i64 , real64 ) type is ( real ( real32 )) allocate ( buf_i64 ( size ( value , 1 ), size ( value , 2 ))) call h5dread_f ( ds_id , H5T_STD_I64LE , buf_i64 , dims , ier , mem_space_id , space_id ) value = real ( buf_i64 , real32 ) type is ( integer ( int32 )) allocate ( buf_i64 ( size ( value , 1 ), size ( value , 2 ))) call h5dread_f ( ds_id , H5T_STD_I64LE , buf_i64 , dims , ier , mem_space_id , space_id ) value = int ( buf_i64 , int32 ) type is ( integer ( int64 )) call h5dread_f ( ds_id , H5T_STD_I64LE , value , dims , ier , mem_space_id , space_id ) class default error stop 'unknown variable type' end select else error stop 'h5fortran:reader: non-handled datatype--please reach out to developers.' end if if ( ier /= 0 ) error stop 'h5fortran:reader: reading ' // dname // ' from ' // self % filename call hdf_wrapup ( ds_id , space_id , ier ) if ( present ( ierr )) ierr = ier if ( check ( ier , self % filename , dname ) . and . . not . present ( ierr )) error stop end procedure hdf_read_2d module procedure hdf_read_3d real ( real32 ), allocatable :: buf_r32 (:,:,:) real ( real64 ), allocatable :: buf_r64 (:,:,:) integer ( int32 ), allocatable :: buf_i32 (:,:,:) integer ( int64 ), allocatable :: buf_i64 (:,:,:) integer ( HSIZE_T ) :: dims ( rank ( value )) integer ( HID_T ) :: ds_id , space_id , mem_space_id , native_dtype integer :: ier ds_id = 0 !< sentinel space_id = H5S_ALL_F mem_space_id = H5S_ALL_F dims = shape ( value ) if ( present ( istart ) . and . present ( iend )) then if ( present ( stride )) then !! necessary to use this present check for Intel and GCC call hdf_get_slice ( self , dname , ds_id , space_id , mem_space_id , istart , iend , stride ) else call hdf_get_slice ( self , dname , ds_id , space_id , mem_space_id , istart , iend ) endif else call hdf_shape_check ( self , dname , dims ) call h5dopen_f ( self % lid , dname , ds_id , ier ) if ( ier /= 0 ) error stop 'h5fortran:reader: setup read ' // dname // ' from ' // self % filename endif native_dtype = get_native_dtype ( ds_id , dname , self % filename ) !> cast the dataset read from disk to the variable type presented by user h5f%read(\"/my_dataset\", x) !> We only cast when needed to save memory. if ( native_dtype == H5T_NATIVE_DOUBLE ) then !! select case doesn't allow H5T_* select type ( value ) type is ( real ( real64 )) call h5dread_f ( ds_id , H5T_NATIVE_DOUBLE , value , dims , ier , mem_space_id , space_id ) type is ( real ( real32 )) allocate ( buf_r64 ( size ( value , 1 ), size ( value , 2 ), size ( value , 3 ))) call h5dread_f ( ds_id , H5T_NATIVE_DOUBLE , buf_r64 , dims , ier , mem_space_id , space_id ) value = real ( buf_r64 , real32 ) type is ( integer ( int32 )) allocate ( buf_r64 ( size ( value , 1 ), size ( value , 2 ), size ( value , 3 ))) call h5dread_f ( ds_id , H5T_NATIVE_DOUBLE , buf_r64 , dims , ier , mem_space_id , space_id ) value = int ( buf_r64 , int32 ) type is ( integer ( int64 )) allocate ( buf_r64 ( size ( value , 1 ), size ( value , 2 ), size ( value , 3 ))) call h5dread_f ( ds_id , H5T_NATIVE_DOUBLE , buf_r64 , dims , ier , mem_space_id , space_id ) value = int ( buf_r64 , int64 ) class default error stop 'unknown variable type' end select elseif ( native_dtype == H5T_NATIVE_REAL ) then select type ( value ) type is ( real ( real64 )) allocate ( buf_r32 ( size ( value , 1 ), size ( value , 2 ), size ( value , 3 ))) call h5dread_f ( ds_id , H5T_NATIVE_REAL , buf_r32 , dims , ier , mem_space_id , space_id ) value = real ( buf_r32 , real64 ) type is ( real ( real32 )) call h5dread_f ( ds_id , H5T_NATIVE_REAL , value , dims , ier , mem_space_id , space_id ) type is ( integer ( int32 )) allocate ( buf_r32 ( size ( value , 1 ), size ( value , 2 ), size ( value , 3 ))) call h5dread_f ( ds_id , H5T_NATIVE_REAL , buf_r32 , dims , ier , mem_space_id , space_id ) value = int ( buf_r32 , int32 ) type is ( integer ( int64 )) allocate ( buf_r32 ( size ( value , 1 ), size ( value , 2 ), size ( value , 3 ))) call h5dread_f ( ds_id , H5T_NATIVE_REAL , buf_r32 , dims , ier , mem_space_id , space_id ) value = int ( buf_r32 , int64 ) class default error stop 'unknown variable type' end select elseif ( native_dtype == H5T_NATIVE_INTEGER ) then select type ( value ) type is ( real ( real64 )) allocate ( buf_i32 ( size ( value , 1 ), size ( value , 2 ), size ( value , 3 ))) call h5dread_f ( ds_id , H5T_NATIVE_INTEGER , buf_i32 , dims , ier , mem_space_id , space_id ) value = real ( buf_i32 , real64 ) type is ( real ( real32 )) allocate ( buf_i32 ( size ( value , 1 ), size ( value , 2 ), size ( value , 3 ))) call h5dread_f ( ds_id , H5T_NATIVE_INTEGER , buf_i32 , dims , ier , mem_space_id , space_id ) value = real ( buf_i32 , real32 ) type is ( integer ( int32 )) call h5dread_f ( ds_id , H5T_NATIVE_INTEGER , value , dims , ier , mem_space_id , space_id ) type is ( integer ( int64 )) allocate ( buf_i32 ( size ( value , 1 ), size ( value , 2 ), size ( value , 3 ))) call h5dread_f ( ds_id , H5T_NATIVE_INTEGER , buf_i32 , dims , ier , mem_space_id , space_id ) value = int ( buf_i32 , int64 ) class default error stop 'unknown variable type' end select elseif ( native_dtype == H5T_STD_I64LE ) then select type ( value ) type is ( real ( real64 )) allocate ( buf_i64 ( size ( value , 1 ), size ( value , 2 ), size ( value , 3 ))) call h5dread_f ( ds_id , H5T_STD_I64LE , buf_i64 , dims , ier , mem_space_id , space_id ) value = real ( buf_i64 , real64 ) type is ( real ( real32 )) allocate ( buf_i64 ( size ( value , 1 ), size ( value , 2 ), size ( value , 3 ))) call h5dread_f ( ds_id , H5T_STD_I64LE , buf_i64 , dims , ier , mem_space_id , space_id ) value = real ( buf_i64 , real32 ) type is ( integer ( int32 )) allocate ( buf_i64 ( size ( value , 1 ), size ( value , 2 ), size ( value , 3 ))) call h5dread_f ( ds_id , H5T_STD_I64LE , buf_i64 , dims , ier , mem_space_id , space_id ) value = int ( buf_i64 , int32 ) type is ( integer ( int64 )) call h5dread_f ( ds_id , H5T_STD_I64LE , value , dims , ier , mem_space_id , space_id ) class default error stop 'unknown variable type' end select else error stop 'h5fortran:reader: non-handled datatype--please reach out to developers.' end if if ( ier /= 0 ) error stop 'h5fortran:reader: reading ' // dname // ' from ' // self % filename call hdf_wrapup ( ds_id , space_id , ier ) if ( present ( ierr )) ierr = ier if ( check ( ier , self % filename , dname ) . and . . not . present ( ierr )) error stop end procedure hdf_read_3d module procedure hdf_read_4d real ( real32 ), allocatable :: buf_r32 (:,:,:,:) real ( real64 ), allocatable :: buf_r64 (:,:,:,:) integer ( int32 ), allocatable :: buf_i32 (:,:,:,:) integer ( HSIZE_T ) :: dims ( rank ( value )) integer ( HID_T ) :: ds_id , space_id , mem_space_id , native_dtype integer :: ier ds_id = 0 !< sentinel space_id = H5S_ALL_F mem_space_id = H5S_ALL_F dims = shape ( value ) if ( present ( istart ) . and . present ( iend )) then if ( present ( stride )) then !! necessary to use this present check for Intel and GCC call hdf_get_slice ( self , dname , ds_id , space_id , mem_space_id , istart , iend , stride ) else call hdf_get_slice ( self , dname , ds_id , space_id , mem_space_id , istart , iend ) endif else call hdf_shape_check ( self , dname , dims ) call h5dopen_f ( self % lid , dname , ds_id , ier ) if ( ier /= 0 ) error stop 'h5fortran:reader: setup read ' // dname // ' from ' // self % filename endif native_dtype = get_native_dtype ( ds_id , dname , self % filename ) !> cast the dataset read from disk to the variable type presented by user h5f%read(\"/my_dataset\", x) !> We only cast when needed to save memory. if ( native_dtype == H5T_NATIVE_DOUBLE ) then !! select case doesn't allow H5T_* select type ( value ) type is ( real ( real64 )) call h5dread_f ( ds_id , H5T_NATIVE_DOUBLE , value , dims , ier , mem_space_id , space_id ) type is ( real ( real32 )) allocate ( buf_r64 ( size ( value , 1 ), size ( value , 2 ), size ( value , 3 ), size ( value , 4 ))) call h5dread_f ( ds_id , H5T_NATIVE_DOUBLE , buf_r64 , dims , ier , mem_space_id , space_id ) value = real ( buf_r64 , real32 ) type is ( integer ( int32 )) allocate ( buf_r64 ( size ( value , 1 ), size ( value , 2 ), size ( value , 3 ), size ( value , 4 ))) call h5dread_f ( ds_id , H5T_NATIVE_DOUBLE , buf_r64 , dims , ier , mem_space_id , space_id ) value = int ( buf_r64 , int32 ) class default error stop 'unknown variable type' end select elseif ( native_dtype == H5T_NATIVE_REAL ) then select type ( value ) type is ( real ( real64 )) allocate ( buf_r32 ( size ( value , 1 ), size ( value , 2 ), size ( value , 3 ), size ( value , 4 ))) call h5dread_f ( ds_id , H5T_NATIVE_REAL , buf_r32 , dims , ier , mem_space_id , space_id ) value = real ( buf_r32 , real64 ) type is ( real ( real32 )) call h5dread_f ( ds_id , H5T_NATIVE_REAL , value , dims , ier , mem_space_id , space_id ) type is ( integer ( int32 )) allocate ( buf_r32 ( size ( value , 1 ), size ( value , 2 ), size ( value , 3 ), size ( value , 4 ))) call h5dread_f ( ds_id , H5T_NATIVE_REAL , buf_r32 , dims , ier , mem_space_id , space_id ) value = int ( buf_r32 , int32 ) class default error stop 'unknown variable type' end select elseif ( native_dtype == H5T_NATIVE_INTEGER ) then select type ( value ) type is ( real ( real64 )) allocate ( buf_i32 ( size ( value , 1 ), size ( value , 2 ), size ( value , 3 ), size ( value , 4 ))) call h5dread_f ( ds_id , H5T_NATIVE_INTEGER , buf_i32 , dims , ier , mem_space_id , space_id ) value = real ( buf_i32 , real64 ) type is ( real ( real32 )) allocate ( buf_i32 ( size ( value , 1 ), size ( value , 2 ), size ( value , 3 ), size ( value , 4 ))) call h5dread_f ( ds_id , H5T_NATIVE_INTEGER , buf_i32 , dims , ier , mem_space_id , space_id ) value = real ( buf_i32 , real32 ) type is ( integer ( int32 )) call h5dread_f ( ds_id , H5T_NATIVE_INTEGER , value , dims , ier , mem_space_id , space_id ) class default error stop 'unknown variable type' end select else error stop 'h5fortran:reader: non-handled datatype--please reach out to developers.' end if if ( ier /= 0 ) error stop 'h5fortran:reader: reading ' // dname // ' from ' // self % filename call hdf_wrapup ( ds_id , space_id , ier ) if ( present ( ierr )) ierr = ier if ( check ( ier , self % filename , dname ) . and . . not . present ( ierr )) error stop end procedure hdf_read_4d module procedure hdf_read_5d real ( real32 ), allocatable :: buf_r32 (:,:,:,:,:) real ( real64 ), allocatable :: buf_r64 (:,:,:,:,:) integer ( int32 ), allocatable :: buf_i32 (:,:,:,:,:) integer ( HSIZE_T ) :: dims ( rank ( value )) integer ( HID_T ) :: ds_id , space_id , mem_space_id , native_dtype integer :: ier ds_id = 0 !< sentinel space_id = H5S_ALL_F mem_space_id = H5S_ALL_F dims = shape ( value ) if ( present ( istart ) . and . present ( iend )) then if ( present ( stride )) then !! necessary to use this present check for Intel and GCC call hdf_get_slice ( self , dname , ds_id , space_id , mem_space_id , istart , iend , stride ) else call hdf_get_slice ( self , dname , ds_id , space_id , mem_space_id , istart , iend ) endif else call hdf_shape_check ( self , dname , dims ) call h5dopen_f ( self % lid , dname , ds_id , ier ) if ( ier /= 0 ) error stop 'h5fortran:reader: setup read ' // dname // ' from ' // self % filename endif native_dtype = get_native_dtype ( ds_id , dname , self % filename ) !> cast the dataset read from disk to the variable type presented by user h5f%read(\"/my_dataset\", x) !> We only cast when needed to save memory. if ( native_dtype == H5T_NATIVE_DOUBLE ) then !! select case doesn't allow H5T_* select type ( value ) type is ( real ( real64 )) call h5dread_f ( ds_id , H5T_NATIVE_DOUBLE , value , dims , ier , mem_space_id , space_id ) type is ( real ( real32 )) allocate ( buf_r64 ( size ( value , 1 ), size ( value , 2 ), size ( value , 3 ), size ( value , 4 ), size ( value , 5 ))) call h5dread_f ( ds_id , H5T_NATIVE_DOUBLE , buf_r64 , dims , ier , mem_space_id , space_id ) value = real ( buf_r64 , real32 ) type is ( integer ( int32 )) allocate ( buf_r64 ( size ( value , 1 ), size ( value , 2 ), size ( value , 3 ), size ( value , 4 ), size ( value , 5 ))) call h5dread_f ( ds_id , H5T_NATIVE_DOUBLE , buf_r64 , dims , ier , mem_space_id , space_id ) value = int ( buf_r64 , int32 ) class default error stop 'unknown variable type' end select elseif ( native_dtype == H5T_NATIVE_REAL ) then select type ( value ) type is ( real ( real64 )) allocate ( buf_r32 ( size ( value , 1 ), size ( value , 2 ), size ( value , 3 ), size ( value , 4 ), size ( value , 5 ))) call h5dread_f ( ds_id , H5T_NATIVE_REAL , buf_r32 , dims , ier , mem_space_id , space_id ) value = real ( buf_r32 , real64 ) type is ( real ( real32 )) call h5dread_f ( ds_id , H5T_NATIVE_REAL , value , dims , ier , mem_space_id , space_id ) type is ( integer ( int32 )) allocate ( buf_r32 ( size ( value , 1 ), size ( value , 2 ), size ( value , 3 ), size ( value , 4 ), size ( value , 5 ))) call h5dread_f ( ds_id , H5T_NATIVE_REAL , buf_r32 , dims , ier , mem_space_id , space_id ) value = int ( buf_r32 , int32 ) class default error stop 'unknown variable type' end select elseif ( native_dtype == H5T_NATIVE_INTEGER ) then select type ( value ) type is ( real ( real64 )) allocate ( buf_i32 ( size ( value , 1 ), size ( value , 2 ), size ( value , 3 ), size ( value , 4 ), size ( value , 5 ))) call h5dread_f ( ds_id , H5T_NATIVE_INTEGER , buf_i32 , dims , ier , mem_space_id , space_id ) value = real ( buf_i32 , real64 ) type is ( real ( real32 )) allocate ( buf_i32 ( size ( value , 1 ), size ( value , 2 ), size ( value , 3 ), size ( value , 4 ), size ( value , 5 ))) call h5dread_f ( ds_id , H5T_NATIVE_INTEGER , buf_i32 , dims , ier , mem_space_id , space_id ) value = real ( buf_i32 , real32 ) type is ( integer ( int32 )) call h5dread_f ( ds_id , H5T_NATIVE_INTEGER , value , dims , ier , mem_space_id , space_id ) class default error stop 'unknown variable type' end select else error stop 'h5fortran:reader: non-handled datatype--please reach out to developers.' end if if ( ier /= 0 ) error stop 'h5fortran:reader: reading ' // dname // ' from ' // self % filename call hdf_wrapup ( ds_id , space_id , ier ) if ( present ( ierr )) ierr = ier if ( check ( ier , self % filename , dname ) . and . . not . present ( ierr )) error stop end procedure hdf_read_5d module procedure hdf_read_6d real ( real32 ), allocatable :: buf_r32 (:,:,:,:,:,:) real ( real64 ), allocatable :: buf_r64 (:,:,:,:,:,:) integer ( int32 ), allocatable :: buf_i32 (:,:,:,:,:,:) integer ( HSIZE_T ) :: dims ( rank ( value )) integer ( HID_T ) :: ds_id , space_id , mem_space_id , native_dtype integer :: ier ds_id = 0 !< sentinel space_id = H5S_ALL_F mem_space_id = H5S_ALL_F dims = shape ( value ) if ( present ( istart ) . and . present ( iend )) then if ( present ( stride )) then !! necessary to use this present check for Intel and GCC call hdf_get_slice ( self , dname , ds_id , space_id , mem_space_id , istart , iend , stride ) else call hdf_get_slice ( self , dname , ds_id , space_id , mem_space_id , istart , iend ) endif else call hdf_shape_check ( self , dname , dims ) call h5dopen_f ( self % lid , dname , ds_id , ier ) if ( ier /= 0 ) error stop 'h5fortran:reader: setup read ' // dname // ' from ' // self % filename endif native_dtype = get_native_dtype ( ds_id , dname , self % filename ) !> cast the dataset read from disk to the variable type presented by user h5f%read(\"/my_dataset\", x) !> We only cast when needed to save memory. if ( native_dtype == H5T_NATIVE_DOUBLE ) then !! select case doesn't allow H5T_* select type ( value ) type is ( real ( real64 )) call h5dread_f ( ds_id , H5T_NATIVE_DOUBLE , value , dims , ier , mem_space_id , space_id ) type is ( real ( real32 )) allocate ( buf_r64 ( size ( value , 1 ), size ( value , 2 ), size ( value , 3 ), size ( value , 4 ), size ( value , 5 ), size ( value , 6 ))) call h5dread_f ( ds_id , H5T_NATIVE_DOUBLE , buf_r64 , dims , ier , mem_space_id , space_id ) value = real ( buf_r64 , real32 ) type is ( integer ( int32 )) allocate ( buf_r64 ( size ( value , 1 ), size ( value , 2 ), size ( value , 3 ), size ( value , 4 ), size ( value , 5 ), size ( value , 6 ))) call h5dread_f ( ds_id , H5T_NATIVE_DOUBLE , buf_r64 , dims , ier , mem_space_id , space_id ) value = int ( buf_r64 , int32 ) class default error stop 'unknown variable type' end select elseif ( native_dtype == H5T_NATIVE_REAL ) then select type ( value ) type is ( real ( real64 )) allocate ( buf_r32 ( size ( value , 1 ), size ( value , 2 ), size ( value , 3 ), size ( value , 4 ), size ( value , 5 ), size ( value , 6 ))) call h5dread_f ( ds_id , H5T_NATIVE_REAL , buf_r32 , dims , ier , mem_space_id , space_id ) value = real ( buf_r32 , real64 ) type is ( real ( real32 )) call h5dread_f ( ds_id , H5T_NATIVE_REAL , value , dims , ier , mem_space_id , space_id ) type is ( integer ( int32 )) allocate ( buf_r32 ( size ( value , 1 ), size ( value , 2 ), size ( value , 3 ), size ( value , 4 ), size ( value , 5 ), size ( value , 6 ))) call h5dread_f ( ds_id , H5T_NATIVE_REAL , buf_r32 , dims , ier , mem_space_id , space_id ) value = int ( buf_r32 , int32 ) class default error stop 'unknown variable type' end select elseif ( native_dtype == H5T_NATIVE_INTEGER ) then select type ( value ) type is ( real ( real64 )) allocate ( buf_i32 ( size ( value , 1 ), size ( value , 2 ), size ( value , 3 ), size ( value , 4 ), size ( value , 5 ), size ( value , 6 ))) call h5dread_f ( ds_id , H5T_NATIVE_INTEGER , buf_i32 , dims , ier , mem_space_id , space_id ) value = real ( buf_i32 , real64 ) type is ( real ( real32 )) allocate ( buf_i32 ( size ( value , 1 ), size ( value , 2 ), size ( value , 3 ), size ( value , 4 ), size ( value , 5 ), size ( value , 6 ))) call h5dread_f ( ds_id , H5T_NATIVE_INTEGER , buf_i32 , dims , ier , mem_space_id , space_id ) value = real ( buf_i32 , real32 ) type is ( integer ( int32 )) call h5dread_f ( ds_id , H5T_NATIVE_INTEGER , value , dims , ier , mem_space_id , space_id ) class default error stop 'unknown variable type' end select else error stop 'h5fortran:reader: non-handled datatype--please reach out to developers.' end if if ( ier /= 0 ) error stop 'h5fortran:reader: reading ' // dname // ' from ' // self % filename call hdf_wrapup ( ds_id , space_id , ier ) if ( present ( ierr )) ierr = ier if ( check ( ier , self % filename , dname ) . and . . not . present ( ierr )) error stop end procedure hdf_read_6d module procedure hdf_read_7d real ( real32 ), allocatable :: buf_r32 (:,:,:,:,:,:,:) real ( real64 ), allocatable :: buf_r64 (:,:,:,:,:,:,:) integer ( int32 ), allocatable :: buf_i32 (:,:,:,:,:,:,:) integer ( HSIZE_T ) :: dims ( rank ( value )) integer ( HID_T ) :: ds_id , space_id , mem_space_id , native_dtype integer :: ier ds_id = 0 !< sentinel space_id = H5S_ALL_F mem_space_id = H5S_ALL_F dims = shape ( value ) if ( present ( istart ) . and . present ( iend )) then if ( present ( stride )) then !! necessary to use this present check for Intel and GCC call hdf_get_slice ( self , dname , ds_id , space_id , mem_space_id , istart , iend , stride ) else call hdf_get_slice ( self , dname , ds_id , space_id , mem_space_id , istart , iend ) endif else call hdf_shape_check ( self , dname , dims ) call h5dopen_f ( self % lid , dname , ds_id , ier ) if ( ier /= 0 ) error stop 'h5fortran:reader: setup read ' // dname // ' from ' // self % filename endif native_dtype = get_native_dtype ( ds_id , dname , self % filename ) !> cast the dataset read from disk to the variable type presented by user h5f%read(\"/my_dataset\", x) !> We only cast when needed to save memory. if ( native_dtype == H5T_NATIVE_DOUBLE ) then !! select case doesn't allow H5T_* select type ( value ) type is ( real ( real64 )) call h5dread_f ( ds_id , H5T_NATIVE_DOUBLE , value , dims , ier , mem_space_id , space_id ) type is ( real ( real32 )) allocate ( buf_r64 ( size ( value , 1 ), size ( value , 2 ), size ( value , 3 ), size ( value , 4 ), size ( value , 5 ), size ( value , 6 ), size ( value , 7 ))) call h5dread_f ( ds_id , H5T_NATIVE_DOUBLE , buf_r64 , dims , ier , mem_space_id , space_id ) value = real ( buf_r64 , real32 ) type is ( integer ( int32 )) allocate ( buf_r64 ( size ( value , 1 ), size ( value , 2 ), size ( value , 3 ), size ( value , 4 ), size ( value , 5 ), size ( value , 6 ), size ( value , 7 ))) call h5dread_f ( ds_id , H5T_NATIVE_DOUBLE , buf_r64 , dims , ier , mem_space_id , space_id ) value = int ( buf_r64 , int32 ) class default error stop 'unknown variable type' end select elseif ( native_dtype == H5T_NATIVE_REAL ) then select type ( value ) type is ( real ( real64 )) allocate ( buf_r32 ( size ( value , 1 ), size ( value , 2 ), size ( value , 3 ), size ( value , 4 ), size ( value , 5 ), size ( value , 6 ), size ( value , 7 ))) call h5dread_f ( ds_id , H5T_NATIVE_REAL , buf_r32 , dims , ier , mem_space_id , space_id ) value = real ( buf_r32 , real64 ) type is ( real ( real32 )) call h5dread_f ( ds_id , H5T_NATIVE_REAL , value , dims , ier , mem_space_id , space_id ) type is ( integer ( int32 )) allocate ( buf_r32 ( size ( value , 1 ), size ( value , 2 ), size ( value , 3 ), size ( value , 4 ), size ( value , 5 ), size ( value , 6 ), size ( value , 7 ))) call h5dread_f ( ds_id , H5T_NATIVE_REAL , buf_r32 , dims , ier , mem_space_id , space_id ) value = int ( buf_r32 , int32 ) class default error stop 'unknown variable type' end select elseif ( native_dtype == H5T_NATIVE_INTEGER ) then select type ( value ) type is ( real ( real64 )) allocate ( buf_i32 ( size ( value , 1 ), size ( value , 2 ), size ( value , 3 ), size ( value , 4 ), size ( value , 5 ), size ( value , 6 ), size ( value , 7 ))) call h5dread_f ( ds_id , H5T_NATIVE_INTEGER , buf_i32 , dims , ier , mem_space_id , space_id ) value = real ( buf_i32 , real64 ) type is ( real ( real32 )) allocate ( buf_i32 ( size ( value , 1 ), size ( value , 2 ), size ( value , 3 ), size ( value , 4 ), size ( value , 5 ), size ( value , 6 ), size ( value , 7 ))) call h5dread_f ( ds_id , H5T_NATIVE_INTEGER , buf_i32 , dims , ier , mem_space_id , space_id ) value = real ( buf_i32 , real32 ) type is ( integer ( int32 )) call h5dread_f ( ds_id , H5T_NATIVE_INTEGER , value , dims , ier , mem_space_id , space_id ) class default error stop 'unknown variable type' end select else error stop 'h5fortran:reader: non-handled datatype--please reach out to developers.' end if if ( ier /= 0 ) error stop 'h5fortran:reader: reading ' // dname // ' from ' // self % filename call hdf_wrapup ( ds_id , space_id , ier ) if ( present ( ierr )) ierr = ier if ( check ( ier , self % filename , dname ) . and . . not . present ( ierr )) error stop end procedure hdf_read_7d end submodule reader","tags":"","loc":"sourcefile/reader.f90.html"},{"title":"reader_lt.in.f90 – Object-oriented Fortran 2008 HDF5 interface","text":"Contents Submodules reader_lt Source Code reader_lt.in.f90 Source Code submodule ( h5fortran : read ) reader_lt implicit none ( type , external ) contains module procedure h5exist type ( hdf5_file ) :: h call h % initialize ( filename , status = 'old' , action = 'r' ) h5exist = h % exist ( dname ) call h % finalize () end procedure h5exist module procedure lt0read @ reader_lt_template @ end procedure lt0read module procedure lt1read @ reader_lt_template @ end procedure lt1read module procedure lt2read @ reader_lt_template @ end procedure lt2read module procedure lt3read @ reader_lt_template @ end procedure lt3read module procedure lt4read @ reader_lt_template @ end procedure lt4read module procedure lt5read @ reader_lt_template @ end procedure lt5read module procedure lt6read @ reader_lt_template @ end procedure lt6read module procedure lt7read @ reader_lt_template @ end procedure lt7read end submodule reader_lt","tags":"","loc":"sourcefile/reader_lt.in.f90.html"},{"title":"reader_nd.f90 – Object-oriented Fortran 2008 HDF5 interface","text":"conceptual--not tested--will use h5dread_f instead Contents Submodules reader_ND Source Code reader_nd.f90 Source Code !! conceptual--not tested--will use h5dread_f instead submodule ( h5fortran : read ) reader_ND implicit none ( type , external ) contains module procedure hdf_read_8d integer ( HSIZE_T ) :: dims ( rank ( value )) integer :: i ( rank ( value )) TYPE ( C_PTR ) :: f_ptr call hdf_setup_read ( self , dname , dims , ierr ) if ( ierr /= 0 ) return select type ( value ) type is ( real ( real64 )) i = lbound ( value ) f_ptr = c_loc ( value ( i ( 1 ), i ( 2 ), i ( 3 ), i ( 4 ), i ( 5 ), i ( 6 ), i ( 7 ), i ( 8 ))) call h5ltread_dataset_f ( self % lid , dname , h5kind_to_type ( kind ( value ), H5_REAL_KIND ), f_ptr , ierr ) type is ( real ( real32 )) i = lbound ( value ) f_ptr = c_loc ( value ( i ( 1 ), i ( 2 ), i ( 3 ), i ( 4 ), i ( 5 ), i ( 6 ), i ( 7 ), i ( 8 ))) call h5ltread_dataset_f ( self % lid , dname , h5kind_to_type ( kind ( value ), H5_REAL_KIND ), f_ptr , ierr ) type is ( integer ( int32 )) i = lbound ( value ) f_ptr = c_loc ( value ( i ( 1 ), i ( 2 ), i ( 3 ), i ( 4 ), i ( 5 ), i ( 6 ), i ( 7 ), i ( 8 ))) call h5ltread_dataset_f ( self % lid , dname , h5kind_to_type ( kind ( value ), H5_INTEGER_KIND ), f_ptr , ierr ) type is ( integer ( int64 )) i = lbound ( value ) f_ptr = c_loc ( value ( i ( 1 ), i ( 2 ), i ( 3 ), i ( 4 ), i ( 5 ), i ( 6 ), i ( 7 ), i ( 8 ))) call h5ltread_dataset_f ( self % lid , dname , h5kind_to_type ( kind ( value ), H5_INTEGER_KIND ), f_ptr , ierr ) class default ierr = 6 end select if ( ierr /= 0 ) write ( stderr , * ) 'ERROR: ' // dname // ' read ' // self % filename end procedure hdf_read_8d end submodule reader_ND","tags":"","loc":"sourcefile/reader_nd.f90.html"},{"title":"read_slice.f90 – Object-oriented Fortran 2008 HDF5 interface","text":"Contents Programs read_slice Source Code read_slice.f90 Source Code program read_slice !! example of Fortran reading smaller array into slice of larger array via subroutine implicit none ( type , external ) type :: foo integer :: i44 ( 4 , 4 ) end type foo integer :: i , bigA ( 4 , 4 ) type ( foo ) :: B bigA = - 1 call getter ( bigA ( 2 : 3 , 3 : 4 )) do i = 1 , size ( bigA , 1 ) print '(4I3)' , bigA ( i ,:) enddo ! ---- B % i44 = - 1 call getter ( B % i44 ( 2 : 3 , 3 : 4 )) print * , '' do i = 1 , size ( B % i44 , 1 ) print '(4I3)' , B % i44 ( i ,:) enddo !! should print !! -1 -1 -1 -1 !! -1 -1  1  2 !! -1 -1  3  4 !! -1 -1 -1 -1 contains subroutine getter ( A ) integer , intent ( out ) :: A ( 2 , 2 ) A = reshape ([ 1 , 2 , 3 , 4 ], shape ( A ), order = [ 2 , 1 ]) end subroutine getter end program","tags":"","loc":"sourcefile/read_slice.f90.html"},{"title":"test_array.f90 – Object-oriented Fortran 2008 HDF5 interface","text":"Contents Programs array_test Source Code test_array.f90 Source Code program array_test use , intrinsic :: ieee_arithmetic , only : ieee_value , ieee_quiet_nan , ieee_is_nan use , intrinsic :: iso_fortran_env , only : real32 , real64 , int32 , stderr => error_unit use h5fortran , only : hdf5_file , HSIZE_T , H5T_NATIVE_INTEGER implicit none ( type , external ) real ( real32 ) :: nan call test_basic_array ( 'test_array.h5' ) print * , 'PASSED: array write' call test_read_slice ( 'test_array.h5' ) print * , 'PASSED: slice read' call test_write_slice ( 'test_array.h5' ) print * , 'PASSED: slice write' call test_readwrite_array ( 'test_group_array.f90' , ng = 69 , nn = 100 , pn = 5 ) print * , 'PASSED: array write / read' contains subroutine test_basic_array ( filename ) character ( * ), intent ( in ) :: filename !! tests that compression doesn't fail for very small datasets, where it really shouldn't be used (makes file bigger) type ( hdf5_file ) :: h integer ( HSIZE_T ), allocatable :: dims (:) integer ( int32 ), dimension ( 4 ) :: i1 , i1t integer ( int32 ), dimension ( 4 , 4 ) :: i2 , i2t real ( real32 ), allocatable :: rr2 (:,:) real ( real32 ) :: nant , r1 ( 4 ), r2 ( 4 , 4 ), B ( 6 , 6 ) integer :: i integer ( int32 ) :: i2_8 ( 8 , 8 ) nan = ieee_value ( 1.0 , ieee_quiet_nan ) do i = 1 , size ( i1 ) i1 ( i ) = i enddo i2 ( 1 ,:) = i1 do i = 1 , size ( i2 , 2 ) i2 ( i ,:) = i2 ( 1 ,:) * i enddo r1 = i1 r2 = i2 call h % initialize ( filename , status = 'replace' , comp_lvl = 1 , verbose = . False .) call h % write ( '/int32-1d' , i1 ) call h % write ( '/test/group2/int32-2d' , i2 ) call h % write ( '/real32-2d' , r2 ) call h % write ( '/nan' , nan ) call h % finalize () !! read call h % initialize ( filename , status = 'old' , action = 'r' , verbose = . false .) !> int32 call h % read ( '/int32-1d' , i1t ) if (. not . all ( i1 == i1t )) error stop 'read 1-d int32: does not match write' call h % read ( '/test/group2/int32-2d' , i2t ) if (. not . all ( i2 == i2t )) error stop 'read 2-D: int32 does not match write' !> verify reading into larger array i2_8 = 0 call h % read ( '/test/group2/int32-2d' , i2_8 ( 2 : 5 , 3 : 6 )) if (. not . all ( i2_8 ( 2 : 5 , 3 : 6 ) == i2 )) error stop 'read into larger array fail' !> real call h % shape ( '/real32-2d' , dims ) allocate ( rr2 ( dims ( 1 ), dims ( 2 ))) call h % read ( 'real32-2d' , rr2 ) if (. not . all ( r2 == rr2 )) error stop 'real 2-D: read does not match write' ! check read into a variable slice call h % read ( 'real32-2d' , B ( 2 : 5 , 3 : 6 )) if (. not . all ( B ( 2 : 5 , 3 : 6 ) == r2 )) error stop 'real 2D: reading into variable slice' call h % read ( '/nan' , nant ) if (. not . ieee_is_nan ( nant )) error stop 'failed storing or reading NaN' call h % finalize () end subroutine test_basic_array subroutine test_read_slice ( filename ) character ( * ), intent ( in ) :: filename type ( hdf5_file ) :: h integer :: i integer ( int32 ), dimension ( 4 ) :: i1 , i1t integer ( int32 ), dimension ( 4 , 4 ) :: i2 , i2t do i = 1 , size ( i1 ) i1 ( i ) = i enddo i2 ( 1 ,:) = i1 do i = 1 , size ( i2 , 2 ) i2 ( i ,:) = i2 ( 1 ,:) * i enddo call h % initialize ( filename , status = 'old' , action = 'r' ) i1t = 0 call h % read ( '/int32-1d' , i1t (: 2 ), istart = [ 2 ], iend = [ 3 ], stride = [ 1 ]) if ( any ( i1t (: 2 ) /= [ 2 , 3 ])) then write ( stderr , * ) 'read 1D slice does not match. expected [2,3] but got ' , i1t (: 2 ) error stop endif i1t = 0 call h % read ( '/int32-1d' , i1t (: 2 ), istart = [ 2 ], iend = [ 3 ]) if ( any ( i1t (: 2 ) /= [ 2 , 3 ])) then write ( stderr , * ) 'read 1D slice does not match. expected [2,3] but got ' , i1t (: 2 ) error stop endif i2t = 0 call h % read ( '/test/group2/int32-2d' , i2t (: 2 ,: 3 ), istart = [ 2 , 1 ], iend = [ 3 , 3 ], stride = [ 1 , 1 ]) if ( any ( i2t (: 2 ,: 3 ) /= i2 ( 2 : 3 , 1 : 3 ))) then write ( stderr , * ) 'read 2D slice does not match. expected:' , i2 ( 2 : 3 , 1 : 3 ), ' but got ' , i2t (: 2 ,: 3 ) error stop endif call h % finalize () end subroutine test_read_slice subroutine test_write_slice ( filename ) character ( * ), intent ( in ) :: filename type ( hdf5_file ) :: h integer ( int32 ), dimension ( 4 ) :: i1t integer ( int32 ), dimension ( 4 , 4 ) :: i2t call h % initialize ( filename , status = 'old' , action = 'r+' , verbose = . true ., debug = . true .) call h % create ( '/int32a-1d' , dtype = H5T_NATIVE_INTEGER , dims = [ 3 ]) call h % write ( '/int32a-1d' , [ 1 , 3 ], istart = [ 1 ], iend = [ 2 ]) print * , 'PASSED: create dataset and write slice 1D' call h % write ( '/int32-1d' , [ 35 , 70 ], istart = [ 2 ], iend = [ 3 ], stride = [ 1 ]) call h % read ( '/int32-1d' , i1t ) if (. not . all ( i1t == [ 1 , 35 , 70 , 4 ])) then write ( stderr , * ) 'write 1D slice does not match. got ' , i1t error stop endif print * , 'PASSED: overwrite slice 1d, stride=1' call h % write ( '/int32-1d' , [ 23 , 34 , 45 ], istart = [ 2 ], iend = [ 4 ]) call h % read ( '/int32-1d' , i1t ) if (. not . all ( i1t == [ 1 , 23 , 34 , 45 ])) then write ( stderr , * ) 'read 1D slice does not match.got ' , i1t error stop endif print * , 'PASSED: overwrite slice 1d, no stride' call h % create ( '/int32a-2d' , dtype = H5T_NATIVE_INTEGER , dims = [ 4 , 4 ]) print * , 'create and write slice 2d, stride=1' call h % write ( '/int32a-2d' , reshape ([ 76 , 65 , 54 , 43 ], [ 2 , 2 ]), istart = [ 2 , 1 ], iend = [ 3 , 2 ]) call h % read ( '/int32a-2d' , i2t ) call h % finalize () end subroutine test_write_slice subroutine test_readwrite_array ( filename , ng , nn , pn ) !! more group type ( hdf5_file ) :: h character ( * ), intent ( in ) :: filename integer , intent ( in ) :: ng , nn , pn real ( real32 ), allocatable :: flux (:,:), fo (:) character ( 2 ) :: pnc , ic integer :: i allocate ( flux ( nn , ng ), fo ( nn )) flux = 1.0 write ( pnc , '(I2)' ) pn call h % initialize ( filename , status = 'scratch' ) do i = 1 , ng write ( ic , '(I2)' ) i call h % write ( '/group' // trim ( adjustl ( ic )) // '/flux_node' , flux (:, i )) enddo call h % read ( '/group1/flux_node' , fo ) if (. not . all ( fo == flux (:, 1 ))) error stop 'test_read_write: read does not match write' call h % finalize () end subroutine test_readwrite_array end program","tags":"","loc":"sourcefile/test_array.f90.html"},{"title":"test_attributes.f90 – Object-oriented Fortran 2008 HDF5 interface","text":"Contents Programs test_attributes Source Code test_attributes.f90 Source Code program test_attributes use , intrinsic :: iso_fortran_env , only : int32 , real32 , real64 , stderr => error_unit use h5fortran , only : hdf5_file , h5write_attr , h5read_attr implicit none ( type , external ) character ( * ), parameter :: filename = 'test_attr.h5' character ( 8 ) :: s32 !< arbitrary length call test_write_attributes ( filename ) call h5write_attr ( filename , '/x' , 'str29' , '29' ) call h5write_attr ( filename , '/x' , 'int29' , [ 29 ]) print * , 'PASSED: HDF5 write attributes' call test_read_attributes ( filename ) call h5read_attr ( filename , '/x' , 'str29' , s32 ) if ( s32 /= '29' ) error stop 'readattr_lt string' block integer :: i32 ( 1 ) call h5read_attr ( filename , '/x' , 'int29' , i32 ) if ( i32 ( 1 ) /= 29 ) error stop 'readattr_lt integer' end block print * , 'PASSED: HDF5 read attributes' contains subroutine test_write_attributes ( path ) type ( hdf5_file ) :: h character ( * ), intent ( in ) :: path call h % initialize ( path , status = 'replace' ) call h % write ( '/x' , 1 ) call h % writeattr ( '/x' , 'note' , 'this is just a little number' ) call h % writeattr ( '/x' , 'hello' , 'hi' ) call h % writeattr ( '/x' , 'life' , [ 42 ]) call h % writeattr ( '/x' , 'life_float' , [ 4 2._real32 , 8 4._real32 ]) call h % writeattr ( '/x' , 'life_double' , [ 4 2._real64 ]) call h % finalize () end subroutine test_write_attributes subroutine test_read_attributes ( path ) type ( hdf5_file ) :: h character ( * ), intent ( in ) :: path character ( 1024 ) :: attr_str integer :: attr_int ( 1 ) real ( real32 ) :: attr32 ( 2 ) real ( real64 ) :: attr64 ( 1 ) integer :: x call h % initialize ( path , status = 'old' , action = 'r' ) call h % read ( '/x' , x ) if ( x /= 1 ) error stop 'readattr: unexpected value' call h % readattr ( '/x' , 'note' , attr_str ) if ( attr_str /= 'this is just a little number' ) error stop 'readattr value note' call h % readattr ( '/x' , 'life' , attr_int ) if ( attr_int ( 1 ) /= 42 ) error stop 'readattr: int' call h % readattr ( '/x' , 'life_float' , attr32 ) if ( any ( attr32 /= [ 4 2._real32 , 8 4._real32 ])) error stop 'readattr: real32' call h % readattr ( '/x' , 'life_double' , attr64 ) if ( attr64 ( 1 ) /= 4 2._real64 ) error stop 'readattr: real64' call h % finalize () end subroutine test_read_attributes end program","tags":"","loc":"sourcefile/test_attributes.f90.html"},{"title":"test_deflate.f90 – Object-oriented Fortran 2008 HDF5 interface","text":"Contents Programs test_deflate Source Code test_deflate.f90 Source Code program test_deflate !! unit tests and registration tests of HDF5 deflate compression write use , intrinsic :: iso_fortran_env , only : int32 , real32 , real64 , stderr => error_unit use h5fortran , only : hdf5_file use hdf5 , only : H5D_CHUNKED_F , H5D_CONTIGUOUS_F , hsize_t implicit none ( type , external ) call test_hdf5_deflate () print * , 'PASSED: HDF5 compression' contains subroutine test_hdf5_deflate () type ( hdf5_file ) :: h5f integer ( hsize_t ), parameter :: N = 1000 integer ( hsize_t ) :: crat , chunks ( 3 ) integer :: fsize , layout integer , allocatable :: ibig2 (:,:), ibig3 (:,:,:) real ( real32 ), allocatable :: big2 (:,:), big3 (:,:,:) character ( * ), parameter :: fn1 = 'deflate1.h5' , fn2 = 'deflate2.h5' , fn3 = 'deflate3.h5' , fn4 = 'deflate4.h5' allocate ( ibig2 ( N , N ), ibig3 ( N , N , 4 ), big2 ( N , N ), big3 ( N , N , 4 )) ibig2 = 0 ibig3 = 0 big2 = 0 big3 = 0 call h5f % initialize ( fn1 , status = 'replace' , comp_lvl = 1 , debug = . true .) call h5f % write ( '/big2' , big2 , chunk_size = [ 100 , 100 ]) call h5f % write ( '/small_contig' , big2 (: 5 ,: 5 )) call h5f % finalize () inquire ( file = fn1 , size = fsize ) crat = ( N * N * storage_size ( big2 ) / 8 ) / fsize print '(A,F6.2,A,I6)' , 'filesize (Mbytes): ' , fsize / 1e6 , '   2D compression ratio:' , crat if ( h5f % comp_lvl > 0 . and . crat < 10 ) error stop '2D low compression' call h5f % initialize ( fn1 , status = 'old' , action = 'r' , debug = . false .) layout = h5f % layout ( '/big2' ) if ( layout /= H5D_CHUNKED_F ) error stop '#1 not chunked layout' if (. not . h5f % is_chunked ( '/big2' )) error stop '#1 not chunked layout' call h5f % chunks ( '/big2' , chunks (: 2 )) if ( any ( chunks (: 2 ) /= [ 100 , 100 ])) error stop '#1 get_chunk mismatch' layout = h5f % layout ( '/small_contig' ) if ( layout /= H5D_CONTIGUOUS_F ) error stop '#1 not contiguous layout' if (. not . h5f % is_contig ( '/small_contig' )) error stop '#1 not contig layout' call h5f % chunks ( '/small_contig' , chunks (: 2 )) if ( any ( chunks (: 2 ) /= - 1 )) error stop '#1 get_chunk mismatch' call h5f % finalize () !====================================== call h5f % initialize ( fn2 , status = 'replace' , comp_lvl = 1 , debug = . true .) call h5f % write ( '/big3' , big3 , chunk_size = [ 100 , 100 , 1 ]) call h5f % write ( '/big3_autochunk' , big3 ) call h5f % chunks ( '/big3_autochunk' , chunks ) if ( any ( chunks /= [ 63 , 125 , 1 ])) error stop '#3 auto chunk unexpected chunk size' call h5f % finalize () inquire ( file = fn2 , size = fsize ) crat = ( 2 * N * N * storage_size ( big3 ) / 8 ) / fsize print '(A,F6.2,A,I6)' , '#2 filesize (Mbytes): ' , fsize / 1e6 , '   3D compression ratio:' , crat if ( h5f % comp_lvl > 0 . and . crat < 10 ) error stop '#2 3D low compression' !====================================== call h5f % initialize ( fn3 , status = 'replace' , comp_lvl = 1 , debug = . true .) call h5f % write ( '/ibig3' , ibig3 (: N - 10 ,: N - 20 ,:)) call h5f % chunks ( '/ibig3' , chunks ) if ( any ( chunks /= [ 62 , 123 , 1 ])) error stop '#3 auto chunk unexpected chunk size' call h5f % finalize () inquire ( file = fn3 , size = fsize ) crat = ( N * N * storage_size ( ibig3 ) / 8 ) / fsize print '(A,F6.2,A,I6)' , '#3 filesize (Mbytes): ' , fsize / 1e6 , '   3D compression ratio:' , crat if ( h5f % comp_lvl > 0 . and . crat < 10 ) error stop '#3 3D low compression' !====================================== call h5f % initialize ( fn4 , status = 'replace' , comp_lvl = 1 , debug = . true .) call h5f % write ( '/ibig2' , ibig2 , chunk_size = [ 100 , 100 ]) call h5f % finalize () inquire ( file = fn4 , size = fsize ) crat = ( N * N * storage_size ( ibig2 ) / 8 ) / fsize print '(A,F6.2,A,I6)' , '#4 filesize (Mbytes): ' , fsize / 1e6 , '   3D compression ratio:' , crat if ( h5f % comp_lvl > 0 . and . crat < 10 ) error stop '#4 3D low compression' end subroutine test_hdf5_deflate end program","tags":"","loc":"sourcefile/test_deflate.f90.html"},{"title":"test_error.f90 – Object-oriented Fortran 2008 HDF5 interface","text":"Contents Programs test_error Source Code test_error.f90 Source Code program test_error use , intrinsic :: iso_fortran_env , only : int32 , real32 , real64 , stderr => error_unit use h5fortran , only : hdf5_file implicit none ( type , external ) call test_nonexist_old_file () print * , 'OK: non-existing old file' call test_nonexist_unknown_file () print * , 'OK: non-existing unknown file' call test_nonhdf5_file () print * , 'OK: non-HDF5 file' call test_wrong_type () print * , \"OK: wrong type read\" contains subroutine test_nonexist_old_file () integer :: ierr type ( hdf5_file ) :: h call h % initialize ( 'not-exist.h5' , ierr , status = 'old' , action = 'read' , verbose = . false .) if ( ierr == 0 ) error stop 'should have had ierr/=0 on non-existing old file' end subroutine test_nonexist_old_file subroutine test_nonexist_unknown_file () integer :: ierr type ( hdf5_file ) :: h call h % initialize ( 'not-exist.h5' , ierr , status = 'unknown' , action = 'read' , verbose = . false .) if ( ierr == 0 ) error stop 'should have had ierr/=0 on non-existing unknown read file' end subroutine test_nonexist_unknown_file subroutine test_nonhdf5_file () integer :: u , ierr type ( hdf5_file ) :: h character ( * ), parameter :: filename = 'bad.h5' ! create or replace zero-length file, could be any size, just not a valid HDF5 file open ( newunit = u , file = filename , status = 'replace' , action = 'write' ) close ( u ) call h % initialize ( filename , ierr , status = 'old' , action = 'read' ) if ( ierr == 0 ) error stop 'should have had ierr/=0 on invalid HDF5 file' end subroutine test_nonhdf5_file subroutine test_wrong_type () integer :: u type ( hdf5_file ) :: h character ( * ), parameter :: filename = 'bad.h5' call h % initialize ( filename , status = 'replace' , verbose = . false .) call h % write ( '/real32' , 4 2. ) call h % finalize () call h % initialize ( filename , status = 'old' , action = 'read' , verbose = . false .) call h % read ( '/real32' , u ) if ( u /= 42 ) error stop 'test_wrong_type: did not coerce real to integer' call h % finalize () end subroutine test_wrong_type end program","tags":"","loc":"sourcefile/test_error.f90.html"},{"title":"test_exist.f90 – Object-oriented Fortran 2008 HDF5 interface","text":"Contents Programs exist_tests Source Code test_exist.f90 Source Code program exist_tests !! test \"exist\" variable use , intrinsic :: iso_fortran_env , only : stderr => error_unit use h5fortran , only : hdf5_file , h5write , h5exist , is_hdf5 , hdf5_close implicit none ( type , external ) call test_is_hdf5 () print * , 'OK: is_hdf5' call test_exist () print * , 'OK: exist' call test_softlink () print * , \"OK: softlink\" call test_scratch () print * , 'OK: scratch' call test_multifiles () print * , 'OK: multiple files open at once' contains subroutine test_is_hdf5 () integer :: i if ( is_hdf5 ( 'apidfjpj-8j9ejfpq984jfp89q39SHf.h5' )) error stop 'test_exist: non-existant file declared hdf5' open ( newunit = i , file = 'not_hdf5.h5' , action = 'write' , status = 'replace' ) write ( i , * ) 'I am not an HDF5 file.' close ( i ) if ( is_hdf5 ( 'not_hdf5.h5' )) error stop 'text files are not hdf5' end subroutine test_is_hdf5 subroutine test_exist () type ( hdf5_file ) :: h character ( * ), parameter :: fn = 'exist.h5' call h5write ( fn , '/x' , 42 ) if (. not . is_hdf5 ( fn )) error stop 'file does not exist' call h % initialize ( fn ) if (. not . h % is_open ) error stop 'file is open' if (. not . h % exist ( '/x' )) error stop 'x exists' if ( h % exist ( '/foo' )) then write ( stderr , * ) 'variable /foo not exist in ' , h % filename error stop endif call h % finalize () if ( h % is_open ) error stop 'file is closed' if (. not . h5exist ( fn , '/x' )) error stop 'x exists' if ( h5exist ( fn , '/foo' )) error stop 'foo not exist' end subroutine test_exist subroutine test_softlink () type ( hdf5_file ) :: h character ( * ), parameter :: fn = 'soft.h5' integer :: y call h % initialize ( fn , status = \"new\" ) call h % write ( \"/actual\" , 142 ) call h % softlink ( \"/actual\" , \"/additional\" ) call h % read ( \"/additional\" , y ) if (. not . h % exist ( \"/additional\" )) error stop \"softlink not present\" if ( y /= 142 ) error stop \"did not read softlink correctly\" !> test dangling link call h % softlink ( \"/not_here\" , \"/not_yet\" ) if ( h % exist ( \"/not_yet\" )) error stop \"dangling softlink\" call h % write ( \"/not_here\" , 36 ) call h % read ( \"/not_yet\" , y ) if ( y /= 36 ) error stop \"finalizing dangling link failed\" call h % finalize () end subroutine test_softlink subroutine test_scratch () logical :: e type ( hdf5_file ) :: h call h % initialize ( \"scratch.h5\" , status = 'scratch' ) call h % write ( \"/foo\" , 42 ) call h % finalize () inquire ( file = h % filename , exist = e ) if ( e ) error stop 'scratch file not autodeleted' end subroutine test_scratch subroutine test_multifiles () type ( hdf5_file ) :: f , g , h integer :: ierr call f % initialize ( filename = 'A.h5' , status = 'scratch' ) call g % initialize ( filename = 'B.h5' , status = 'scratch' ) if ( h % is_open ) error stop 'is_open not isolated at constructor' call h % initialize ( filename = 'C.h5' , status = 'scratch' ) call f % flush () call f % finalize ( ierr ) if ( ierr /= 0 ) error stop 'close a.h5' if (. not . g % is_open . or . . not . h % is_open ) error stop 'is_open not isolated at destructor' call g % finalize ( ierr ) if ( ierr /= 0 ) error stop 'close b.h5' call h % finalize ( ierr ) if ( ierr /= 0 ) error stop 'close c.h5' call hdf5_close () end subroutine test_multifiles end program","tags":"","loc":"sourcefile/test_exist.f90.html"},{"title":"test_fail_nonexist_variable.f90 – Object-oriented Fortran 2008 HDF5 interface","text":"Contents Programs nonexistvar Source Code test_fail_nonexist_variable.f90 Source Code program nonexistvar use h5fortran , only : hdf5_file implicit none ( type , external ) integer :: u type ( hdf5_file ) :: h character ( * ), parameter :: filename = 'bad.h5' call h % initialize ( filename , status = 'scratch' , verbose = . false .) call h % read ( '/not-exist' , u ) call h % finalize () end program","tags":"","loc":"sourcefile/test_fail_nonexist_variable.f90.html"},{"title":"test_fail_read_rank_mismatch.f90 – Object-oriented Fortran 2008 HDF5 interface","text":"Contents Programs fail_slice_mismatch Source Code test_fail_read_rank_mismatch.f90 Source Code program fail_slice_mismatch !> test writing wrong size use h5fortran , only : hdf5_file implicit none ( type , external ) type ( hdf5_file ) :: h call h % initialize ( 'mismatch.h5' , status = 'scratch' , verbose = . False .) call h % write ( '/int32-1d' , [ - 1 , 1 ]) call h % write ( '/int32-1d' , reshape ([ - 1 ], shape = [ 1 , 1 ])) call h % finalize () end program","tags":"","loc":"sourcefile/test_fail_read_rank_mismatch.f90.html"},{"title":"test_fail_read_size_mismatch.f90 – Object-oriented Fortran 2008 HDF5 interface","text":"Contents Programs fail_slice_mismatch Source Code test_fail_read_size_mismatch.f90 Source Code program fail_slice_mismatch !> test writing wrong size use h5fortran , only : hdf5_file implicit none ( type , external ) type ( hdf5_file ) :: h call h % initialize ( 'mismatch.h5' , status = 'scratch' , verbose = . False .) call h % write ( '/int32-1d' , [ - 1 , 1 ]) call h % write ( '/int32-1d' , [ - 1 ]) call h % finalize () end program","tags":"","loc":"sourcefile/test_fail_read_size_mismatch.f90.html"},{"title":"test_fail_unknown_read.f90 – Object-oriented Fortran 2008 HDF5 interface","text":"Contents Programs fail_unknown_read Source Code test_fail_unknown_read.f90 Source Code program fail_unknown_read use h5fortran , only : hdf5_file implicit none ( type , external ) type ( hdf5_file ) :: h complex :: x call h % initialize ( 'bad.h5' , status = 'scratch' , verbose = . false .) call h % read ( '/complex' , x ) call h % finalize () end program","tags":"","loc":"sourcefile/test_fail_unknown_read.f90.html"},{"title":"test_fail_unknown_write.f90 – Object-oriented Fortran 2008 HDF5 interface","text":"Contents Programs fail_unknown_write Source Code test_fail_unknown_write.f90 Source Code program fail_unknown_write use h5fortran , only : hdf5_file implicit none ( type , external ) type ( hdf5_file ) :: h complex :: x x = ( 1 , - 1 ) call h % initialize ( 'bad.h5' , status = 'scratch' , verbose = . false .) call h % write ( '/complex' , x ) call h % finalize () end program","tags":"","loc":"sourcefile/test_fail_unknown_write.f90.html"},{"title":"test_layout.f90 – Object-oriented Fortran 2008 HDF5 interface","text":"Contents Programs test_layout Source Code test_layout.f90 Source Code program test_layout use , intrinsic :: iso_fortran_env , only : real32 , real64 use h5fortran , only : hdf5_file use hdf5 , only : H5D_COMPACT_F implicit none ( type , external ) type ( hdf5_file ) :: h character ( * ), parameter :: fn = 'test_layout.h5' real ( real32 ), dimension ( 1 , 1 , 1 , 1 , 1 , 1 , 1 ) :: d7_32 , r7_32 real ( real64 ), dimension ( 1 , 1 , 1 , 1 , 1 , 1 , 1 ) :: d7_64 , r7_64 real ( real32 ) :: w32 , r32 real ( real64 ) :: w64 , r64 integer :: wi32 , ri32 d7_32 = 42 d7_64 = 42 w32 = 142 w64 = 142 wi32 = 142 call h % initialize ( fn , status = \"replace\" , action = \"write\" ) call h % write ( \"/compact1d\" , [ 1 , 2 , 3 ], compact = . true .) call h % write ( \"/contig1d\" , [ 1 , 2 , 3 ], compact = . false .) call h % write ( \"/compact0d\" , 42 , compact = . true .) call h % write ( \"/compact7d_32\" , d7_32 , compact = . true .) call h % write ( \"/compact7d_64\" , d7_64 , compact = . true .) call h % write ( '/compact_r32' , w32 , compact = . true .) call h % write ( '/compact_r64' , w64 , compact = . true .) call h % write ( '/compact_i32' , wi32 , compact = . true .) call h % finalize () !> read casting call h % initialize ( fn , status = \"old\" , action = \"read\" ) call h % read ( \"/compact_r32\" , r64 ) if ( r64 /= w32 ) error stop \"read real32 => real64\" call h % read ( \"/compact_r64\" , r32 ) if ( r32 /= w64 ) error stop \"read real64 => real32\" call h % read ( \"/compact_i32\" , r32 ) if ( r32 /= wi32 ) error stop \"read int32 => real32\" call h % read ( \"/compact_r32\" , ri32 ) if ( ri32 /= w32 ) error stop \"real real32 => int32\" call h % read ( \"/compact7d_32\" , r7_64 ) if ( any ( r7_64 /= d7_32 )) error stop \"read real32 => real64\" call h % read ( \"/compact7d_64\" , r7_32 ) if ( any ( r7_32 /= d7_64 )) error stop \"read real64 => real32\" if ( h % layout ( \"/compact1d\" ) /= H5D_COMPACT_F ) error stop \"expected compact\" if (. not . h % is_compact ( \"/compact1d\" )) error stop \"1d is_compact fail\" if (. not . h % is_compact ( \"/compact7d_32\" )) error stop \"7d is_compact fail\" if (. not . h % is_compact ( \"/compact0d\" )) error stop \"0d is_compact fail\" call h % finalize () end program","tags":"","loc":"sourcefile/test_layout.f90.html"},{"title":"test_lt.f90 – Object-oriented Fortran 2008 HDF5 interface","text":"Contents Programs test_lt Source Code test_lt.f90 Source Code program test_lt use h5fortran , only : h5write , h5read implicit none ( type , external ) integer :: L , L1 ( 8 ), L2 ( 2 , 1 ), L3 ( 1 , 1 , 1 ), L4 ( 1 , 1 , 1 , 1 ), L5 ( 1 , 1 , 1 , 1 , 1 ), L6 ( 1 , 1 , 1 , 1 , 1 , 1 ), L7 ( 1 , 1 , 1 , 1 , 1 , 1 , 1 ) L = 121242 L2 = L ; L3 = L ; L4 = L ; L5 = L ; L6 = L ; L7 = L call h5write ( 'scalar_int.h5' , '/int' , 42 ) call h5write ( 'golt.h5' , '/int32_0d' , 121242 ) call h5read ( 'golt.h5' , '/int32_0d' , L ) if ( L /= 121242 ) error stop 'incorrect read value' ! --- 1d call h5write ( 'golt.h5' , '/int32_1d' , [ 1 , 2 , 3 , 4 , 5 , 6 ]) L1 = 0 call h5read ( 'golt.h5' , '/int32_1d' , L1 ( 2 : 7 )) if (. not . all ( L1 ( 2 : 7 ) == [ 1 , 2 , 3 , 4 , 5 , 6 ])) error stop '1d slice read error' ! --- 2d call h5write ( 'golt.h5' , '/int32_2d' , L2 ) call h5read ( 'golt.h5' , '/int32_2d' , L2 ) ! --- 3d call h5write ( 'golt.h5' , '/int32_3d' , L3 ) call h5read ( 'golt.h5' , '/int32_3d' , L3 ) call h5write ( 'golt.h5' , '/int32_4d' , L4 ) call h5read ( 'golt.h5' , '/int32_4d' , L4 ) call h5write ( 'golt.h5' , '/int32_5d' , L5 ) call h5read ( 'golt.h5' , '/int32_5d' , L5 ) call h5write ( 'golt.h5' , '/int32_6d' , L6 ) call h5read ( 'golt.h5' , '/int32_6d' , L6 ) call h5write ( 'golt.h5' , '/int32_7d' , L7 ) call h5read ( 'golt.h5' , '/int32_7d' , L7 ) end program","tags":"","loc":"sourcefile/test_lt.f90.html"},{"title":"test_minimal.f90 – Object-oriented Fortran 2008 HDF5 interface","text":"Contents Programs test_minimal Source Code test_minimal.f90 Source Code program test_minimal use hdf5 , only : HID_T , HSIZE_T , H5_INTEGER_KIND , h5kind_to_type , h5open_f , h5close_f , h5fclose_f , h5fcreate_f , H5F_ACC_TRUNC_F use h5lt , only : h5ltmake_dataset_f implicit none ( type , external ) integer :: i , p integer ( HID_T ) :: lid character ( * ), parameter :: filename = 'test_minimal.h5' p = 42 call h5open_f ( i ) if ( i /= 0 ) error stop 'minimal: could not open hdf5 library' call h5fcreate_f ( filename , H5F_ACC_TRUNC_F , lid , i ) if ( i /= 0 ) error stop 'minimal: could not create file' print * , 'minimal: created ' // filename call h5ltmake_dataset_f ( lid , \"foo\" , rank ( p ), shape ( p , kind = HSIZE_T ), h5kind_to_type ( kind ( p ), H5_INTEGER_KIND ), p , i ) if ( i /= 0 ) error stop 'minimal: could not create dataset foo' print * , 'minimal: created variable' call h5fclose_f ( lid , i ) if ( i /= 0 ) error stop 'minimal: could not close file' print * , 'minimal: closed ' // filename call h5close_f ( i ) if ( i /= 0 ) error stop 'could not close hdf5 library' ! this is a Fortran-standard way to delete files open ( newunit = i , file = filename ) close ( i , status = 'delete' ) end program","tags":"","loc":"sourcefile/test_minimal.f90.html"},{"title":"test_module.f90 – Object-oriented Fortran 2008 HDF5 interface","text":"Contents Programs test_hdf5 Source Code test_module.f90 Source Code program test_hdf5 !! unit tests and registration tests of HDF5 OO interface use , intrinsic :: iso_fortran_env , only : int32 , real32 , real64 , stderr => error_unit use h5fortran , only : hdf5_file , h5write , h5read implicit none ( type , external ) call testGroup () print * , 'PASSED: HDF5 group' call test_writeExistingVariable () print * , 'PASSED: write existing variable' contains subroutine testGroup () type ( hdf5_file ) :: h5f call h5f % initialize ( 'test_groups.h5' , status = 'replace' ) call h5f % write_group ( '/test/' ) call h5f % open ( '/test' ) call h5f % write ( 'group3/scalar' , 1_int32 ) call h5f % write ( 'group3/scalar_real' , 1._real32 ) call h5f % close () call h5f % finalize () end subroutine testGroup subroutine test_writeExistingVariable () type ( hdf5_file ) :: h5f character ( * ), parameter :: fn = 'overwrite.h5' call h5f % initialize ( fn , status = 'replace' ) call h5f % write ( '/scalar_int' , 42_int32 ) call h5f % write ( '/int1d' , [ 42_int32 , 1_int32 ]) call h5f % finalize () call h5f % initialize ( fn , status = 'old' , action = 'rw' ) call h5f % write ( '/scalar_int' , 100_int32 ) call h5f % write ( '/int1d' , [ 100_int32 , 10_int32 ]) call h5f % finalize () end subroutine test_writeExistingVariable end program","tags":"","loc":"sourcefile/test_module.f90.html"},{"title":"test_scalar.f90 – Object-oriented Fortran 2008 HDF5 interface","text":"Contents Programs scalar_test Source Code test_scalar.f90 Source Code program scalar_test use , intrinsic :: iso_fortran_env , only : real32 , real64 , int32 , int64 , stderr => error_unit use h5fortran , only : hdf5_file use hdf5 , only : HSIZE_T , H5T_NATIVE_INTEGER , H5T_STD_I64LE implicit none ( type , external ) type ( hdf5_file ) :: h real ( real32 ), allocatable :: rr1 (:) real ( real32 ) :: rt , r1 ( 4 ) integer ( int32 ) :: it , i1 ( 4 ) integer ( int32 ), allocatable :: i1t (:) integer ( int64 ) :: it_64 , i1_64 ( 4 ) integer ( int64 ), allocatable :: i1t_64 (:) integer ( HSIZE_T ), allocatable :: dims (:) integer :: i character ( * ), parameter :: fn = 'test_scalar.h5' do i = 1 , size ( i1 ) i1 ( i ) = i enddo r1 = i1 i1_64 = i1 !> write call h % initialize ( fn , status = 'replace' ) !> scalar tests call h % write ( '/scalar_int32' , 42_int32 ) call h % write ( '/scalar_int64' , 42_int64 ) call h % write ( '/scalar_real' , - 1._real32 ) !> vector call h % write ( '/1d_real' , r1 ) !> create then write call h % create ( '/1d_int32' , H5T_NATIVE_INTEGER , shape ( i1 )) call h % write ( '/1d_int32' , i1 ) call h % create ( '/1d_int64' , H5T_STD_I64LE , shape ( i1_64 )) call h % write ( '/1d_int64' , i1_64 ) print * , 'PASSED: vector write' !> test rewrite call h % write ( 'scalar_real' , 4 2. ) call h % write ( 'scalar_int32' , 42_int32 ) call h % write ( 'scalar_int64' , 42_int64 ) call h % finalize () !> read call h % initialize ( fn , status = 'old' , action = 'r' ) call h % read ( '/scalar_int32' , it ) call h % read ( '/scalar_int64' , it_64 ) call h % read ( '/scalar_real' , rt ) if (. not .( rt == it . and . it == 42 )) then write ( stderr , * ) it , '/=' , rt error stop 'scalar real / int: not equal 42' endif print * , 'PASSED: scalar read/write' !> read casting -- real to int and int to real call h % read ( '/scalar_real' , it ) if ( it /= 42 ) error stop 'scalar cast real => int' call h % read ( '/scalar_int32' , rt ) if ( rt /= 42 ) error stop 'scalar cast int32 => real' call h % read ( '/scalar_int64' , rt ) if ( rt /= 42 ) error stop 'scalar cast int64 => real' print * , 'PASSED: scalar case on read' !> 1D vector read write call h % shape ( '/1d_real' , dims ) allocate ( rr1 ( dims ( 1 ))) call h % read ( '/1d_real' , rr1 ) if (. not . all ( r1 == rr1 )) error stop 'real 1-D: read does not match write' call h % shape ( '/1d_int32' , dims ) allocate ( i1t ( dims ( 1 ))) call h % read ( '/1d_int32' , i1t ) if (. not . all ( i1 == i1t )) error stop 'int32 1-D: read does not match write' allocate ( i1t_64 ( dims ( 1 ))) call h % read ( '/1d_int64' , i1t_64 ) if (. not . all ( i1_64 == i1t_64 )) error stop 'int64 1-D: read does not match write' print * , 'PASSED: 1D read/write' !> 1D vector read casting -- real to int and int to real call h % read ( '/1d_real' , i1t ) if (. not . all ( r1 == i1t )) error stop '1Dcast real => int32' call h % read ( '/1d_real' , i1t_64 ) if (. not . all ( r1 == i1t_64 )) error stop '1Dcast real => int64' call h % read ( '/1d_int32' , rr1 ) if (. not . all ( i1 == rr1 )) error stop '1D cast int32 => real' call h % read ( '/1d_int64' , rr1 ) if (. not . all ( i1_64 == rr1 )) error stop '1D cast int64 => real' !> check filename property if (. not . h % filename == fn ) then write ( stderr , * ) h % filename // ' mismatch filename' error stop endif call h % finalize () end program","tags":"","loc":"sourcefile/test_scalar.f90.html"},{"title":"test_shape.f90 – Object-oriented Fortran 2008 HDF5 interface","text":"Contents Programs test_shape Source Code test_shape.f90 Source Code program test_shape !! This program shows how HDF5 dimension orders are distinct in different langauges use h5fortran , only : hdf5_file , hsize_t , is_hdf5 use , intrinsic :: iso_fortran_env , only : real64 , stdout => output_unit , stderr => error_unit implicit none ( type , external ) type ( hdf5_file ) :: h character ( * ), parameter :: path = 'test_shape.h5' integer ( HSIZE_T ), allocatable :: dims (:) integer :: d2 ( 3 , 4 ), d7 ( 2 , 1 , 3 , 4 , 7 , 6 , 5 ) call h % initialize ( path , status = 'scratch' ) call h % write ( '/d2' , d2 ) call h % write ( '/d7' , d7 ) call h % shape ( '/d2' , dims ) if ( h % ndims ( '/d2' ) /= size ( dims )) error stop 'rank /= size(dims)' if ( any ( dims /= shape ( d2 ))) error stop '2-D: file shape not match variable shape' call h % shape ( '/d7' , dims ) if ( h % ndims ( '/d7' ) /= size ( dims )) error stop 'rank /= size(dims)' if ( any ( dims /= shape ( d7 ))) error stop '7-D: file shape not match variable shape' call h % finalize () end program","tags":"","loc":"sourcefile/test_shape.f90.html"},{"title":"test_string.f90 – Object-oriented Fortran 2008 HDF5 interface","text":"Contents Programs test_string Source Code test_string.f90 Source Code program test_string use , intrinsic :: iso_fortran_env , only : stderr => error_unit use , intrinsic :: iso_c_binding , only : c_null_char use h5fortran , only : hdf5_file implicit none ( type , external ) type ( hdf5_file ) :: h integer :: i character ( 2 ) :: value character ( 1024 ) :: val1k character (:), allocatable :: final character ( * ), parameter :: path = 'test_string.h5' call h % initialize ( path , status = 'replace' ) call h % write ( '/little' , '42' ) call h % write ( '/MySentence' , 'this is a little sentence.' ) call h % finalize () call h % initialize ( path , status = 'old' , action = 'r' ) call h % read ( '/little' , value ) if ( value /= '42' ) then write ( stderr , * ) 'test_string:  read/write verification failure. Value: ' // value error stop endif print * , 'test_string_rw: reading too much data' !! try reading too much data, then truncating to first C_NULL call h % read ( '/little' , val1k ) i = index ( val1k , c_null_char ) final = val1k (: i - 1 ) if ( len ( final ) /= 2 ) then write ( stderr , * ) 'trimming str to c_null did not work, got len() = ' , len ( final ) write ( stderr , * ) iachar ( final ( 3 : 3 )) error stop endif call h % finalize () print * , 'PASSED: HDF5 string write/read' end program","tags":"","loc":"sourcefile/test_string.f90.html"},{"title":"write.f90 – Object-oriented Fortran 2008 HDF5 interface","text":"Contents Submodules write Source Code write.f90 Source Code submodule ( h5fortran ) write !! This submodule is for writing HDF5 data via child submodules use hdf5 , only : & h5screate_f , H5S_SCALAR_F , & h5dcreate_f , & h5pset_chunk_f , h5pset_layout_f , h5pset_deflate_f , h5pset_shuffle_f , h5pset_fletcher32_f , h5pcreate_f , h5pclose_f , & H5P_DATASET_CREATE_F , & h5gopen_f , & H5Lcreate_soft_f use H5LT , only : h5ltmake_dataset_string_f , h5ltpath_valid_f implicit none ( type , external ) contains module procedure hdf_create logical :: exists integer :: ierr integer ( HID_T ) :: pid , space_id , ds_id integer ( HSIZE_T ) :: vdims ( size ( dims )) if (. not . self % is_open ) error stop 'h5fortran:write: file handle is not open' call h5ltpath_valid_f ( self % lid , dname , . true ., exists , ierr ) !! h5lexists_f can false error with groups--just use h5ltpath_valid !! stricter than self%exists() since we're creating and/or writing variable if ( ierr /= 0 ) then write ( stderr , * ) 'ERROR:h5fortran:create: variable path invalid: ' , dname , ' in ' , self % filename error stop 6 endif !> allow user to specify int4 or int8 dims select type ( dims ) type is ( integer ( int32 )) vdims = int ( dims , int64 ) type is ( integer ( hsize_t )) vdims = dims class default write ( stderr , * ) 'ERROR:h5fortran:create: wrong type for dims: ' , dname , self % filename error stop 5 end select if ( self % debug ) print * , 'h5fortran:TRACE:create:exists: ' // dname , exists if ( exists ) then if (. not . present ( istart )) call hdf_shape_check ( self , dname , vdims ) !! FIXME: read and write slice shape not checked; but should check in future versions !> open dataset call h5dopen_f ( self % lid , dname , ds_id , ierr ) if ( ierr /= 0 ) then write ( stderr , * ) 'ERROR:h5fortran:create: could not open ' , dname , ' in ' , self % filename error stop endif if ( present ( did )) did = ds_id if ( present ( sid )) then call h5dget_space_f ( ds_id , sid , ierr ) if ( ierr /= 0 ) error stop 'h5fortran:create could not get dataset' endif return endif if ( self % debug ) print * , 'h5fortran:TRACE1: ' // dname !> Only new datasets go past this point call self % write_group ( dname , ierr ) if ( ierr /= 0 ) then write ( stderr , * ) 'ERROR:h5fortran:create: could not create group for ' , dname , ' in ' , self % filename error stop endif !> create properties pid = 0 !< sentinel if ( size ( vdims ) >= 2 ) then if ( self % debug ) print * , 'h5fortran:TRACE:create: deflate: ' // dname call set_deflate ( self , vdims , pid , ierr , chunk_size ) if ( ierr /= 0 ) error stop 'ERROR:h5fortran:create: problem setting deflate on' endif if ( present ( compact )) then ! print *, \"TRACE1: COMPACT\", compact !! don't set COMPACT after CHUNKED, will fail. And it's either or anyway. if ( compact . and . pid == 0 . and . product ( vdims ) * 8 < 60000 ) then !! 64000 byte limit, here we assumed 8 bytes / element call h5pcreate_f ( H5P_DATASET_CREATE_F , pid , ierr ) if ( check ( ierr , self % filename )) error stop call h5pset_layout_f ( pid , H5D_COMPACT_F , ierr ) if ( check ( ierr , self % filename )) error stop endif endif !> create dataspace if ( size ( vdims ) == 0 ) then call h5screate_f ( H5S_SCALAR_F , space_id , ierr ) else call h5screate_simple_f ( size ( vdims ), vdims , space_id , ierr ) endif if ( check ( ierr , self % filename , dname )) error stop !> create dataset if ( pid == 0 ) then call h5dcreate_f ( self % lid , dname , dtype , space_id , ds_id , ierr ) else call h5dcreate_f ( self % lid , dname , dtype , space_id , ds_id , ierr , pid ) if ( check ( ierr , self % filename , dname )) error stop call h5pclose_f ( pid , ierr ) if ( check ( ierr , self % filename , dname )) error stop endif if ( check ( ierr , self % filename , dname )) error stop if (. not .( present ( did ) . and . present ( sid ))) then if ( self % debug ) print * , 'h5fortran:TRACE:create: closing dataset ' , dname call hdf_wrapup ( ds_id , space_id , ierr ) endif if ( check ( ierr , self % filename , dname )) error stop if ( present ( sid )) sid = space_id if ( present ( did )) did = ds_id end procedure hdf_create module procedure create_softlink !! HDF5 soft link -- to variables in same file !! target need not exist (dangling link) !! linking to external files requires an external link (different function required) integer :: ierr call H5Lcreate_soft_f ( target , self % lid , link , ierr ) if ( check ( ierr , self % filename )) return end procedure create_softlink subroutine set_deflate ( self , dims , pid , ierr , chunk_size ) class ( hdf5_file ), intent ( inout ) :: self integer ( HSIZE_T ), intent ( in ) :: dims (:) integer ( HID_T ), intent ( out ) :: pid integer , intent ( out ) :: ierr integer , intent ( in ), optional :: chunk_size (:) integer ( HSIZE_T ) :: cs ( size ( dims )) pid = 0 if ( self % comp_lvl < 1 . or . self % comp_lvl > 9 ) return if ( present ( chunk_size )) then cs = chunk_size where ( cs > dims ) cs = dims if ( self % debug ) print * , 'TRACE: user request chunk_size ' , cs else !! guess chunk size, keeping in mind 1 Megabyte recommended maximum chunk size call guess_chunk_size ( dims , cs ) endif if ( any ( cs < 1 )) return if ( self % debug ) print * , 'DEBUG:set_deflate: dims: ' , dims , 'chunk size: ' , cs call h5pcreate_f ( H5P_DATASET_CREATE_F , pid , ierr ) if ( check ( ierr , self % filename )) return call h5pset_chunk_f ( pid , size ( dims ), cs , ierr ) if ( check ( ierr , self % filename )) return call h5pset_shuffle_f ( pid , ierr ) if ( check ( ierr , self % filename )) return call h5pset_fletcher32_f ( pid , ierr ) if ( check ( ierr , self % filename )) return call h5pset_deflate_f ( pid , self % comp_lvl , ierr ) if ( check ( ierr , self % filename )) return if ( self % debug ) print * , 'TRACE:set_deflate done' end subroutine set_deflate subroutine guess_chunk_size ( dims , chunk_size ) !! based on https://github.com/h5py/h5py/blob/master/h5py/_hl/filters.py !! refer to https://support.hdfgroup.org/HDF5/Tutor/layout.html integer ( HSIZE_T ), intent ( in ) :: dims (:) integer ( HSIZE_T ), intent ( out ) :: chunk_size (:) integer ( hsize_t ), parameter :: & CHUNK_BASE = 16000 , & !< Multiplier by which chunks are adjusted CHUNK_MIN = 8000 , & !< lower limit: 8 kbyte CHUNK_MAX = 1000000 , & !< upper limit: 1 Mbyte TYPESIZE = 8 !< bytes, assume real64 for simplicity integer ( hsize_t ) :: dset_size , target_size , chunk_bytes , i , j , ndims if ( product ( dims ) * TYPESIZE < CHUNK_MIN ) then chunk_size = 0 return endif ndims = size ( chunk_size ) chunk_size = dims dset_size = product ( chunk_size ) * TYPESIZE target_size = int ( CHUNK_BASE * ( 2 ** log10 ( real ( dset_size ) / 1e6 )), hsize_t ) if ( target_size > CHUNK_MAX ) target_size = CHUNK_MAX ! print *,'target_size [bytes]: ',target_size i = 0 do !! Repeatedly loop over the axes, dividing them by 2. !! Stop when: !!   1a. We're smaller than the target chunk size, OR !!   1b. We're within 50% of the target chunk size, AND !!    2. The chunk is smaller than the maximum chunk size chunk_bytes = product ( chunk_size ) * TYPESIZE if (( chunk_bytes < target_size . or . 2 * ( abs ( chunk_bytes - target_size ) / target_size ) < 1 ) . and . & chunk_bytes < CHUNK_MAX ) exit if ( product ( chunk_size ) == 1 ) exit !! Element size larger than CHUNK_MAX j = int ( modulo ( i , ndims ), hsize_t ) + 1 if ( j < 1 . or . j > ndims ) error stop 'auto index bounds error' chunk_size ( j ) = ceiling ( real ( chunk_size ( j )) / 2.0 ) i = i + 1 end do end subroutine guess_chunk_size module procedure hdf_open_group integer :: ier if (. not . self % is_open ) error stop 'h5fortran:write: file handle is not open' call h5gopen_f ( self % lid , gname , self % gid , ier ) if ( present ( ierr )) ierr = ier if ( check ( ier , self % filename , gname )) then if ( present ( ierr )) return error stop endif self % glid = self % lid self % lid = self % gid end procedure hdf_open_group module procedure hdf_close_group integer :: ier if (. not . self % is_open ) error stop 'h5fortran:write: file handle is not open' call h5gclose_f ( self % gid , ier ) if ( present ( ierr )) ierr = ier if ( check ( ier , self % filename )) then if ( present ( ierr )) return error stop endif self % lid = self % glid end procedure hdf_close_group end submodule write","tags":"","loc":"sourcefile/write.f90.html"},{"title":"writer.in.f90 – Object-oriented Fortran 2008 HDF5 interface","text":"Contents Submodules writer Source Code writer.in.f90 Source Code submodule ( h5fortran : write ) writer !! This submodule is for writing 0-D..7-D data use hdf5 , only : h5dwrite_f , H5T_STD_I64LE implicit none ( type , external ) contains module procedure hdf_write_scalar integer ( HID_T ) :: sid , did integer ( HSIZE_T ), allocatable :: dims (:) integer :: ier if (. not . self % is_open ) error stop 'h5fortran:writer: file handle is not open' allocate ( dims ( 0 )) did = 0 sid = 0 !! sentinel select type ( value ) type is ( character ( * )) call h5ltmake_dataset_string_f ( self % lid , dname , value , ier ) type is ( real ( real64 )) !! NOTE: 0d does not use chunk_size call hdf_create ( self , dname , H5T_NATIVE_DOUBLE , dims , sid , did , compact = compact ) call h5dwrite_f ( did , H5T_NATIVE_DOUBLE , value , dims , ier ) type is ( real ( real32 )) call hdf_create ( self , dname , H5T_NATIVE_REAL , dims , sid , did , compact = compact ) call h5dwrite_f ( did , H5T_NATIVE_REAL , value , dims , ier ) type is ( integer ( int32 )) call hdf_create ( self , dname , H5T_NATIVE_INTEGER , dims , sid , did , compact = compact ) call h5dwrite_f ( did , H5T_NATIVE_INTEGER , value , dims , ier ) type is ( integer ( int64 )) call hdf_create ( self , dname , H5T_STD_I64LE , dims , sid , did , compact = compact ) call h5dwrite_f ( did , H5T_STD_I64LE , value , dims , ier ) class default error stop 'h5fortran: invalid data type' end select if ( ier /= 0 ) then write ( stderr , * ) 'h5fortran:ERROR: could not write ' , dname , ' to ' , self % filename error stop endif call hdf_wrapup ( did , sid , ier ) if ( present ( ierr )) ierr = ier if ( check ( ier , self % filename , dname ) . and . . not . present ( ierr )) error stop end procedure hdf_write_scalar module procedure hdf_write_1d @ writer_template @ end procedure hdf_write_1d module procedure hdf_write_2d @ writer_template @ end procedure hdf_write_2d module procedure hdf_write_3d @ writer_template @ end procedure hdf_write_3d module procedure hdf_write_4d @ writer_template @ end procedure hdf_write_4d module procedure hdf_write_5d @ writer_template @ end procedure hdf_write_5d module procedure hdf_write_6d @ writer_template @ end procedure hdf_write_6d module procedure hdf_write_7d @ writer_template @ end procedure hdf_write_7d end submodule writer","tags":"","loc":"sourcefile/writer.in.f90.html"},{"title":"writer_lt.in.f90 – Object-oriented Fortran 2008 HDF5 interface","text":"Contents Submodules writer_lt Source Code writer_lt.in.f90 Source Code submodule ( h5fortran : write ) writer_lt implicit none ( type , external ) contains module procedure lt0write @ writer_lt_template @ end procedure lt0write module procedure lt1write @ writer_lt_template @ end procedure lt1write module procedure lt2write @ writer_lt_template @ end procedure lt2write module procedure lt3write @ writer_lt_template @ end procedure lt3write module procedure lt4write @ writer_lt_template @ end procedure lt4write module procedure lt5write @ writer_lt_template @ end procedure lt5write module procedure lt6write @ writer_lt_template @ end procedure lt6write module procedure lt7write @ writer_lt_template @ end procedure lt7write end submodule writer_lt","tags":"","loc":"sourcefile/writer_lt.in.f90.html"},{"title":"writer_nd.f90 – Object-oriented Fortran 2008 HDF5 interface","text":"conceptual--not tested Contents Submodules writer_ND Source Code writer_nd.f90 Source Code !! conceptual--not tested submodule ( h5fortran : write ) writer_ND implicit none ( type , external ) contains module procedure hdf_write_8d integer ( HID_T ) :: dtype , sid , did integer ( HSIZE_T ) :: dims ( rank ( value )) integer :: i ( rank ( value )) TYPE ( C_PTR ) :: f_ptr ierr = 0 select type ( value ) type is ( real ( real64 )) dims = shape ( value ) dtype = h5kind_to_type ( kind ( value ), H5_REAL_KIND ) call hdf_create ( self , dname , dtype , dims , sid , did ) i = lbound ( value ) f_ptr = c_loc ( value ( i ( 1 ), i ( 2 ), i ( 3 ), i ( 4 ), i ( 5 ), i ( 6 ), i ( 7 ), i ( 8 ))) call h5dwrite_f ( did , dtype , f_ptr , ierr ) type is ( real ( real32 )) dtype = h5kind_to_type ( kind ( value ), H5_REAL_KIND ) dims = shape ( value ) call hdf_create ( self , dname , dtype , dims , sid , did ) i = lbound ( value ) f_ptr = c_loc ( value ( i ( 1 ), i ( 2 ), i ( 3 ), i ( 4 ), i ( 5 ), i ( 6 ), i ( 7 ), i ( 8 ))) call h5dwrite_f ( did , dtype , f_ptr , ierr ) type is ( integer ( int32 )) dtype = h5kind_to_type ( kind ( value ), H5_INTEGER_KIND ) dims = shape ( value ) call hdf_create ( self , dname , dtype , dims , sid , did ) i = lbound ( value ) f_ptr = c_loc ( value ( i ( 1 ), i ( 2 ), i ( 3 ), i ( 4 ), i ( 5 ), i ( 6 ), i ( 7 ), i ( 8 ))) call h5dwrite_f ( did , dtype , f_ptr , ierr ) type is ( integer ( int64 )) dtype = h5kind_to_type ( kind ( value ), H5_INTEGER_KIND ) dims = shape ( value ) call hdf_create ( self , dname , dtype , dims , sid , did ) i = lbound ( value ) f_ptr = c_loc ( value ( i ( 1 ), i ( 2 ), i ( 3 ), i ( 4 ), i ( 5 ), i ( 6 ), i ( 7 ), i ( 8 ))) call h5dwrite_f ( did , dtype , f_ptr , ierr ) class default ierr = 6 end select call hdf_wrapup ( did , sid , ierr ) if ( check ( ierr , 'ERROR: ' // dname // ' write ' // self % filename )) return end procedure hdf_write_8d end submodule writer_ND","tags":"","loc":"sourcefile/writer_nd.f90.html"},{"title":"hdf5_file – Object-oriented Fortran 2008 HDF5 interface ","text":"type, public :: hdf5_file main type Contents Variables filename lid gid glid comp_lvl verbose debug is_open is_scratch libversion Type-Bound Procedures softlink is_compact is_chunked is_contig exists exist chunks layout shape ndims flush close open create write_group finalize initialize write writeattr readattr read readattr_num readattr_char writeattr_num writeattr_char hdf_read_7d hdf_read_6d hdf_read_5d hdf_read_4d hdf_read_3d hdf_read_2d hdf_read_1d hdf_read_scalar hdf_write_7d hdf_write_6d hdf_write_5d hdf_write_4d hdf_write_3d hdf_write_2d hdf_write_1d hdf_write_scalar Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: filename integer(kind=HID_T), public :: lid = 0 integer(kind=HID_T), public :: gid integer(kind=HID_T), public :: glid integer, public :: comp_lvl = 0 logical, public :: verbose = .true. logical, public :: debug = .false. logical, public :: is_open = .false. logical, public :: is_scratch = .false. will be auto-deleted on close integer, public :: libversion (3) Type-Bound Procedures procedure, public :: softlink => create_softlink define methods (procedures) that don't need generic procedure interface private module subroutine create_softlink(self, target, link) Implementation → Arguments Type Intent Optional Attributes Name class( hdf5_file ), intent(inout) :: self character(len=*), intent(in) :: target character(len=*), intent(in) :: link procedure, public :: is_compact => hdf_is_compact private function hdf_is_compact (self, dname) Arguments Type Intent Optional Attributes Name class( hdf5_file ), intent(in) :: self character(len=*), intent(in) :: dname Return Value logical procedure, public :: is_chunked => hdf_is_chunked private function hdf_is_chunked (self, dname) Arguments Type Intent Optional Attributes Name class( hdf5_file ), intent(in) :: self character(len=*), intent(in) :: dname Return Value logical procedure, public :: is_contig => hdf_is_contig private function hdf_is_contig (self, dname) Arguments Type Intent Optional Attributes Name class( hdf5_file ), intent(in) :: self character(len=*), intent(in) :: dname Return Value logical procedure, public :: exists => hdf_check_exist interface private module function hdf_check_exist(self, dname) result(exists) Implementation → Arguments Type Intent Optional Attributes Name class( hdf5_file ), intent(in) :: self character(len=*), intent(in) :: dname Return Value logical procedure, public :: exist => hdf_check_exist interface private module function hdf_check_exist(self, dname) result(exists) Implementation → Arguments Type Intent Optional Attributes Name class( hdf5_file ), intent(in) :: self character(len=*), intent(in) :: dname Return Value logical procedure, public :: chunks => hdf_get_chunk interface private module subroutine hdf_get_chunk(self, dname, chunk_size) Implementation → Arguments Type Intent Optional Attributes Name class( hdf5_file ), intent(in) :: self character(len=*), intent(in) :: dname integer(kind=hsize_t), intent(out) :: chunk_size (:) procedure, public :: layout => hdf_get_layout interface private module function hdf_get_layout(self, dname) result(layout) Implementation → H5D_CONTIGUOUS_F, H5D_CHUNKED_F, H5D_VIRTUAL_F, H5D_COMPACT_F Arguments Type Intent Optional Attributes Name class( hdf5_file ), intent(in) :: self character(len=*), intent(in) :: dname Return Value integer procedure, public :: shape => hdf_get_shape interface private module subroutine hdf_get_shape(self, dname, dims, ierr) Implementation → Arguments Type Intent Optional Attributes Name class( hdf5_file ), intent(in) :: self character(len=*), intent(in) :: dname integer(kind=HSIZE_T), intent(out), allocatable :: dims (:) integer, intent(out), optional :: ierr procedure, public :: ndims => hdf_get_ndims interface private module function hdf_get_ndims(self, dname) result(drank) Implementation → Arguments Type Intent Optional Attributes Name class( hdf5_file ), intent(in) :: self character(len=*), intent(in) :: dname Return Value integer procedure, public :: flush => hdf_flush private subroutine hdf_flush (self, ierr) Arguments Type Intent Optional Attributes Name class( hdf5_file ), intent(in) :: self integer, intent(out), optional :: ierr procedure, public :: close => hdf_close_group interface private module subroutine hdf_close_group(self, ierr) Implementation → Arguments Type Intent Optional Attributes Name class( hdf5_file ), intent(inout) :: self integer, intent(out), optional :: ierr procedure, public :: open => hdf_open_group interface private module subroutine hdf_open_group(self, gname, ierr) Implementation → Arguments Type Intent Optional Attributes Name class( hdf5_file ), intent(inout) :: self character(len=*), intent(in) :: gname integer, intent(out), optional :: ierr procedure, public :: create => hdf_create interface private module subroutine hdf_create(self, dname, dtype, dims, sid, did, chunk_size, istart, iend, stride, compact) Implementation → Arguments Type Intent Optional Attributes Name class( hdf5_file ), intent(inout) :: self character(len=*), intent(in) :: dname integer(kind=HID_T), intent(in) :: dtype class(*), intent(in) :: dims (:) integer(kind=HID_T), intent(out), optional :: sid integer(kind=HID_T), intent(out), optional :: did integer, intent(in), optional :: chunk_size (:) integer, intent(in), optional :: istart (:) integer, intent(in), optional :: iend (:) integer, intent(in), optional :: stride (:) logical, intent(in), optional :: compact keep istart, iend, stride for future slice shape check procedure, public :: write_group private subroutine write_group (self, gname, ierr) Arguments Type Intent Optional Attributes Name class( hdf5_file ), intent(in) :: self character(len=*), intent(in) :: gname integer, intent(out), optional :: ierr procedure, public :: finalize => hdf_finalize private subroutine hdf_finalize (self, ierr, close_hdf5_interface) This must be called on each HDF5 file to flush buffers to disk\n data loss can occur if program terminates before this procedure Read more… Arguments Type Intent Optional Attributes Name class( hdf5_file ), intent(inout) :: self integer, intent(out), optional :: ierr logical, intent(in), optional :: close_hdf5_interface procedure, public :: initialize => hdf_initialize private subroutine hdf_initialize (self, filename, ierr, status, action, comp_lvl, verbose, debug) Opens hdf5 file Read more… Arguments Type Intent Optional Attributes Name class( hdf5_file ), intent(inout) :: self character(len=*), intent(in) :: filename integer, intent(out), optional :: ierr character(len=*), intent(in), optional :: status character(len=*), intent(in), optional :: action integer, intent(in), optional :: comp_lvl logical, intent(in), optional :: verbose logical, intent(in), optional :: debug generic, public :: write => hdf_write_scalar , hdf_write_1d , hdf_write_2d , hdf_write_3d , hdf_write_4d , hdf_write_5d , hdf_write_6d , hdf_write_7d below are procedure that need generic mapping (type or rank agnostic)\n write group or dataset integer/real private interface hdf_write_scalar () Arguments None private interface hdf_write_1d () Arguments None private interface hdf_write_2d () Arguments None private interface hdf_write_3d () Arguments None private interface hdf_write_4d () Arguments None private interface hdf_write_5d () Arguments None private interface hdf_write_6d () Arguments None private interface hdf_write_7d () Arguments None generic, public :: writeattr => writeattr_char , writeattr_num write attributes private interface writeattr_char () Arguments None private interface writeattr_num () Arguments None generic, public :: readattr => readattr_char , readattr_num read attributes private interface readattr_char () Arguments None private interface readattr_num () Arguments None generic, public :: read => hdf_read_scalar , hdf_read_1d , hdf_read_2d , hdf_read_3d , hdf_read_4d , hdf_read_5d , hdf_read_6d , hdf_read_7d read dataset private interface hdf_read_scalar () Arguments None private interface hdf_read_1d () Arguments None private interface hdf_read_2d () Arguments None private interface hdf_read_3d () Arguments None private interface hdf_read_4d () Arguments None private interface hdf_read_5d () Arguments None private interface hdf_read_6d () Arguments None private interface hdf_read_7d () Arguments None procedure, private :: readattr_num private methods\n each method must be declared here, and above as a generic, public interface private module subroutine readattr_num(self, dname, attr, attrval, ierr) Implementation → Arguments Type Intent Optional Attributes Name class( hdf5_file ), intent(in) :: self character(len=*), intent(in) :: dname character(len=*), intent(in) :: attr class(*), intent(out) :: attrval (:) integer, intent(out), optional :: ierr procedure, private :: readattr_char interface private module subroutine readattr_char(self, dname, attr, attrval, ierr) Implementation → Arguments Type Intent Optional Attributes Name class( hdf5_file ), intent(in) :: self character(len=*), intent(in) :: dname character(len=*), intent(in) :: attr character(len=*), intent(inout) :: attrval intent(inout) for character integer, intent(out), optional :: ierr procedure, private :: writeattr_num interface private module subroutine writeattr_num(self, dname, attr, attrval, ierr) Implementation → Arguments Type Intent Optional Attributes Name class( hdf5_file ), intent(in) :: self character(len=*), intent(in) :: dname character(len=*), intent(in) :: attr class(*), intent(in) :: attrval (:) integer, intent(out), optional :: ierr procedure, private :: writeattr_char interface private module subroutine writeattr_char(self, dname, attr, attrval, ierr) Implementation → Arguments Type Intent Optional Attributes Name class( hdf5_file ), intent(in) :: self character(len=*), intent(in) :: dname character(len=*), intent(in) :: attr character(len=*), intent(in) :: attrval integer, intent(out), optional :: ierr procedure, private :: hdf_read_7d interface private module subroutine hdf_read_7d(self, dname, value, ierr, istart, iend, stride) Implementation → Arguments Type Intent Optional Attributes Name class( hdf5_file ), intent(in) :: self character(len=*), intent(in) :: dname class(*), intent(out) :: value (:,:,:,:,:,:,:) integer, intent(out), optional :: ierr integer, intent(in), optional dimension(:) :: istart integer, intent(in), optional dimension(:) :: iend integer, intent(in), optional dimension(:) :: stride procedure, private :: hdf_read_6d interface private module subroutine hdf_read_6d(self, dname, value, ierr, istart, iend, stride) Implementation → Arguments Type Intent Optional Attributes Name class( hdf5_file ), intent(in) :: self character(len=*), intent(in) :: dname class(*), intent(out) :: value (:,:,:,:,:,:) integer, intent(out), optional :: ierr integer, intent(in), optional dimension(:) :: istart integer, intent(in), optional dimension(:) :: iend integer, intent(in), optional dimension(:) :: stride procedure, private :: hdf_read_5d interface private module subroutine hdf_read_5d(self, dname, value, ierr, istart, iend, stride) Implementation → Arguments Type Intent Optional Attributes Name class( hdf5_file ), intent(in) :: self character(len=*), intent(in) :: dname class(*), intent(out) :: value (:,:,:,:,:) integer, intent(out), optional :: ierr integer, intent(in), optional dimension(:) :: istart integer, intent(in), optional dimension(:) :: iend integer, intent(in), optional dimension(:) :: stride procedure, private :: hdf_read_4d interface private module subroutine hdf_read_4d(self, dname, value, ierr, istart, iend, stride) Implementation → Arguments Type Intent Optional Attributes Name class( hdf5_file ), intent(in) :: self character(len=*), intent(in) :: dname class(*), intent(out) :: value (:,:,:,:) integer, intent(out), optional :: ierr integer, intent(in), optional dimension(:) :: istart integer, intent(in), optional dimension(:) :: iend integer, intent(in), optional dimension(:) :: stride procedure, private :: hdf_read_3d interface private module subroutine hdf_read_3d(self, dname, value, ierr, istart, iend, stride) Implementation → Arguments Type Intent Optional Attributes Name class( hdf5_file ), intent(in) :: self character(len=*), intent(in) :: dname class(*), intent(out) :: value (:,:,:) integer, intent(out), optional :: ierr integer, intent(in), optional dimension(:) :: istart integer, intent(in), optional dimension(:) :: iend integer, intent(in), optional dimension(:) :: stride procedure, private :: hdf_read_2d interface private module subroutine hdf_read_2d(self, dname, value, ierr, istart, iend, stride) Implementation → Arguments Type Intent Optional Attributes Name class( hdf5_file ), intent(in) :: self character(len=*), intent(in) :: dname class(*), intent(out) :: value (:,:) integer, intent(out), optional :: ierr integer, intent(in), optional dimension(:) :: istart integer, intent(in), optional dimension(:) :: iend integer, intent(in), optional dimension(:) :: stride procedure, private :: hdf_read_1d interface private module subroutine hdf_read_1d(self, dname, value, ierr, istart, iend, stride) Implementation → Arguments Type Intent Optional Attributes Name class( hdf5_file ), intent(in) :: self character(len=*), intent(in) :: dname class(*), intent(out) :: value (:) integer, intent(out), optional :: ierr integer, intent(in), optional dimension(:) :: istart integer, intent(in), optional dimension(:) :: iend integer, intent(in), optional dimension(:) :: stride procedure, private :: hdf_read_scalar interface private module subroutine hdf_read_scalar(self, dname, value, ierr) Implementation → Arguments Type Intent Optional Attributes Name class( hdf5_file ), intent(in) :: self character(len=*), intent(in) :: dname class(*), intent(inout) :: value intent(inout) for character integer, intent(out), optional :: ierr procedure, private :: hdf_write_7d interface private module subroutine hdf_write_7d(self, dname, value, ierr, chunk_size, istart, iend, stride, compact) Implementation → Arguments Type Intent Optional Attributes Name class( hdf5_file ), intent(inout) :: self character(len=*), intent(in) :: dname class(*), intent(in) :: value (:,:,:,:,:,:,:) integer, intent(out), optional :: ierr integer, intent(in), optional :: chunk_size (7) integer, intent(in), optional dimension(:) :: istart integer, intent(in), optional dimension(:) :: iend integer, intent(in), optional dimension(:) :: stride logical, intent(in), optional :: compact procedure, private :: hdf_write_6d interface private module subroutine hdf_write_6d(self, dname, value, ierr, chunk_size, istart, iend, stride, compact) Implementation → Arguments Type Intent Optional Attributes Name class( hdf5_file ), intent(inout) :: self character(len=*), intent(in) :: dname class(*), intent(in) :: value (:,:,:,:,:,:) integer, intent(out), optional :: ierr integer, intent(in), optional :: chunk_size (6) integer, intent(in), optional dimension(:) :: istart integer, intent(in), optional dimension(:) :: iend integer, intent(in), optional dimension(:) :: stride logical, intent(in), optional :: compact procedure, private :: hdf_write_5d interface private module subroutine hdf_write_5d(self, dname, value, ierr, chunk_size, istart, iend, stride, compact) Implementation → Arguments Type Intent Optional Attributes Name class( hdf5_file ), intent(inout) :: self character(len=*), intent(in) :: dname class(*), intent(in) :: value (:,:,:,:,:) integer, intent(out), optional :: ierr integer, intent(in), optional :: chunk_size (5) integer, intent(in), optional dimension(:) :: istart integer, intent(in), optional dimension(:) :: iend integer, intent(in), optional dimension(:) :: stride logical, intent(in), optional :: compact procedure, private :: hdf_write_4d interface private module subroutine hdf_write_4d(self, dname, value, ierr, chunk_size, istart, iend, stride, compact) Implementation → Arguments Type Intent Optional Attributes Name class( hdf5_file ), intent(inout) :: self character(len=*), intent(in) :: dname class(*), intent(in) :: value (:,:,:,:) integer, intent(out), optional :: ierr integer, intent(in), optional :: chunk_size (4) integer, intent(in), optional dimension(:) :: istart integer, intent(in), optional dimension(:) :: iend integer, intent(in), optional dimension(:) :: stride logical, intent(in), optional :: compact procedure, private :: hdf_write_3d interface private module subroutine hdf_write_3d(self, dname, value, ierr, chunk_size, istart, iend, stride, compact) Implementation → Arguments Type Intent Optional Attributes Name class( hdf5_file ), intent(inout) :: self character(len=*), intent(in) :: dname class(*), intent(in) :: value (:,:,:) integer, intent(out), optional :: ierr integer, intent(in), optional :: chunk_size (3) integer, intent(in), optional dimension(:) :: istart integer, intent(in), optional dimension(:) :: iend integer, intent(in), optional dimension(:) :: stride logical, intent(in), optional :: compact procedure, private :: hdf_write_2d interface private module subroutine hdf_write_2d(self, dname, value, ierr, chunk_size, istart, iend, stride, compact) Implementation → Arguments Type Intent Optional Attributes Name class( hdf5_file ), intent(inout) :: self character(len=*), intent(in) :: dname class(*), intent(in) :: value (:,:) integer, intent(out), optional :: ierr integer, intent(in), optional :: chunk_size (2) integer, intent(in), optional dimension(:) :: istart integer, intent(in), optional dimension(:) :: iend integer, intent(in), optional dimension(:) :: stride logical, intent(in), optional :: compact procedure, private :: hdf_write_1d interface private module subroutine hdf_write_1d(self, dname, value, ierr, chunk_size, istart, iend, stride, compact) Implementation → Arguments Type Intent Optional Attributes Name class( hdf5_file ), intent(inout) :: self character(len=*), intent(in) :: dname class(*), intent(in) :: value (:) integer, intent(out), optional :: ierr integer, intent(in), optional :: chunk_size (1) integer, intent(in), optional dimension(:) :: istart integer, intent(in), optional dimension(:) :: iend integer, intent(in), optional dimension(:) :: stride logical, intent(in), optional :: compact procedure, private :: hdf_write_scalar interface private module subroutine hdf_write_scalar(self, dname, value, ierr, compact) Implementation → Arguments Type Intent Optional Attributes Name class( hdf5_file ), intent(inout) :: self character(len=*), intent(in) :: dname class(*), intent(in) :: value integer, intent(out), optional :: ierr logical, intent(in), optional :: compact","tags":"","loc":"type/hdf5_file.html"},{"title":"foo – Object-oriented Fortran 2008 HDF5 interface ","text":"type :: foo Contents Variables i44 Components Type Visibility Attributes Name Initial integer, public :: i44 (4,4)","tags":"","loc":"type/foo.html"},{"title":"attr_shape_check – Object-oriented Fortran 2008 HDF5 interface","text":"subroutine attr_shape_check(self, dname, attr, asize, ierr) check for matching rank, else bad reads can occur--doesn't always crash without this check\n check for matching size, else bad reads can occur. Arguments Type Intent Optional Attributes Name class( hdf5_file ), intent(in) :: self character(len=*), intent(in) :: dname character(len=*), intent(in) :: attr integer, intent(in) :: asize integer, intent(out) :: ierr Contents None","tags":"","loc":"proc/attr_shape_check.html"},{"title":"hdf_is_contig – Object-oriented Fortran 2008 HDF5 interface","text":"private function hdf_is_contig(self, dname) Arguments Type Intent Optional Attributes Name class( hdf5_file ), intent(in) :: self character(len=*), intent(in) :: dname Return Value logical Contents None","tags":"","loc":"proc/hdf_is_contig.html"},{"title":"hdf_is_compact – Object-oriented Fortran 2008 HDF5 interface","text":"private function hdf_is_compact(self, dname) Arguments Type Intent Optional Attributes Name class( hdf5_file ), intent(in) :: self character(len=*), intent(in) :: dname Return Value logical Contents None","tags":"","loc":"proc/hdf_is_compact.html"},{"title":"hdf_is_chunked – Object-oriented Fortran 2008 HDF5 interface","text":"private function hdf_is_chunked(self, dname) Arguments Type Intent Optional Attributes Name class( hdf5_file ), intent(in) :: self character(len=*), intent(in) :: dname Return Value logical Contents None","tags":"","loc":"proc/hdf_is_chunked.html"},{"title":"is_hdf5 – Object-oriented Fortran 2008 HDF5 interface","text":"public function is_hdf5(filename) is this file HDF5? avoid warning/error messages\n sometimes h5fis_hdf5_f is .true. for missing file Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename Return Value logical Contents None","tags":"","loc":"proc/is_hdf5.html"},{"title":"check – Object-oriented Fortran 2008 HDF5 interface","text":"public function check(ierr, filename, dname) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ierr character(len=*), intent(in), optional :: filename character(len=*), intent(in), optional :: dname Return Value logical Contents None","tags":"","loc":"proc/check.html"},{"title":"hdf_initialize – Object-oriented Fortran 2008 HDF5 interface","text":"private subroutine hdf_initialize(self, filename, ierr, status, action, comp_lvl, verbose, debug) Opens hdf5 file Initialize FORTRAN interface.\n get library version Arguments Type Intent Optional Attributes Name class( hdf5_file ), intent(inout) :: self character(len=*), intent(in) :: filename integer, intent(out), optional :: ierr character(len=*), intent(in), optional :: status character(len=*), intent(in), optional :: action integer, intent(in), optional :: comp_lvl logical, intent(in), optional :: verbose logical, intent(in), optional :: debug Contents None","tags":"","loc":"proc/hdf_initialize.html"},{"title":"hdf_finalize – Object-oriented Fortran 2008 HDF5 interface","text":"private subroutine hdf_finalize(self, ierr, close_hdf5_interface) This must be called on each HDF5 file to flush buffers to disk\n data loss can occur if program terminates before this procedure We don't reference count because applications might also invoke HDF5\n directly.\n close_hdf5_interface is when you know you have exactly one HDF5 file in your\n application, if true it closes ALL files, even those invoked directly from HDF5. close hdf5 file\n sentinel lid Arguments Type Intent Optional Attributes Name class( hdf5_file ), intent(inout) :: self integer, intent(out), optional :: ierr logical, intent(in), optional :: close_hdf5_interface Contents None","tags":"","loc":"proc/hdf_finalize.html"},{"title":"hdf_flush – Object-oriented Fortran 2008 HDF5 interface","text":"private subroutine hdf_flush(self, ierr) Arguments Type Intent Optional Attributes Name class( hdf5_file ), intent(in) :: self integer, intent(out), optional :: ierr Contents None","tags":"","loc":"proc/hdf_flush.html"},{"title":"hdf5_close – Object-oriented Fortran 2008 HDF5 interface","text":"public subroutine hdf5_close(ierr) this subroutine will close ALL existing file handles\n only call it at end of your program\n \"Flushes all data to disk, closes all open identifiers, and cleans up memory.\"\n \"Should be called by all HDF5 Fortran programs\" Arguments Type Intent Optional Attributes Name integer, intent(out), optional :: ierr Contents None","tags":"","loc":"proc/hdf5_close.html"},{"title":"write_group – Object-oriented Fortran 2008 HDF5 interface","text":"private subroutine write_group(self, gname, ierr) Arguments Type Intent Optional Attributes Name class( hdf5_file ), intent(in) :: self character(len=*), intent(in) :: gname integer, intent(out), optional :: ierr Contents None","tags":"","loc":"proc/write_group.html"},{"title":"hdf_wrapup – Object-oriented Fortran 2008 HDF5 interface","text":"public subroutine hdf_wrapup(did, sid, ierr) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: did integer(kind=HID_T), intent(in) :: sid integer, intent(out) :: ierr Contents None","tags":"","loc":"proc/hdf_wrapup.html"},{"title":"hdf_get_slice – Object-oriented Fortran 2008 HDF5 interface","text":"public subroutine hdf_get_slice(self, dname, did, sid, mem_sid, i0, i1, i2) setup array slices for read and write\n istart\n iend stride compensate for 0-based hyperslab vs. 1-based Fortran\n some callers have already opened the dataset. 0 is a sentinel saying not opened yet. Arguments Type Intent Optional Attributes Name class( hdf5_file ), intent(in) :: self character(len=*), intent(in) :: dname integer(kind=HID_T), intent(inout) :: did integer(kind=hid_t), intent(out) :: sid integer(kind=hid_t), intent(out) :: mem_sid class(*), intent(in), dimension(:) :: i0 class(*), intent(in), dimension(:) :: i1 class(*), intent(in), optional dimension(:) :: i2 Contents None","tags":"","loc":"proc/hdf_get_slice.html"},{"title":"hdf_shape_check – Object-oriented Fortran 2008 HDF5 interface","text":"public subroutine hdf_shape_check(self, dname, dims) allow user to specify int4 or int8 dims\n check for matching rank, else bad reads can occur--doesn't always crash without this check\n check for matching size, else bad reads can occur. Arguments Type Intent Optional Attributes Name class( hdf5_file ), intent(in) :: self character(len=*), intent(in) :: dname class(*), intent(in) :: dims (:) Contents None","tags":"","loc":"proc/hdf_shape_check.html"},{"title":"h5write – Object-oriented Fortran 2008 HDF5 interface","text":"public interface h5write Contents Module Procedures lt0write lt1write lt2write lt3write lt4write lt5write lt6write lt7write Module Procedures private interface lt0write () Arguments None private interface lt1write () Arguments None private interface lt2write () Arguments None private interface lt3write () Arguments None private interface lt4write () Arguments None private interface lt5write () Arguments None private interface lt6write () Arguments None private interface lt7write () Arguments None","tags":"","loc":"interface/h5write.html"},{"title":"h5read – Object-oriented Fortran 2008 HDF5 interface","text":"public interface h5read Contents Module Procedures lt0read lt1read lt2read lt3read lt4read lt5read lt6read lt7read Module Procedures private interface lt0read () Arguments None private interface lt1read () Arguments None private interface lt2read () Arguments None private interface lt3read () Arguments None private interface lt4read () Arguments None private interface lt5read () Arguments None private interface lt6read () Arguments None private interface lt7read () Arguments None","tags":"","loc":"interface/h5read.html"},{"title":"h5write_attr – Object-oriented Fortran 2008 HDF5 interface","text":"public interface h5write_attr Contents Module Procedures writeattr_num_lt writeattr_char_lt Module Procedures private interface writeattr_num_lt () Arguments None private interface writeattr_char_lt () Arguments None","tags":"","loc":"interface/h5write_attr.html"},{"title":"h5read_attr – Object-oriented Fortran 2008 HDF5 interface","text":"public interface h5read_attr Contents Module Procedures readattr_num_lt readattr_char_lt Module Procedures private interface readattr_num_lt () Arguments None private interface readattr_char_lt () Arguments None","tags":"","loc":"interface/h5read_attr.html"},{"title":"std_unlink – Object-oriented Fortran 2008 HDF5 interface","text":"interface Submodules private module function std_unlink(filename) Implementation → Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename Return Value logical","tags":"","loc":"interface/std_unlink.html"},{"title":"is_absolute_path – Object-oriented Fortran 2008 HDF5 interface","text":"interface Submodules private module function is_absolute_path(path) Implementation → Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: path Return Value logical","tags":"","loc":"interface/is_absolute_path.html"},{"title":"get_tempdir – Object-oriented Fortran 2008 HDF5 interface","text":"interface Submodules private module function get_tempdir() Implementation → Arguments None Return Value character(len=:),\n  allocatable","tags":"","loc":"interface/get_tempdir.html"},{"title":"hdf_create – Object-oriented Fortran 2008 HDF5 interface","text":"interface private module subroutine hdf_create(self, dname, dtype, dims, sid, did, chunk_size, istart, iend, stride, compact) Implementation → Arguments Type Intent Optional Attributes Name class( hdf5_file ), intent(inout) :: self character(len=*), intent(in) :: dname integer(kind=HID_T), intent(in) :: dtype class(*), intent(in) :: dims (:) integer(kind=HID_T), intent(out), optional :: sid integer(kind=HID_T), intent(out), optional :: did integer, intent(in), optional :: chunk_size (:) integer, intent(in), optional :: istart (:) integer, intent(in), optional :: iend (:) integer, intent(in), optional :: stride (:) logical, intent(in), optional :: compact keep istart, iend, stride for future slice shape check","tags":"","loc":"interface/hdf_create.html"},{"title":"hdf_open_group – Object-oriented Fortran 2008 HDF5 interface","text":"interface private module subroutine hdf_open_group(self, gname, ierr) Implementation → Arguments Type Intent Optional Attributes Name class( hdf5_file ), intent(inout) :: self character(len=*), intent(in) :: gname integer, intent(out), optional :: ierr","tags":"","loc":"interface/hdf_open_group.html"},{"title":"hdf_close_group – Object-oriented Fortran 2008 HDF5 interface","text":"interface private module subroutine hdf_close_group(self, ierr) Implementation → Arguments Type Intent Optional Attributes Name class( hdf5_file ), intent(inout) :: self integer, intent(out), optional :: ierr","tags":"","loc":"interface/hdf_close_group.html"},{"title":"create_softlink – Object-oriented Fortran 2008 HDF5 interface","text":"interface private module subroutine create_softlink(self, target, link) Implementation → Arguments Type Intent Optional Attributes Name class( hdf5_file ), intent(inout) :: self character(len=*), intent(in) :: target character(len=*), intent(in) :: link","tags":"","loc":"interface/create_softlink.html"},{"title":"h5exist – Object-oriented Fortran 2008 HDF5 interface","text":"interface public module function h5exist(filename, dname) Implementation → Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename character(len=*), intent(in) :: dname Return Value logical","tags":"","loc":"interface/h5exist.html"},{"title":"lt0write – Object-oriented Fortran 2008 HDF5 interface","text":"interface private module subroutine lt0write(filename, dname, value, ierr) Implementation → Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename character(len=*), intent(in) :: dname class(*), intent(in) :: value integer, intent(out), optional :: ierr","tags":"","loc":"interface/lt0write.html"},{"title":"lt1write – Object-oriented Fortran 2008 HDF5 interface","text":"interface private module subroutine lt1write(filename, dname, value, ierr) Implementation → Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename character(len=*), intent(in) :: dname class(*), intent(in) :: value (:) integer, intent(out), optional :: ierr","tags":"","loc":"interface/lt1write.html"},{"title":"lt2write – Object-oriented Fortran 2008 HDF5 interface","text":"interface private module subroutine lt2write(filename, dname, value, ierr) Implementation → Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename character(len=*), intent(in) :: dname class(*), intent(in) :: value (:,:) integer, intent(out), optional :: ierr","tags":"","loc":"interface/lt2write.html"},{"title":"lt3write – Object-oriented Fortran 2008 HDF5 interface","text":"interface private module subroutine lt3write(filename, dname, value, ierr) Implementation → Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename character(len=*), intent(in) :: dname class(*), intent(in) :: value (:,:,:) integer, intent(out), optional :: ierr","tags":"","loc":"interface/lt3write.html"},{"title":"lt4write – Object-oriented Fortran 2008 HDF5 interface","text":"interface private module subroutine lt4write(filename, dname, value, ierr) Implementation → Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename character(len=*), intent(in) :: dname class(*), intent(in) :: value (:,:,:,:) integer, intent(out), optional :: ierr","tags":"","loc":"interface/lt4write.html"},{"title":"lt5write – Object-oriented Fortran 2008 HDF5 interface","text":"interface private module subroutine lt5write(filename, dname, value, ierr) Implementation → Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename character(len=*), intent(in) :: dname class(*), intent(in) :: value (:,:,:,:,:) integer, intent(out), optional :: ierr","tags":"","loc":"interface/lt5write.html"},{"title":"lt6write – Object-oriented Fortran 2008 HDF5 interface","text":"interface private module subroutine lt6write(filename, dname, value, ierr) Implementation → Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename character(len=*), intent(in) :: dname class(*), intent(in) :: value (:,:,:,:,:,:) integer, intent(out), optional :: ierr","tags":"","loc":"interface/lt6write.html"},{"title":"lt7write – Object-oriented Fortran 2008 HDF5 interface","text":"interface private module subroutine lt7write(filename, dname, value, ierr) Implementation → Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename character(len=*), intent(in) :: dname class(*), intent(in) :: value (:,:,:,:,:,:,:) integer, intent(out), optional :: ierr","tags":"","loc":"interface/lt7write.html"},{"title":"lt0read – Object-oriented Fortran 2008 HDF5 interface","text":"interface private module subroutine lt0read(filename, dname, value, ierr) Implementation → Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename character(len=*), intent(in) :: dname class(*), intent(out) :: value integer, intent(out), optional :: ierr","tags":"","loc":"interface/lt0read.html"},{"title":"lt1read – Object-oriented Fortran 2008 HDF5 interface","text":"interface private module subroutine lt1read(filename, dname, value, ierr) Implementation → Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename character(len=*), intent(in) :: dname class(*), intent(out) :: value (:) integer, intent(out), optional :: ierr","tags":"","loc":"interface/lt1read.html"},{"title":"lt2read – Object-oriented Fortran 2008 HDF5 interface","text":"interface private module subroutine lt2read(filename, dname, value, ierr) Implementation → Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename character(len=*), intent(in) :: dname class(*), intent(out) :: value (:,:) integer, intent(out), optional :: ierr","tags":"","loc":"interface/lt2read.html"},{"title":"lt3read – Object-oriented Fortran 2008 HDF5 interface","text":"interface private module subroutine lt3read(filename, dname, value, ierr) Implementation → Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename character(len=*), intent(in) :: dname class(*), intent(out) :: value (:,:,:) integer, intent(out), optional :: ierr","tags":"","loc":"interface/lt3read.html"},{"title":"lt4read – Object-oriented Fortran 2008 HDF5 interface","text":"interface private module subroutine lt4read(filename, dname, value, ierr) Implementation → Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename character(len=*), intent(in) :: dname class(*), intent(out) :: value (:,:,:,:) integer, intent(out), optional :: ierr","tags":"","loc":"interface/lt4read.html"},{"title":"lt5read – Object-oriented Fortran 2008 HDF5 interface","text":"interface private module subroutine lt5read(filename, dname, value, ierr) Implementation → Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename character(len=*), intent(in) :: dname class(*), intent(out) :: value (:,:,:,:,:) integer, intent(out), optional :: ierr","tags":"","loc":"interface/lt5read.html"},{"title":"lt6read – Object-oriented Fortran 2008 HDF5 interface","text":"interface private module subroutine lt6read(filename, dname, value, ierr) Implementation → Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename character(len=*), intent(in) :: dname class(*), intent(out) :: value (:,:,:,:,:,:) integer, intent(out), optional :: ierr","tags":"","loc":"interface/lt6read.html"},{"title":"lt7read – Object-oriented Fortran 2008 HDF5 interface","text":"interface private module subroutine lt7read(filename, dname, value, ierr) Implementation → Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename character(len=*), intent(in) :: dname class(*), intent(out) :: value (:,:,:,:,:,:,:) integer, intent(out), optional :: ierr","tags":"","loc":"interface/lt7read.html"},{"title":"hdf_write_scalar – Object-oriented Fortran 2008 HDF5 interface","text":"interface private module subroutine hdf_write_scalar(self, dname, value, ierr, compact) Implementation → Arguments Type Intent Optional Attributes Name class( hdf5_file ), intent(inout) :: self character(len=*), intent(in) :: dname class(*), intent(in) :: value integer, intent(out), optional :: ierr logical, intent(in), optional :: compact","tags":"","loc":"interface/hdf_write_scalar.html"},{"title":"hdf_write_1d – Object-oriented Fortran 2008 HDF5 interface","text":"interface private module subroutine hdf_write_1d(self, dname, value, ierr, chunk_size, istart, iend, stride, compact) Implementation → Arguments Type Intent Optional Attributes Name class( hdf5_file ), intent(inout) :: self character(len=*), intent(in) :: dname class(*), intent(in) :: value (:) integer, intent(out), optional :: ierr integer, intent(in), optional :: chunk_size (1) integer, intent(in), optional dimension(:) :: istart integer, intent(in), optional dimension(:) :: iend integer, intent(in), optional dimension(:) :: stride logical, intent(in), optional :: compact","tags":"","loc":"interface/hdf_write_1d.html"},{"title":"hdf_write_2d – Object-oriented Fortran 2008 HDF5 interface","text":"interface private module subroutine hdf_write_2d(self, dname, value, ierr, chunk_size, istart, iend, stride, compact) Implementation → Arguments Type Intent Optional Attributes Name class( hdf5_file ), intent(inout) :: self character(len=*), intent(in) :: dname class(*), intent(in) :: value (:,:) integer, intent(out), optional :: ierr integer, intent(in), optional :: chunk_size (2) integer, intent(in), optional dimension(:) :: istart integer, intent(in), optional dimension(:) :: iend integer, intent(in), optional dimension(:) :: stride logical, intent(in), optional :: compact","tags":"","loc":"interface/hdf_write_2d.html"},{"title":"hdf_write_3d – Object-oriented Fortran 2008 HDF5 interface","text":"interface private module subroutine hdf_write_3d(self, dname, value, ierr, chunk_size, istart, iend, stride, compact) Implementation → Arguments Type Intent Optional Attributes Name class( hdf5_file ), intent(inout) :: self character(len=*), intent(in) :: dname class(*), intent(in) :: value (:,:,:) integer, intent(out), optional :: ierr integer, intent(in), optional :: chunk_size (3) integer, intent(in), optional dimension(:) :: istart integer, intent(in), optional dimension(:) :: iend integer, intent(in), optional dimension(:) :: stride logical, intent(in), optional :: compact","tags":"","loc":"interface/hdf_write_3d.html"},{"title":"hdf_write_4d – Object-oriented Fortran 2008 HDF5 interface","text":"interface private module subroutine hdf_write_4d(self, dname, value, ierr, chunk_size, istart, iend, stride, compact) Implementation → Arguments Type Intent Optional Attributes Name class( hdf5_file ), intent(inout) :: self character(len=*), intent(in) :: dname class(*), intent(in) :: value (:,:,:,:) integer, intent(out), optional :: ierr integer, intent(in), optional :: chunk_size (4) integer, intent(in), optional dimension(:) :: istart integer, intent(in), optional dimension(:) :: iend integer, intent(in), optional dimension(:) :: stride logical, intent(in), optional :: compact","tags":"","loc":"interface/hdf_write_4d.html"},{"title":"hdf_write_5d – Object-oriented Fortran 2008 HDF5 interface","text":"interface private module subroutine hdf_write_5d(self, dname, value, ierr, chunk_size, istart, iend, stride, compact) Implementation → Arguments Type Intent Optional Attributes Name class( hdf5_file ), intent(inout) :: self character(len=*), intent(in) :: dname class(*), intent(in) :: value (:,:,:,:,:) integer, intent(out), optional :: ierr integer, intent(in), optional :: chunk_size (5) integer, intent(in), optional dimension(:) :: istart integer, intent(in), optional dimension(:) :: iend integer, intent(in), optional dimension(:) :: stride logical, intent(in), optional :: compact","tags":"","loc":"interface/hdf_write_5d.html"},{"title":"hdf_write_6d – Object-oriented Fortran 2008 HDF5 interface","text":"interface private module subroutine hdf_write_6d(self, dname, value, ierr, chunk_size, istart, iend, stride, compact) Implementation → Arguments Type Intent Optional Attributes Name class( hdf5_file ), intent(inout) :: self character(len=*), intent(in) :: dname class(*), intent(in) :: value (:,:,:,:,:,:) integer, intent(out), optional :: ierr integer, intent(in), optional :: chunk_size (6) integer, intent(in), optional dimension(:) :: istart integer, intent(in), optional dimension(:) :: iend integer, intent(in), optional dimension(:) :: stride logical, intent(in), optional :: compact","tags":"","loc":"interface/hdf_write_6d.html"},{"title":"hdf_write_7d – Object-oriented Fortran 2008 HDF5 interface","text":"interface private module subroutine hdf_write_7d(self, dname, value, ierr, chunk_size, istart, iend, stride, compact) Implementation → Arguments Type Intent Optional Attributes Name class( hdf5_file ), intent(inout) :: self character(len=*), intent(in) :: dname class(*), intent(in) :: value (:,:,:,:,:,:,:) integer, intent(out), optional :: ierr integer, intent(in), optional :: chunk_size (7) integer, intent(in), optional dimension(:) :: istart integer, intent(in), optional dimension(:) :: iend integer, intent(in), optional dimension(:) :: stride logical, intent(in), optional :: compact","tags":"","loc":"interface/hdf_write_7d.html"},{"title":"hdf_get_ndims – Object-oriented Fortran 2008 HDF5 interface","text":"interface private module function hdf_get_ndims(self, dname) result(drank) Implementation → Arguments Type Intent Optional Attributes Name class( hdf5_file ), intent(in) :: self character(len=*), intent(in) :: dname Return Value integer","tags":"","loc":"interface/hdf_get_ndims.html"},{"title":"hdf_get_layout – Object-oriented Fortran 2008 HDF5 interface","text":"interface private module function hdf_get_layout(self, dname) result(layout) Implementation → Arguments Type Intent Optional Attributes Name class( hdf5_file ), intent(in) :: self character(len=*), intent(in) :: dname Return Value integer Description H5D_CONTIGUOUS_F, H5D_CHUNKED_F, H5D_VIRTUAL_F, H5D_COMPACT_F","tags":"","loc":"interface/hdf_get_layout.html"},{"title":"hdf_check_exist – Object-oriented Fortran 2008 HDF5 interface","text":"interface private module function hdf_check_exist(self, dname) result(exists) Implementation → Arguments Type Intent Optional Attributes Name class( hdf5_file ), intent(in) :: self character(len=*), intent(in) :: dname Return Value logical","tags":"","loc":"interface/hdf_check_exist.html"},{"title":"hdf_get_shape – Object-oriented Fortran 2008 HDF5 interface","text":"interface private module subroutine hdf_get_shape(self, dname, dims, ierr) Implementation → Arguments Type Intent Optional Attributes Name class( hdf5_file ), intent(in) :: self character(len=*), intent(in) :: dname integer(kind=HSIZE_T), intent(out), allocatable :: dims (:) integer, intent(out), optional :: ierr","tags":"","loc":"interface/hdf_get_shape.html"},{"title":"hdf_get_chunk – Object-oriented Fortran 2008 HDF5 interface","text":"interface private module subroutine hdf_get_chunk(self, dname, chunk_size) Implementation → Arguments Type Intent Optional Attributes Name class( hdf5_file ), intent(in) :: self character(len=*), intent(in) :: dname integer(kind=hsize_t), intent(out) :: chunk_size (:)","tags":"","loc":"interface/hdf_get_chunk.html"},{"title":"hdf_read_scalar – Object-oriented Fortran 2008 HDF5 interface","text":"interface private module subroutine hdf_read_scalar(self, dname, value, ierr) Implementation → Arguments Type Intent Optional Attributes Name class( hdf5_file ), intent(in) :: self character(len=*), intent(in) :: dname class(*), intent(inout) :: value intent(inout) for character integer, intent(out), optional :: ierr","tags":"","loc":"interface/hdf_read_scalar.html"},{"title":"hdf_read_1d – Object-oriented Fortran 2008 HDF5 interface","text":"interface private module subroutine hdf_read_1d(self, dname, value, ierr, istart, iend, stride) Implementation → Arguments Type Intent Optional Attributes Name class( hdf5_file ), intent(in) :: self character(len=*), intent(in) :: dname class(*), intent(out) :: value (:) integer, intent(out), optional :: ierr integer, intent(in), optional dimension(:) :: istart integer, intent(in), optional dimension(:) :: iend integer, intent(in), optional dimension(:) :: stride","tags":"","loc":"interface/hdf_read_1d.html"},{"title":"hdf_read_2d – Object-oriented Fortran 2008 HDF5 interface","text":"interface private module subroutine hdf_read_2d(self, dname, value, ierr, istart, iend, stride) Implementation → Arguments Type Intent Optional Attributes Name class( hdf5_file ), intent(in) :: self character(len=*), intent(in) :: dname class(*), intent(out) :: value (:,:) integer, intent(out), optional :: ierr integer, intent(in), optional dimension(:) :: istart integer, intent(in), optional dimension(:) :: iend integer, intent(in), optional dimension(:) :: stride","tags":"","loc":"interface/hdf_read_2d.html"},{"title":"hdf_read_3d – Object-oriented Fortran 2008 HDF5 interface","text":"interface private module subroutine hdf_read_3d(self, dname, value, ierr, istart, iend, stride) Implementation → Arguments Type Intent Optional Attributes Name class( hdf5_file ), intent(in) :: self character(len=*), intent(in) :: dname class(*), intent(out) :: value (:,:,:) integer, intent(out), optional :: ierr integer, intent(in), optional dimension(:) :: istart integer, intent(in), optional dimension(:) :: iend integer, intent(in), optional dimension(:) :: stride","tags":"","loc":"interface/hdf_read_3d.html"},{"title":"hdf_read_4d – Object-oriented Fortran 2008 HDF5 interface","text":"interface private module subroutine hdf_read_4d(self, dname, value, ierr, istart, iend, stride) Implementation → Arguments Type Intent Optional Attributes Name class( hdf5_file ), intent(in) :: self character(len=*), intent(in) :: dname class(*), intent(out) :: value (:,:,:,:) integer, intent(out), optional :: ierr integer, intent(in), optional dimension(:) :: istart integer, intent(in), optional dimension(:) :: iend integer, intent(in), optional dimension(:) :: stride","tags":"","loc":"interface/hdf_read_4d.html"},{"title":"hdf_read_5d – Object-oriented Fortran 2008 HDF5 interface","text":"interface private module subroutine hdf_read_5d(self, dname, value, ierr, istart, iend, stride) Implementation → Arguments Type Intent Optional Attributes Name class( hdf5_file ), intent(in) :: self character(len=*), intent(in) :: dname class(*), intent(out) :: value (:,:,:,:,:) integer, intent(out), optional :: ierr integer, intent(in), optional dimension(:) :: istart integer, intent(in), optional dimension(:) :: iend integer, intent(in), optional dimension(:) :: stride","tags":"","loc":"interface/hdf_read_5d.html"},{"title":"hdf_read_6d – Object-oriented Fortran 2008 HDF5 interface","text":"interface private module subroutine hdf_read_6d(self, dname, value, ierr, istart, iend, stride) Implementation → Arguments Type Intent Optional Attributes Name class( hdf5_file ), intent(in) :: self character(len=*), intent(in) :: dname class(*), intent(out) :: value (:,:,:,:,:,:) integer, intent(out), optional :: ierr integer, intent(in), optional dimension(:) :: istart integer, intent(in), optional dimension(:) :: iend integer, intent(in), optional dimension(:) :: stride","tags":"","loc":"interface/hdf_read_6d.html"},{"title":"hdf_read_7d – Object-oriented Fortran 2008 HDF5 interface","text":"interface private module subroutine hdf_read_7d(self, dname, value, ierr, istart, iend, stride) Implementation → Arguments Type Intent Optional Attributes Name class( hdf5_file ), intent(in) :: self character(len=*), intent(in) :: dname class(*), intent(out) :: value (:,:,:,:,:,:,:) integer, intent(out), optional :: ierr integer, intent(in), optional dimension(:) :: istart integer, intent(in), optional dimension(:) :: iend integer, intent(in), optional dimension(:) :: stride","tags":"","loc":"interface/hdf_read_7d.html"},{"title":"readattr_char – Object-oriented Fortran 2008 HDF5 interface","text":"interface private module subroutine readattr_char(self, dname, attr, attrval, ierr) Implementation → Arguments Type Intent Optional Attributes Name class( hdf5_file ), intent(in) :: self character(len=*), intent(in) :: dname character(len=*), intent(in) :: attr character(len=*), intent(inout) :: attrval intent(inout) for character integer, intent(out), optional :: ierr","tags":"","loc":"interface/readattr_char.html"},{"title":"readattr_num – Object-oriented Fortran 2008 HDF5 interface","text":"interface private module subroutine readattr_num(self, dname, attr, attrval, ierr) Implementation → Arguments Type Intent Optional Attributes Name class( hdf5_file ), intent(in) :: self character(len=*), intent(in) :: dname character(len=*), intent(in) :: attr class(*), intent(out) :: attrval (:) integer, intent(out), optional :: ierr","tags":"","loc":"interface/readattr_num.html"},{"title":"writeattr_char – Object-oriented Fortran 2008 HDF5 interface","text":"interface private module subroutine writeattr_char(self, dname, attr, attrval, ierr) Implementation → Arguments Type Intent Optional Attributes Name class( hdf5_file ), intent(in) :: self character(len=*), intent(in) :: dname character(len=*), intent(in) :: attr character(len=*), intent(in) :: attrval integer, intent(out), optional :: ierr","tags":"","loc":"interface/writeattr_char.html"},{"title":"writeattr_num – Object-oriented Fortran 2008 HDF5 interface","text":"interface private module subroutine writeattr_num(self, dname, attr, attrval, ierr) Implementation → Arguments Type Intent Optional Attributes Name class( hdf5_file ), intent(in) :: self character(len=*), intent(in) :: dname character(len=*), intent(in) :: attr class(*), intent(in) :: attrval (:) integer, intent(out), optional :: ierr","tags":"","loc":"interface/writeattr_num.html"},{"title":"writeattr_char_lt – Object-oriented Fortran 2008 HDF5 interface","text":"interface private module subroutine writeattr_char_lt(filename, dname, attr, attrval, ierr) Implementation → Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename character(len=*), intent(in) :: dname character(len=*), intent(in) :: attr character(len=*), intent(in) :: attrval integer, intent(out), optional :: ierr","tags":"","loc":"interface/writeattr_char_lt.html"},{"title":"writeattr_num_lt – Object-oriented Fortran 2008 HDF5 interface","text":"interface private module subroutine writeattr_num_lt(filename, dname, attr, attrval, ierr) Implementation → Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename character(len=*), intent(in) :: dname character(len=*), intent(in) :: attr class(*), intent(in) :: attrval (:) integer, intent(out), optional :: ierr","tags":"","loc":"interface/writeattr_num_lt.html"},{"title":"readattr_char_lt – Object-oriented Fortran 2008 HDF5 interface","text":"interface private module subroutine readattr_char_lt(filename, dname, attr, attrval, ierr) Implementation → Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename character(len=*), intent(in) :: dname character(len=*), intent(in) :: attr character(len=*), intent(inout) :: attrval intent(inout) for character integer, intent(out), optional :: ierr","tags":"","loc":"interface/readattr_char_lt.html"},{"title":"readattr_num_lt – Object-oriented Fortran 2008 HDF5 interface","text":"interface private module subroutine readattr_num_lt(filename, dname, attr, attrval, ierr) Implementation → Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename character(len=*), intent(in) :: dname character(len=*), intent(in) :: attr class(*), intent(out) :: attrval (:) integer, intent(out), optional :: ierr","tags":"","loc":"interface/readattr_num_lt.html"},{"title":"create_file_image – Object-oriented Fortran 2008 HDF5 interface","text":"public subroutine create_file_image(fapl_id) open HDF5 library\n create file property ID \"fapl_id\"\n create and check empty buffer Arguments Type Intent Optional Attributes Name integer(kind=hid_t), intent(out) :: fapl_id Contents None","tags":"","loc":"proc/create_file_image.html"},{"title":"write_file_image – Object-oriented Fortran 2008 HDF5 interface","text":"public subroutine write_file_image(data, fapl_id) polymorphic in future implementation write data to HDF5 file image Arguments Type Intent Optional Attributes Name integer, intent(in) :: data (:) integer(kind=hid_t), intent(in) :: fapl_id Contents None","tags":"","loc":"proc/write_file_image.html"},{"title":"read_file_image – Object-oriented Fortran 2008 HDF5 interface","text":"public subroutine read_file_image(buffer, fapl_id) Arguments Type Intent Optional Attributes Name integer, intent(out), dimension(:), target :: buffer integer(kind=hid_t), intent(in) :: fapl_id Contents None","tags":"","loc":"proc/read_file_image.html"},{"title":"close_file_image – Object-oriented Fortran 2008 HDF5 interface","text":"public subroutine close_file_image(fapl_id) close file image and library Arguments Type Intent Optional Attributes Name integer(kind=hid_t), intent(in) :: fapl_id Contents None","tags":"","loc":"proc/close_file_image.html"},{"title":"sysclock2ms – Object-oriented Fortran 2008 HDF5 interface","text":"public impure elemental function sysclock2ms(t) Convert a number of clock ticks, as returned by system_clock() called\n with integer(int64) arguments, to milliseconds Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: t Return Value real(kind=real64) Contents None","tags":"","loc":"proc/sysclock2ms.html"},{"title":"print_layout – Object-oriented Fortran 2008 HDF5 interface","text":"public subroutine print_layout(filename, ds_name) prints dataset (variable) layout in a file\n get file size.\n get dataset storage layout\n not truly constants, so select case doesn't work Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename character(len=*), intent(in) :: ds_name Contents None","tags":"","loc":"proc/print_layout.html"},{"title":"write_layout – Object-oriented Fortran 2008 HDF5 interface","text":"public subroutine write_layout(file_id, ds_name, layout, dat) write real data with HDF5 layout type specified create dataspace\n create dataset property list\n config for dataset\n normally chunk size set more effectively for actual large datasets.\n create dataset\n write data close Arguments Type Intent Optional Attributes Name integer(kind=hid_t), intent(in) :: file_id character(len=*), intent(in) :: ds_name integer, intent(in) :: layout real, intent(in) :: dat (:) Contents None","tags":"","loc":"proc/write_layout.html"},{"title":"std_unlink – Object-oriented Fortran 2008 HDF5 interface","text":"private subroutine std_unlink(file) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file Contents None","tags":"","loc":"proc/std_unlink~2.html"},{"title":"bench_write – Object-oriented Fortran 2008 HDF5 interface","text":"public subroutine bench_write(file, layout, dat, N) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file integer, intent(in) :: layout real, intent(in) :: dat (:) integer, intent(in) :: N Contents None","tags":"","loc":"proc/bench_write.html"},{"title":"bench_read – Object-oriented Fortran 2008 HDF5 interface","text":"public subroutine bench_read(file, N, dat) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file integer, intent(in) :: N real, intent(out), optional :: dat (:) Contents None","tags":"","loc":"proc/bench_read.html"},{"title":"read_int64 – Object-oriented Fortran 2008 HDF5 interface","text":"function read_int64(fid, name) result(i) Arguments Type Intent Optional Attributes Name integer(kind=hid_t), intent(in) :: fid character(len=*), intent(in) :: name Return Value integer(kind=int64) Contents None","tags":"","loc":"proc/read_int64.html"},{"title":"verify_data – Object-oriented Fortran 2008 HDF5 interface","text":"subroutine verify_data(filename) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename Contents None","tags":"","loc":"proc/verify_data.html"},{"title":"write_data – Object-oriented Fortran 2008 HDF5 interface","text":"subroutine write_data(filename) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename Contents None","tags":"","loc":"proc/write_data.html"},{"title":"write_int64 – Object-oriented Fortran 2008 HDF5 interface","text":"subroutine write_int64(fid, i, name) dataspace create the dataset. write data close handles Arguments Type Intent Optional Attributes Name integer(kind=hid_t) :: fid integer(kind=int64), intent(in) :: i character(len=*), intent(in) :: name Contents None","tags":"","loc":"proc/write_int64.html"},{"title":"get_native_dtype – Object-oriented Fortran 2008 HDF5 interface","text":"function get_native_dtype(ds_id, dname, filename) result(native_dtype) get the dataset variable type\n the \"type\" and \"native_type\" are just IDs, the final native type is composed from:\n * enddianness\n * generic type\n we think endianness is handled by HDF5 ... ?\n compose datatype inferred Arguments Type Intent Optional Attributes Name integer(kind=hid_t), intent(in) :: ds_id character(len=*), intent(in) :: dname character(len=*), intent(in) :: filename Return Value integer(kind=hid_t) Contents None","tags":"","loc":"proc/get_native_dtype.html"},{"title":"getter – Object-oriented Fortran 2008 HDF5 interface","text":"subroutine getter(A) Arguments Type Intent Optional Attributes Name integer, intent(out) :: A (2,2) Contents None","tags":"","loc":"proc/getter.html"},{"title":"test_basic_array – Object-oriented Fortran 2008 HDF5 interface","text":"subroutine test_basic_array(filename) read\n int32\n verify reading into larger array\n real Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename tests that compression doesn't fail for very small datasets, where it really shouldn't be used (makes file bigger) Contents None","tags":"","loc":"proc/test_basic_array.html"},{"title":"test_read_slice – Object-oriented Fortran 2008 HDF5 interface","text":"subroutine test_read_slice(filename) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename Contents None","tags":"","loc":"proc/test_read_slice.html"},{"title":"test_write_slice – Object-oriented Fortran 2008 HDF5 interface","text":"subroutine test_write_slice(filename) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename Contents None","tags":"","loc":"proc/test_write_slice.html"},{"title":"test_readwrite_array – Object-oriented Fortran 2008 HDF5 interface","text":"subroutine test_readwrite_array(filename, ng, nn, pn) more group Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename integer, intent(in) :: ng integer, intent(in) :: nn integer, intent(in) :: pn Contents None","tags":"","loc":"proc/test_readwrite_array.html"},{"title":"test_write_attributes – Object-oriented Fortran 2008 HDF5 interface","text":"subroutine test_write_attributes(path) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: path Contents None","tags":"","loc":"proc/test_write_attributes.html"},{"title":"test_read_attributes – Object-oriented Fortran 2008 HDF5 interface","text":"subroutine test_read_attributes(path) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: path Contents None","tags":"","loc":"proc/test_read_attributes.html"},{"title":"test_hdf5_deflate – Object-oriented Fortran 2008 HDF5 interface","text":"subroutine test_hdf5_deflate() Arguments None Contents None","tags":"","loc":"proc/test_hdf5_deflate.html"},{"title":"test_nonexist_old_file – Object-oriented Fortran 2008 HDF5 interface","text":"subroutine test_nonexist_old_file() Arguments None Contents None","tags":"","loc":"proc/test_nonexist_old_file.html"},{"title":"test_nonexist_unknown_file – Object-oriented Fortran 2008 HDF5 interface","text":"subroutine test_nonexist_unknown_file() Arguments None Contents None","tags":"","loc":"proc/test_nonexist_unknown_file.html"},{"title":"test_nonhdf5_file – Object-oriented Fortran 2008 HDF5 interface","text":"subroutine test_nonhdf5_file() Arguments None Contents None","tags":"","loc":"proc/test_nonhdf5_file.html"},{"title":"test_wrong_type – Object-oriented Fortran 2008 HDF5 interface","text":"subroutine test_wrong_type() Arguments None Contents None","tags":"","loc":"proc/test_wrong_type.html"},{"title":"test_is_hdf5 – Object-oriented Fortran 2008 HDF5 interface","text":"subroutine test_is_hdf5() Arguments None Contents None","tags":"","loc":"proc/test_is_hdf5.html"},{"title":"test_exist – Object-oriented Fortran 2008 HDF5 interface","text":"subroutine test_exist() Arguments None Contents None","tags":"","loc":"proc/test_exist.html"},{"title":"test_softlink – Object-oriented Fortran 2008 HDF5 interface","text":"subroutine test_softlink() test dangling link Arguments None Contents None","tags":"","loc":"proc/test_softlink.html"},{"title":"test_scratch – Object-oriented Fortran 2008 HDF5 interface","text":"subroutine test_scratch() Arguments None Contents None","tags":"","loc":"proc/test_scratch.html"},{"title":"test_multifiles – Object-oriented Fortran 2008 HDF5 interface","text":"subroutine test_multifiles() Arguments None Contents None","tags":"","loc":"proc/test_multifiles.html"},{"title":"testGroup – Object-oriented Fortran 2008 HDF5 interface","text":"subroutine testGroup() Arguments None Contents None","tags":"","loc":"proc/testgroup.html"},{"title":"test_writeExistingVariable – Object-oriented Fortran 2008 HDF5 interface","text":"subroutine test_writeExistingVariable() Arguments None Contents None","tags":"","loc":"proc/test_writeexistingvariable.html"},{"title":"set_deflate – Object-oriented Fortran 2008 HDF5 interface","text":"subroutine set_deflate(self, dims, pid, ierr, chunk_size) guess chunk size, keeping in mind 1 Megabyte recommended maximum chunk size Arguments Type Intent Optional Attributes Name class( hdf5_file ), intent(inout) :: self integer(kind=HSIZE_T), intent(in) :: dims (:) integer(kind=HID_T), intent(out) :: pid integer, intent(out) :: ierr integer, intent(in), optional :: chunk_size (:) Contents None","tags":"","loc":"proc/set_deflate.html"},{"title":"guess_chunk_size – Object-oriented Fortran 2008 HDF5 interface","text":"subroutine guess_chunk_size(dims, chunk_size) based on https://github.com/h5py/h5py/blob/master/h5py/_hl/filters.py\n refer to https://support.hdfgroup.org/HDF5/Tutor/layout.html\n Repeatedly loop over the axes, dividing them by 2.\n Stop when:\n   1a. We're smaller than the target chunk size, OR\n   1b. We're within 50% of the target chunk size, AND\n    2. The chunk is smaller than the maximum chunk size Element size larger than CHUNK_MAX Arguments Type Intent Optional Attributes Name integer(kind=HSIZE_T), intent(in) :: dims (:) integer(kind=HSIZE_T), intent(out) :: chunk_size (:) Contents None","tags":"","loc":"proc/guess_chunk_size.html"},{"title":"readattr_char – Object-oriented Fortran 2008 HDF5 interface","text":"module procedure readattr_char module subroutine readattr_char(self, dname, attr, attrval, ierr) Interface → NOTE: HDF5 character attributes are scalar. Arguments Type Intent Optional Attributes Name class( hdf5_file ), intent(in) :: self character(len=*), intent(in) :: dname character(len=*), intent(in) :: attr character(len=*), intent(inout) :: attrval intent(inout) for character integer, intent(out), optional :: ierr Contents None","tags":"","loc":"proc/readattr_char.html"},{"title":"readattr_num – Object-oriented Fortran 2008 HDF5 interface","text":"module procedure readattr_num module subroutine readattr_num(self, dname, attr, attrval, ierr) Interface → NOTE: HDF5 has 1D vector attributes for integer, float and double. Arguments Type Intent Optional Attributes Name class( hdf5_file ), intent(in) :: self character(len=*), intent(in) :: dname character(len=*), intent(in) :: attr class(*), intent(out) :: attrval (:) integer, intent(out), optional :: ierr Contents None","tags":"","loc":"proc/readattr_num.html"},{"title":"writeattr_char – Object-oriented Fortran 2008 HDF5 interface","text":"module procedure writeattr_char module subroutine writeattr_char(self, dname, attr, attrval, ierr) Interface → Arguments Type Intent Optional Attributes Name class( hdf5_file ), intent(in) :: self character(len=*), intent(in) :: dname character(len=*), intent(in) :: attr character(len=*), intent(in) :: attrval integer, intent(out), optional :: ierr Contents None","tags":"","loc":"proc/writeattr_char.html"},{"title":"writeattr_num – Object-oriented Fortran 2008 HDF5 interface","text":"module procedure writeattr_num module subroutine writeattr_num(self, dname, attr, attrval, ierr) Interface → NOTE: HDF5 has 1D vector attributes for integer, float and double. Arguments Type Intent Optional Attributes Name class( hdf5_file ), intent(in) :: self character(len=*), intent(in) :: dname character(len=*), intent(in) :: attr class(*), intent(in) :: attrval (:) integer, intent(out), optional :: ierr Contents None","tags":"","loc":"proc/writeattr_num.html"},{"title":"writeattr_char_lt – Object-oriented Fortran 2008 HDF5 interface","text":"module procedure writeattr_char_lt module subroutine writeattr_char_lt(filename, dname, attr, attrval, ierr) Interface → Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename character(len=*), intent(in) :: dname character(len=*), intent(in) :: attr character(len=*), intent(in) :: attrval integer, intent(out), optional :: ierr Contents None","tags":"","loc":"proc/writeattr_char_lt.html"},{"title":"writeattr_num_lt – Object-oriented Fortran 2008 HDF5 interface","text":"module procedure writeattr_num_lt module subroutine writeattr_num_lt(filename, dname, attr, attrval, ierr) Interface → Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename character(len=*), intent(in) :: dname character(len=*), intent(in) :: attr class(*), intent(in) :: attrval (:) integer, intent(out), optional :: ierr Contents None","tags":"","loc":"proc/writeattr_num_lt.html"},{"title":"readattr_char_lt – Object-oriented Fortran 2008 HDF5 interface","text":"module procedure readattr_char_lt module subroutine readattr_char_lt(filename, dname, attr, attrval, ierr) Interface → Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename character(len=*), intent(in) :: dname character(len=*), intent(in) :: attr character(len=*), intent(inout) :: attrval intent(inout) for character integer, intent(out), optional :: ierr Contents None","tags":"","loc":"proc/readattr_char_lt.html"},{"title":"readattr_num_lt – Object-oriented Fortran 2008 HDF5 interface","text":"module procedure readattr_num_lt module subroutine readattr_num_lt(filename, dname, attr, attrval, ierr) Interface → Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename character(len=*), intent(in) :: dname character(len=*), intent(in) :: attr class(*), intent(out) :: attrval (:) integer, intent(out), optional :: ierr Contents None","tags":"","loc":"proc/readattr_num_lt.html"},{"title":"get_tempdir – Object-oriented Fortran 2008 HDF5 interface","text":"module procedure get_tempdir module function get_tempdir() Interface → Arguments None Return Value character(len=:),\n  allocatable Contents None","tags":"","loc":"proc/get_tempdir.html"},{"title":"is_absolute_path – Object-oriented Fortran 2008 HDF5 interface","text":"module procedure is_absolute_path module function is_absolute_path(path) Interface → heuristic to determine if is absolute path Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: path Return Value logical Contents None","tags":"","loc":"proc/is_absolute_path.html"},{"title":"std_unlink – Object-oriented Fortran 2008 HDF5 interface","text":"module procedure std_unlink module function std_unlink(filename) Interface → deletes file in Fortran standard manner. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename Return Value logical Contents None","tags":"","loc":"proc/std_unlink.html"},{"title":"hdf_get_ndims – Object-oriented Fortran 2008 HDF5 interface","text":"module procedure hdf_get_ndims module function hdf_get_ndims(self, dname) result(drank) Interface → get rank or \"ndims\" Arguments Type Intent Optional Attributes Name class( hdf5_file ), intent(in) :: self character(len=*), intent(in) :: dname Return Value integer Contents None","tags":"","loc":"proc/hdf_get_ndims.html"},{"title":"hdf_get_shape – Object-oriented Fortran 2008 HDF5 interface","text":"module procedure hdf_get_shape module subroutine hdf_get_shape(self, dname, dims, ierr) Interface → must get dims before info, as \"dims\" must be allocated or segfault occurs. Arguments Type Intent Optional Attributes Name class( hdf5_file ), intent(in) :: self character(len=*), intent(in) :: dname integer(kind=HSIZE_T), intent(out), allocatable :: dims (:) integer, intent(out), optional :: ierr Contents None","tags":"","loc":"proc/hdf_get_shape.html"},{"title":"hdf_get_chunk – Object-oriented Fortran 2008 HDF5 interface","text":"module procedure hdf_get_chunk module subroutine hdf_get_chunk(self, dname, chunk_size) Interface → Arguments Type Intent Optional Attributes Name class( hdf5_file ), intent(in) :: self character(len=*), intent(in) :: dname integer(kind=hsize_t), intent(out) :: chunk_size (:) Contents None","tags":"","loc":"proc/hdf_get_chunk.html"},{"title":"hdf_get_layout – Object-oriented Fortran 2008 HDF5 interface","text":"module procedure hdf_get_layout module function hdf_get_layout(self, dname) result(layout) Interface → Arguments Type Intent Optional Attributes Name class( hdf5_file ), intent(in) :: self character(len=*), intent(in) :: dname Return Value integer Contents None","tags":"","loc":"proc/hdf_get_layout.html"},{"title":"hdf_check_exist – Object-oriented Fortran 2008 HDF5 interface","text":"module procedure hdf_check_exist module function hdf_check_exist(self, dname) result(exists) Interface → h5lexists_f can false error with groups--just use h5ltpath_valid Arguments Type Intent Optional Attributes Name class( hdf5_file ), intent(in) :: self character(len=*), intent(in) :: dname Return Value logical Contents None","tags":"","loc":"proc/hdf_check_exist.html"},{"title":"hdf_read_scalar – Object-oriented Fortran 2008 HDF5 interface","text":"module procedure hdf_read_scalar module subroutine hdf_read_scalar(self, dname, value, ierr) Interface → cast the dataset read from disk to the variable type presented by user h5f%read(\"/my_dataset\", x)\n We only cast when needed to save memory.\n select case doesn't allow H5T_* Arguments Type Intent Optional Attributes Name class( hdf5_file ), intent(in) :: self character(len=*), intent(in) :: dname class(*), intent(inout) :: value intent(inout) for character integer, intent(out), optional :: ierr Contents None","tags":"","loc":"proc/hdf_read_scalar.html"},{"title":"hdf_read_1d – Object-oriented Fortran 2008 HDF5 interface","text":"module procedure hdf_read_1d module subroutine hdf_read_1d(self, dname, value, ierr, istart, iend, stride) Interface → necessary to use this present check for Intel and GCC\n cast the dataset read from disk to the variable type presented by user h5f%read(\"/my_dataset\", x)\n We only cast when needed to save memory.\n select case doesn't allow H5T_* Arguments Type Intent Optional Attributes Name class( hdf5_file ), intent(in) :: self character(len=*), intent(in) :: dname class(*), intent(out) :: value (:) integer, intent(out), optional :: ierr integer, intent(in), optional dimension(:) :: istart integer, intent(in), optional dimension(:) :: iend integer, intent(in), optional dimension(:) :: stride Contents None","tags":"","loc":"proc/hdf_read_1d.html"},{"title":"hdf_read_2d – Object-oriented Fortran 2008 HDF5 interface","text":"module procedure hdf_read_2d module subroutine hdf_read_2d(self, dname, value, ierr, istart, iend, stride) Interface → necessary to use this present check for Intel and GCC\n cast the dataset read from disk to the variable type presented by user h5f%read(\"/my_dataset\", x)\n We only cast when needed to save memory.\n select case doesn't allow H5T_* Arguments Type Intent Optional Attributes Name class( hdf5_file ), intent(in) :: self character(len=*), intent(in) :: dname class(*), intent(out) :: value (:,:) integer, intent(out), optional :: ierr integer, intent(in), optional dimension(:) :: istart integer, intent(in), optional dimension(:) :: iend integer, intent(in), optional dimension(:) :: stride Contents None","tags":"","loc":"proc/hdf_read_2d.html"},{"title":"hdf_read_3d – Object-oriented Fortran 2008 HDF5 interface","text":"module procedure hdf_read_3d module subroutine hdf_read_3d(self, dname, value, ierr, istart, iend, stride) Interface → necessary to use this present check for Intel and GCC\n cast the dataset read from disk to the variable type presented by user h5f%read(\"/my_dataset\", x)\n We only cast when needed to save memory.\n select case doesn't allow H5T_* Arguments Type Intent Optional Attributes Name class( hdf5_file ), intent(in) :: self character(len=*), intent(in) :: dname class(*), intent(out) :: value (:,:,:) integer, intent(out), optional :: ierr integer, intent(in), optional dimension(:) :: istart integer, intent(in), optional dimension(:) :: iend integer, intent(in), optional dimension(:) :: stride Contents None","tags":"","loc":"proc/hdf_read_3d.html"},{"title":"hdf_read_4d – Object-oriented Fortran 2008 HDF5 interface","text":"module procedure hdf_read_4d module subroutine hdf_read_4d(self, dname, value, ierr, istart, iend, stride) Interface → necessary to use this present check for Intel and GCC\n cast the dataset read from disk to the variable type presented by user h5f%read(\"/my_dataset\", x)\n We only cast when needed to save memory.\n select case doesn't allow H5T_* Arguments Type Intent Optional Attributes Name class( hdf5_file ), intent(in) :: self character(len=*), intent(in) :: dname class(*), intent(out) :: value (:,:,:,:) integer, intent(out), optional :: ierr integer, intent(in), optional dimension(:) :: istart integer, intent(in), optional dimension(:) :: iend integer, intent(in), optional dimension(:) :: stride Contents None","tags":"","loc":"proc/hdf_read_4d.html"},{"title":"hdf_read_5d – Object-oriented Fortran 2008 HDF5 interface","text":"module procedure hdf_read_5d module subroutine hdf_read_5d(self, dname, value, ierr, istart, iend, stride) Interface → necessary to use this present check for Intel and GCC\n cast the dataset read from disk to the variable type presented by user h5f%read(\"/my_dataset\", x)\n We only cast when needed to save memory.\n select case doesn't allow H5T_* Arguments Type Intent Optional Attributes Name class( hdf5_file ), intent(in) :: self character(len=*), intent(in) :: dname class(*), intent(out) :: value (:,:,:,:,:) integer, intent(out), optional :: ierr integer, intent(in), optional dimension(:) :: istart integer, intent(in), optional dimension(:) :: iend integer, intent(in), optional dimension(:) :: stride Contents None","tags":"","loc":"proc/hdf_read_5d.html"},{"title":"hdf_read_6d – Object-oriented Fortran 2008 HDF5 interface","text":"module procedure hdf_read_6d module subroutine hdf_read_6d(self, dname, value, ierr, istart, iend, stride) Interface → necessary to use this present check for Intel and GCC\n cast the dataset read from disk to the variable type presented by user h5f%read(\"/my_dataset\", x)\n We only cast when needed to save memory.\n select case doesn't allow H5T_* Arguments Type Intent Optional Attributes Name class( hdf5_file ), intent(in) :: self character(len=*), intent(in) :: dname class(*), intent(out) :: value (:,:,:,:,:,:) integer, intent(out), optional :: ierr integer, intent(in), optional dimension(:) :: istart integer, intent(in), optional dimension(:) :: iend integer, intent(in), optional dimension(:) :: stride Contents None","tags":"","loc":"proc/hdf_read_6d.html"},{"title":"hdf_read_7d – Object-oriented Fortran 2008 HDF5 interface","text":"module procedure hdf_read_7d module subroutine hdf_read_7d(self, dname, value, ierr, istart, iend, stride) Interface → necessary to use this present check for Intel and GCC\n cast the dataset read from disk to the variable type presented by user h5f%read(\"/my_dataset\", x)\n We only cast when needed to save memory.\n select case doesn't allow H5T_* Arguments Type Intent Optional Attributes Name class( hdf5_file ), intent(in) :: self character(len=*), intent(in) :: dname class(*), intent(out) :: value (:,:,:,:,:,:,:) integer, intent(out), optional :: ierr integer, intent(in), optional dimension(:) :: istart integer, intent(in), optional dimension(:) :: iend integer, intent(in), optional dimension(:) :: stride Contents None","tags":"","loc":"proc/hdf_read_7d.html"},{"title":"h5exist – Object-oriented Fortran 2008 HDF5 interface","text":"module procedure h5exist module function h5exist(filename, dname) Interface → Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename character(len=*), intent(in) :: dname Return Value logical Contents None","tags":"","loc":"proc/h5exist.html"},{"title":"lt0read – Object-oriented Fortran 2008 HDF5 interface","text":"module procedure lt0read module subroutine lt0read(filename, dname, value, ierr) Interface → Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename character(len=*), intent(in) :: dname class(*), intent(out) :: value integer, intent(out), optional :: ierr Contents None","tags":"","loc":"proc/lt0read.html"},{"title":"lt1read – Object-oriented Fortran 2008 HDF5 interface","text":"module procedure lt1read module subroutine lt1read(filename, dname, value, ierr) Interface → Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename character(len=*), intent(in) :: dname class(*), intent(out) :: value (:) integer, intent(out), optional :: ierr Contents None","tags":"","loc":"proc/lt1read.html"},{"title":"lt2read – Object-oriented Fortran 2008 HDF5 interface","text":"module procedure lt2read module subroutine lt2read(filename, dname, value, ierr) Interface → Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename character(len=*), intent(in) :: dname class(*), intent(out) :: value (:,:) integer, intent(out), optional :: ierr Contents None","tags":"","loc":"proc/lt2read.html"},{"title":"lt3read – Object-oriented Fortran 2008 HDF5 interface","text":"module procedure lt3read module subroutine lt3read(filename, dname, value, ierr) Interface → Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename character(len=*), intent(in) :: dname class(*), intent(out) :: value (:,:,:) integer, intent(out), optional :: ierr Contents None","tags":"","loc":"proc/lt3read.html"},{"title":"lt4read – Object-oriented Fortran 2008 HDF5 interface","text":"module procedure lt4read module subroutine lt4read(filename, dname, value, ierr) Interface → Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename character(len=*), intent(in) :: dname class(*), intent(out) :: value (:,:,:,:) integer, intent(out), optional :: ierr Contents None","tags":"","loc":"proc/lt4read.html"},{"title":"lt5read – Object-oriented Fortran 2008 HDF5 interface","text":"module procedure lt5read module subroutine lt5read(filename, dname, value, ierr) Interface → Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename character(len=*), intent(in) :: dname class(*), intent(out) :: value (:,:,:,:,:) integer, intent(out), optional :: ierr Contents None","tags":"","loc":"proc/lt5read.html"},{"title":"lt6read – Object-oriented Fortran 2008 HDF5 interface","text":"module procedure lt6read module subroutine lt6read(filename, dname, value, ierr) Interface → Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename character(len=*), intent(in) :: dname class(*), intent(out) :: value (:,:,:,:,:,:) integer, intent(out), optional :: ierr Contents None","tags":"","loc":"proc/lt6read.html"},{"title":"lt7read – Object-oriented Fortran 2008 HDF5 interface","text":"module procedure lt7read module subroutine lt7read(filename, dname, value, ierr) Interface → Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename character(len=*), intent(in) :: dname class(*), intent(out) :: value (:,:,:,:,:,:,:) integer, intent(out), optional :: ierr Contents None","tags":"","loc":"proc/lt7read.html"},{"title":"hdf_read_8d – Object-oriented Fortran 2008 HDF5 interface","text":"module procedure hdf_read_8d module procedure hdf_read_8d() Arguments None Contents None","tags":"","loc":"proc/hdf_read_8d.html"},{"title":"hdf_create – Object-oriented Fortran 2008 HDF5 interface","text":"module procedure hdf_create module subroutine hdf_create(self, dname, dtype, dims, sid, did, chunk_size, istart, iend, stride, compact) Interface → h5lexists_f can false error with groups--just use h5ltpath_valid stricter than self%exists() since we're creating and/or writing variable\n allow user to specify int4 or int8 dims\n FIXME: read and write slice shape not checked; but should check in future versions\n open dataset\n Only new datasets go past this point\n create properties don't set COMPACT after CHUNKED, will fail. And it's either or anyway.\n 64000 byte limit, here we assumed 8 bytes / element\n create dataspace\n create dataset Arguments Type Intent Optional Attributes Name class( hdf5_file ), intent(inout) :: self character(len=*), intent(in) :: dname integer(kind=HID_T), intent(in) :: dtype class(*), intent(in) :: dims (:) integer(kind=HID_T), intent(out), optional :: sid integer(kind=HID_T), intent(out), optional :: did integer, intent(in), optional :: chunk_size (:) integer, intent(in), optional :: istart (:) integer, intent(in), optional :: iend (:) integer, intent(in), optional :: stride (:) logical, intent(in), optional :: compact keep istart, iend, stride for future slice shape check Contents None","tags":"","loc":"proc/hdf_create.html"},{"title":"create_softlink – Object-oriented Fortran 2008 HDF5 interface","text":"module procedure create_softlink module subroutine create_softlink(self, target, link) Interface → HDF5 soft link -- to variables in same file\n target need not exist (dangling link)\n linking to external files requires an external link (different function required) Arguments Type Intent Optional Attributes Name class( hdf5_file ), intent(inout) :: self character(len=*), intent(in) :: target character(len=*), intent(in) :: link Contents None","tags":"","loc":"proc/create_softlink.html"},{"title":"hdf_open_group – Object-oriented Fortran 2008 HDF5 interface","text":"module procedure hdf_open_group module subroutine hdf_open_group(self, gname, ierr) Interface → Arguments Type Intent Optional Attributes Name class( hdf5_file ), intent(inout) :: self character(len=*), intent(in) :: gname integer, intent(out), optional :: ierr Contents None","tags":"","loc":"proc/hdf_open_group.html"},{"title":"hdf_close_group – Object-oriented Fortran 2008 HDF5 interface","text":"module procedure hdf_close_group module subroutine hdf_close_group(self, ierr) Interface → Arguments Type Intent Optional Attributes Name class( hdf5_file ), intent(inout) :: self integer, intent(out), optional :: ierr Contents None","tags":"","loc":"proc/hdf_close_group.html"},{"title":"hdf_write_scalar – Object-oriented Fortran 2008 HDF5 interface","text":"module procedure hdf_write_scalar module subroutine hdf_write_scalar(self, dname, value, ierr, compact) Interface → sentinel NOTE: 0d does not use chunk_size Arguments Type Intent Optional Attributes Name class( hdf5_file ), intent(inout) :: self character(len=*), intent(in) :: dname class(*), intent(in) :: value integer, intent(out), optional :: ierr logical, intent(in), optional :: compact Contents None","tags":"","loc":"proc/hdf_write_scalar.html"},{"title":"hdf_write_1d – Object-oriented Fortran 2008 HDF5 interface","text":"module procedure hdf_write_1d module subroutine hdf_write_1d(self, dname, value, ierr, chunk_size, istart, iend, stride, compact) Interface → Arguments Type Intent Optional Attributes Name class( hdf5_file ), intent(inout) :: self character(len=*), intent(in) :: dname class(*), intent(in) :: value (:) integer, intent(out), optional :: ierr integer, intent(in), optional :: chunk_size (1) integer, intent(in), optional dimension(:) :: istart integer, intent(in), optional dimension(:) :: iend integer, intent(in), optional dimension(:) :: stride logical, intent(in), optional :: compact Contents None","tags":"","loc":"proc/hdf_write_1d.html"},{"title":"hdf_write_2d – Object-oriented Fortran 2008 HDF5 interface","text":"module procedure hdf_write_2d module subroutine hdf_write_2d(self, dname, value, ierr, chunk_size, istart, iend, stride, compact) Interface → Arguments Type Intent Optional Attributes Name class( hdf5_file ), intent(inout) :: self character(len=*), intent(in) :: dname class(*), intent(in) :: value (:,:) integer, intent(out), optional :: ierr integer, intent(in), optional :: chunk_size (2) integer, intent(in), optional dimension(:) :: istart integer, intent(in), optional dimension(:) :: iend integer, intent(in), optional dimension(:) :: stride logical, intent(in), optional :: compact Contents None","tags":"","loc":"proc/hdf_write_2d.html"},{"title":"hdf_write_3d – Object-oriented Fortran 2008 HDF5 interface","text":"module procedure hdf_write_3d module subroutine hdf_write_3d(self, dname, value, ierr, chunk_size, istart, iend, stride, compact) Interface → Arguments Type Intent Optional Attributes Name class( hdf5_file ), intent(inout) :: self character(len=*), intent(in) :: dname class(*), intent(in) :: value (:,:,:) integer, intent(out), optional :: ierr integer, intent(in), optional :: chunk_size (3) integer, intent(in), optional dimension(:) :: istart integer, intent(in), optional dimension(:) :: iend integer, intent(in), optional dimension(:) :: stride logical, intent(in), optional :: compact Contents None","tags":"","loc":"proc/hdf_write_3d.html"},{"title":"hdf_write_4d – Object-oriented Fortran 2008 HDF5 interface","text":"module procedure hdf_write_4d module subroutine hdf_write_4d(self, dname, value, ierr, chunk_size, istart, iend, stride, compact) Interface → Arguments Type Intent Optional Attributes Name class( hdf5_file ), intent(inout) :: self character(len=*), intent(in) :: dname class(*), intent(in) :: value (:,:,:,:) integer, intent(out), optional :: ierr integer, intent(in), optional :: chunk_size (4) integer, intent(in), optional dimension(:) :: istart integer, intent(in), optional dimension(:) :: iend integer, intent(in), optional dimension(:) :: stride logical, intent(in), optional :: compact Contents None","tags":"","loc":"proc/hdf_write_4d.html"},{"title":"hdf_write_5d – Object-oriented Fortran 2008 HDF5 interface","text":"module procedure hdf_write_5d module subroutine hdf_write_5d(self, dname, value, ierr, chunk_size, istart, iend, stride, compact) Interface → Arguments Type Intent Optional Attributes Name class( hdf5_file ), intent(inout) :: self character(len=*), intent(in) :: dname class(*), intent(in) :: value (:,:,:,:,:) integer, intent(out), optional :: ierr integer, intent(in), optional :: chunk_size (5) integer, intent(in), optional dimension(:) :: istart integer, intent(in), optional dimension(:) :: iend integer, intent(in), optional dimension(:) :: stride logical, intent(in), optional :: compact Contents None","tags":"","loc":"proc/hdf_write_5d.html"},{"title":"hdf_write_6d – Object-oriented Fortran 2008 HDF5 interface","text":"module procedure hdf_write_6d module subroutine hdf_write_6d(self, dname, value, ierr, chunk_size, istart, iend, stride, compact) Interface → Arguments Type Intent Optional Attributes Name class( hdf5_file ), intent(inout) :: self character(len=*), intent(in) :: dname class(*), intent(in) :: value (:,:,:,:,:,:) integer, intent(out), optional :: ierr integer, intent(in), optional :: chunk_size (6) integer, intent(in), optional dimension(:) :: istart integer, intent(in), optional dimension(:) :: iend integer, intent(in), optional dimension(:) :: stride logical, intent(in), optional :: compact Contents None","tags":"","loc":"proc/hdf_write_6d.html"},{"title":"hdf_write_7d – Object-oriented Fortran 2008 HDF5 interface","text":"module procedure hdf_write_7d module subroutine hdf_write_7d(self, dname, value, ierr, chunk_size, istart, iend, stride, compact) Interface → Arguments Type Intent Optional Attributes Name class( hdf5_file ), intent(inout) :: self character(len=*), intent(in) :: dname class(*), intent(in) :: value (:,:,:,:,:,:,:) integer, intent(out), optional :: ierr integer, intent(in), optional :: chunk_size (7) integer, intent(in), optional dimension(:) :: istart integer, intent(in), optional dimension(:) :: iend integer, intent(in), optional dimension(:) :: stride logical, intent(in), optional :: compact Contents None","tags":"","loc":"proc/hdf_write_7d.html"},{"title":"lt0write – Object-oriented Fortran 2008 HDF5 interface","text":"module procedure lt0write module subroutine lt0write(filename, dname, value, ierr) Interface → Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename character(len=*), intent(in) :: dname class(*), intent(in) :: value integer, intent(out), optional :: ierr Contents None","tags":"","loc":"proc/lt0write.html"},{"title":"lt1write – Object-oriented Fortran 2008 HDF5 interface","text":"module procedure lt1write module subroutine lt1write(filename, dname, value, ierr) Interface → Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename character(len=*), intent(in) :: dname class(*), intent(in) :: value (:) integer, intent(out), optional :: ierr Contents None","tags":"","loc":"proc/lt1write.html"},{"title":"lt2write – Object-oriented Fortran 2008 HDF5 interface","text":"module procedure lt2write module subroutine lt2write(filename, dname, value, ierr) Interface → Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename character(len=*), intent(in) :: dname class(*), intent(in) :: value (:,:) integer, intent(out), optional :: ierr Contents None","tags":"","loc":"proc/lt2write.html"},{"title":"lt3write – Object-oriented Fortran 2008 HDF5 interface","text":"module procedure lt3write module subroutine lt3write(filename, dname, value, ierr) Interface → Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename character(len=*), intent(in) :: dname class(*), intent(in) :: value (:,:,:) integer, intent(out), optional :: ierr Contents None","tags":"","loc":"proc/lt3write.html"},{"title":"lt4write – Object-oriented Fortran 2008 HDF5 interface","text":"module procedure lt4write module subroutine lt4write(filename, dname, value, ierr) Interface → Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename character(len=*), intent(in) :: dname class(*), intent(in) :: value (:,:,:,:) integer, intent(out), optional :: ierr Contents None","tags":"","loc":"proc/lt4write.html"},{"title":"lt5write – Object-oriented Fortran 2008 HDF5 interface","text":"module procedure lt5write module subroutine lt5write(filename, dname, value, ierr) Interface → Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename character(len=*), intent(in) :: dname class(*), intent(in) :: value (:,:,:,:,:) integer, intent(out), optional :: ierr Contents None","tags":"","loc":"proc/lt5write.html"},{"title":"lt6write – Object-oriented Fortran 2008 HDF5 interface","text":"module procedure lt6write module subroutine lt6write(filename, dname, value, ierr) Interface → Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename character(len=*), intent(in) :: dname class(*), intent(in) :: value (:,:,:,:,:,:) integer, intent(out), optional :: ierr Contents None","tags":"","loc":"proc/lt6write.html"},{"title":"lt7write – Object-oriented Fortran 2008 HDF5 interface","text":"module procedure lt7write module subroutine lt7write(filename, dname, value, ierr) Interface → Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename character(len=*), intent(in) :: dname class(*), intent(in) :: value (:,:,:,:,:,:,:) integer, intent(out), optional :: ierr Contents None","tags":"","loc":"proc/lt7write.html"},{"title":"hdf_write_8d – Object-oriented Fortran 2008 HDF5 interface","text":"module procedure hdf_write_8d module procedure hdf_write_8d() Arguments None Contents None","tags":"","loc":"proc/hdf_write_8d.html"},{"title":"h5fortran – Object-oriented Fortran 2008 HDF5 interface","text":"HDF5 object-oriented polymorphic interface Uses iso_c_binding iso_fortran_env hdf5 h5lt Used by Descendants: attributes pathlib read write Contents Interfaces h5write h5read h5write_attr h5read_attr std_unlink is_absolute_path get_tempdir hdf_create hdf_open_group hdf_close_group create_softlink h5exist lt0write lt1write lt2write lt3write lt4write lt5write lt6write lt7write lt0read lt1read lt2read lt3read lt4read lt5read lt6read lt7read hdf_write_scalar hdf_write_1d hdf_write_2d hdf_write_3d hdf_write_4d hdf_write_5d hdf_write_6d hdf_write_7d hdf_get_ndims hdf_get_layout hdf_check_exist hdf_get_shape hdf_get_chunk hdf_read_scalar hdf_read_1d hdf_read_2d hdf_read_3d hdf_read_4d hdf_read_5d hdf_read_6d hdf_read_7d readattr_char readattr_num writeattr_char writeattr_num writeattr_char_lt writeattr_num_lt readattr_char_lt readattr_num_lt Derived Types hdf5_file Functions hdf_is_contig hdf_is_compact hdf_is_chunked is_hdf5 check Subroutines hdf_initialize hdf_finalize hdf_flush hdf5_close write_group hdf_wrapup hdf_get_slice hdf_shape_check Interfaces public interface h5write private interface lt0write () Arguments None private interface lt1write () Arguments None private interface lt2write () Arguments None private interface lt3write () Arguments None private interface lt4write () Arguments None private interface lt5write () Arguments None private interface lt6write () Arguments None private interface lt7write () Arguments None public interface h5read private interface lt0read () Arguments None private interface lt1read () Arguments None private interface lt2read () Arguments None private interface lt3read () Arguments None private interface lt4read () Arguments None private interface lt5read () Arguments None private interface lt6read () Arguments None private interface lt7read () Arguments None public interface h5write_attr private interface writeattr_num_lt () Arguments None private interface writeattr_char_lt () Arguments None public interface h5read_attr private interface readattr_num_lt () Arguments None private interface readattr_char_lt () Arguments None interface Submodules private module function std_unlink(filename) Implementation → Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename Return Value logical interface Submodules private module function is_absolute_path(path) Implementation → Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: path Return Value logical interface Submodules private module function get_tempdir() Implementation → Arguments None Return Value character(len=:),\n  allocatable interface private module subroutine hdf_create(self, dname, dtype, dims, sid, did, chunk_size, istart, iend, stride, compact) Implementation → Arguments Type Intent Optional Attributes Name class( hdf5_file ), intent(inout) :: self character(len=*), intent(in) :: dname integer(kind=HID_T), intent(in) :: dtype class(*), intent(in) :: dims (:) integer(kind=HID_T), intent(out), optional :: sid integer(kind=HID_T), intent(out), optional :: did integer, intent(in), optional :: chunk_size (:) integer, intent(in), optional :: istart (:) integer, intent(in), optional :: iend (:) integer, intent(in), optional :: stride (:) logical, intent(in), optional :: compact keep istart, iend, stride for future slice shape check interface private module subroutine hdf_open_group(self, gname, ierr) Implementation → Arguments Type Intent Optional Attributes Name class( hdf5_file ), intent(inout) :: self character(len=*), intent(in) :: gname integer, intent(out), optional :: ierr interface private module subroutine hdf_close_group(self, ierr) Implementation → Arguments Type Intent Optional Attributes Name class( hdf5_file ), intent(inout) :: self integer, intent(out), optional :: ierr interface private module subroutine create_softlink(self, target, link) Implementation → Arguments Type Intent Optional Attributes Name class( hdf5_file ), intent(inout) :: self character(len=*), intent(in) :: target character(len=*), intent(in) :: link interface public module function h5exist(filename, dname) Implementation → Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename character(len=*), intent(in) :: dname Return Value logical interface private module subroutine lt0write(filename, dname, value, ierr) Implementation → Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename character(len=*), intent(in) :: dname class(*), intent(in) :: value integer, intent(out), optional :: ierr interface private module subroutine lt1write(filename, dname, value, ierr) Implementation → Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename character(len=*), intent(in) :: dname class(*), intent(in) :: value (:) integer, intent(out), optional :: ierr interface private module subroutine lt2write(filename, dname, value, ierr) Implementation → Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename character(len=*), intent(in) :: dname class(*), intent(in) :: value (:,:) integer, intent(out), optional :: ierr interface private module subroutine lt3write(filename, dname, value, ierr) Implementation → Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename character(len=*), intent(in) :: dname class(*), intent(in) :: value (:,:,:) integer, intent(out), optional :: ierr interface private module subroutine lt4write(filename, dname, value, ierr) Implementation → Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename character(len=*), intent(in) :: dname class(*), intent(in) :: value (:,:,:,:) integer, intent(out), optional :: ierr interface private module subroutine lt5write(filename, dname, value, ierr) Implementation → Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename character(len=*), intent(in) :: dname class(*), intent(in) :: value (:,:,:,:,:) integer, intent(out), optional :: ierr interface private module subroutine lt6write(filename, dname, value, ierr) Implementation → Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename character(len=*), intent(in) :: dname class(*), intent(in) :: value (:,:,:,:,:,:) integer, intent(out), optional :: ierr interface private module subroutine lt7write(filename, dname, value, ierr) Implementation → Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename character(len=*), intent(in) :: dname class(*), intent(in) :: value (:,:,:,:,:,:,:) integer, intent(out), optional :: ierr interface private module subroutine lt0read(filename, dname, value, ierr) Implementation → Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename character(len=*), intent(in) :: dname class(*), intent(out) :: value integer, intent(out), optional :: ierr interface private module subroutine lt1read(filename, dname, value, ierr) Implementation → Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename character(len=*), intent(in) :: dname class(*), intent(out) :: value (:) integer, intent(out), optional :: ierr interface private module subroutine lt2read(filename, dname, value, ierr) Implementation → Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename character(len=*), intent(in) :: dname class(*), intent(out) :: value (:,:) integer, intent(out), optional :: ierr interface private module subroutine lt3read(filename, dname, value, ierr) Implementation → Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename character(len=*), intent(in) :: dname class(*), intent(out) :: value (:,:,:) integer, intent(out), optional :: ierr interface private module subroutine lt4read(filename, dname, value, ierr) Implementation → Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename character(len=*), intent(in) :: dname class(*), intent(out) :: value (:,:,:,:) integer, intent(out), optional :: ierr interface private module subroutine lt5read(filename, dname, value, ierr) Implementation → Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename character(len=*), intent(in) :: dname class(*), intent(out) :: value (:,:,:,:,:) integer, intent(out), optional :: ierr interface private module subroutine lt6read(filename, dname, value, ierr) Implementation → Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename character(len=*), intent(in) :: dname class(*), intent(out) :: value (:,:,:,:,:,:) integer, intent(out), optional :: ierr interface private module subroutine lt7read(filename, dname, value, ierr) Implementation → Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename character(len=*), intent(in) :: dname class(*), intent(out) :: value (:,:,:,:,:,:,:) integer, intent(out), optional :: ierr interface private module subroutine hdf_write_scalar(self, dname, value, ierr, compact) Implementation → Arguments Type Intent Optional Attributes Name class( hdf5_file ), intent(inout) :: self character(len=*), intent(in) :: dname class(*), intent(in) :: value integer, intent(out), optional :: ierr logical, intent(in), optional :: compact interface private module subroutine hdf_write_1d(self, dname, value, ierr, chunk_size, istart, iend, stride, compact) Implementation → Arguments Type Intent Optional Attributes Name class( hdf5_file ), intent(inout) :: self character(len=*), intent(in) :: dname class(*), intent(in) :: value (:) integer, intent(out), optional :: ierr integer, intent(in), optional :: chunk_size (1) integer, intent(in), optional dimension(:) :: istart integer, intent(in), optional dimension(:) :: iend integer, intent(in), optional dimension(:) :: stride logical, intent(in), optional :: compact interface private module subroutine hdf_write_2d(self, dname, value, ierr, chunk_size, istart, iend, stride, compact) Implementation → Arguments Type Intent Optional Attributes Name class( hdf5_file ), intent(inout) :: self character(len=*), intent(in) :: dname class(*), intent(in) :: value (:,:) integer, intent(out), optional :: ierr integer, intent(in), optional :: chunk_size (2) integer, intent(in), optional dimension(:) :: istart integer, intent(in), optional dimension(:) :: iend integer, intent(in), optional dimension(:) :: stride logical, intent(in), optional :: compact interface private module subroutine hdf_write_3d(self, dname, value, ierr, chunk_size, istart, iend, stride, compact) Implementation → Arguments Type Intent Optional Attributes Name class( hdf5_file ), intent(inout) :: self character(len=*), intent(in) :: dname class(*), intent(in) :: value (:,:,:) integer, intent(out), optional :: ierr integer, intent(in), optional :: chunk_size (3) integer, intent(in), optional dimension(:) :: istart integer, intent(in), optional dimension(:) :: iend integer, intent(in), optional dimension(:) :: stride logical, intent(in), optional :: compact interface private module subroutine hdf_write_4d(self, dname, value, ierr, chunk_size, istart, iend, stride, compact) Implementation → Arguments Type Intent Optional Attributes Name class( hdf5_file ), intent(inout) :: self character(len=*), intent(in) :: dname class(*), intent(in) :: value (:,:,:,:) integer, intent(out), optional :: ierr integer, intent(in), optional :: chunk_size (4) integer, intent(in), optional dimension(:) :: istart integer, intent(in), optional dimension(:) :: iend integer, intent(in), optional dimension(:) :: stride logical, intent(in), optional :: compact interface private module subroutine hdf_write_5d(self, dname, value, ierr, chunk_size, istart, iend, stride, compact) Implementation → Arguments Type Intent Optional Attributes Name class( hdf5_file ), intent(inout) :: self character(len=*), intent(in) :: dname class(*), intent(in) :: value (:,:,:,:,:) integer, intent(out), optional :: ierr integer, intent(in), optional :: chunk_size (5) integer, intent(in), optional dimension(:) :: istart integer, intent(in), optional dimension(:) :: iend integer, intent(in), optional dimension(:) :: stride logical, intent(in), optional :: compact interface private module subroutine hdf_write_6d(self, dname, value, ierr, chunk_size, istart, iend, stride, compact) Implementation → Arguments Type Intent Optional Attributes Name class( hdf5_file ), intent(inout) :: self character(len=*), intent(in) :: dname class(*), intent(in) :: value (:,:,:,:,:,:) integer, intent(out), optional :: ierr integer, intent(in), optional :: chunk_size (6) integer, intent(in), optional dimension(:) :: istart integer, intent(in), optional dimension(:) :: iend integer, intent(in), optional dimension(:) :: stride logical, intent(in), optional :: compact interface private module subroutine hdf_write_7d(self, dname, value, ierr, chunk_size, istart, iend, stride, compact) Implementation → Arguments Type Intent Optional Attributes Name class( hdf5_file ), intent(inout) :: self character(len=*), intent(in) :: dname class(*), intent(in) :: value (:,:,:,:,:,:,:) integer, intent(out), optional :: ierr integer, intent(in), optional :: chunk_size (7) integer, intent(in), optional dimension(:) :: istart integer, intent(in), optional dimension(:) :: iend integer, intent(in), optional dimension(:) :: stride logical, intent(in), optional :: compact interface private module function hdf_get_ndims(self, dname) result(drank) Implementation → Arguments Type Intent Optional Attributes Name class( hdf5_file ), intent(in) :: self character(len=*), intent(in) :: dname Return Value integer interface private module function hdf_get_layout(self, dname) result(layout) Implementation → H5D_CONTIGUOUS_F, H5D_CHUNKED_F, H5D_VIRTUAL_F, H5D_COMPACT_F Arguments Type Intent Optional Attributes Name class( hdf5_file ), intent(in) :: self character(len=*), intent(in) :: dname Return Value integer interface private module function hdf_check_exist(self, dname) result(exists) Implementation → Arguments Type Intent Optional Attributes Name class( hdf5_file ), intent(in) :: self character(len=*), intent(in) :: dname Return Value logical interface private module subroutine hdf_get_shape(self, dname, dims, ierr) Implementation → Arguments Type Intent Optional Attributes Name class( hdf5_file ), intent(in) :: self character(len=*), intent(in) :: dname integer(kind=HSIZE_T), intent(out), allocatable :: dims (:) integer, intent(out), optional :: ierr interface private module subroutine hdf_get_chunk(self, dname, chunk_size) Implementation → Arguments Type Intent Optional Attributes Name class( hdf5_file ), intent(in) :: self character(len=*), intent(in) :: dname integer(kind=hsize_t), intent(out) :: chunk_size (:) interface private module subroutine hdf_read_scalar(self, dname, value, ierr) Implementation → Arguments Type Intent Optional Attributes Name class( hdf5_file ), intent(in) :: self character(len=*), intent(in) :: dname class(*), intent(inout) :: value intent(inout) for character integer, intent(out), optional :: ierr interface private module subroutine hdf_read_1d(self, dname, value, ierr, istart, iend, stride) Implementation → Arguments Type Intent Optional Attributes Name class( hdf5_file ), intent(in) :: self character(len=*), intent(in) :: dname class(*), intent(out) :: value (:) integer, intent(out), optional :: ierr integer, intent(in), optional dimension(:) :: istart integer, intent(in), optional dimension(:) :: iend integer, intent(in), optional dimension(:) :: stride interface private module subroutine hdf_read_2d(self, dname, value, ierr, istart, iend, stride) Implementation → Arguments Type Intent Optional Attributes Name class( hdf5_file ), intent(in) :: self character(len=*), intent(in) :: dname class(*), intent(out) :: value (:,:) integer, intent(out), optional :: ierr integer, intent(in), optional dimension(:) :: istart integer, intent(in), optional dimension(:) :: iend integer, intent(in), optional dimension(:) :: stride interface private module subroutine hdf_read_3d(self, dname, value, ierr, istart, iend, stride) Implementation → Arguments Type Intent Optional Attributes Name class( hdf5_file ), intent(in) :: self character(len=*), intent(in) :: dname class(*), intent(out) :: value (:,:,:) integer, intent(out), optional :: ierr integer, intent(in), optional dimension(:) :: istart integer, intent(in), optional dimension(:) :: iend integer, intent(in), optional dimension(:) :: stride interface private module subroutine hdf_read_4d(self, dname, value, ierr, istart, iend, stride) Implementation → Arguments Type Intent Optional Attributes Name class( hdf5_file ), intent(in) :: self character(len=*), intent(in) :: dname class(*), intent(out) :: value (:,:,:,:) integer, intent(out), optional :: ierr integer, intent(in), optional dimension(:) :: istart integer, intent(in), optional dimension(:) :: iend integer, intent(in), optional dimension(:) :: stride interface private module subroutine hdf_read_5d(self, dname, value, ierr, istart, iend, stride) Implementation → Arguments Type Intent Optional Attributes Name class( hdf5_file ), intent(in) :: self character(len=*), intent(in) :: dname class(*), intent(out) :: value (:,:,:,:,:) integer, intent(out), optional :: ierr integer, intent(in), optional dimension(:) :: istart integer, intent(in), optional dimension(:) :: iend integer, intent(in), optional dimension(:) :: stride interface private module subroutine hdf_read_6d(self, dname, value, ierr, istart, iend, stride) Implementation → Arguments Type Intent Optional Attributes Name class( hdf5_file ), intent(in) :: self character(len=*), intent(in) :: dname class(*), intent(out) :: value (:,:,:,:,:,:) integer, intent(out), optional :: ierr integer, intent(in), optional dimension(:) :: istart integer, intent(in), optional dimension(:) :: iend integer, intent(in), optional dimension(:) :: stride interface private module subroutine hdf_read_7d(self, dname, value, ierr, istart, iend, stride) Implementation → Arguments Type Intent Optional Attributes Name class( hdf5_file ), intent(in) :: self character(len=*), intent(in) :: dname class(*), intent(out) :: value (:,:,:,:,:,:,:) integer, intent(out), optional :: ierr integer, intent(in), optional dimension(:) :: istart integer, intent(in), optional dimension(:) :: iend integer, intent(in), optional dimension(:) :: stride interface private module subroutine readattr_char(self, dname, attr, attrval, ierr) Implementation → Arguments Type Intent Optional Attributes Name class( hdf5_file ), intent(in) :: self character(len=*), intent(in) :: dname character(len=*), intent(in) :: attr character(len=*), intent(inout) :: attrval intent(inout) for character integer, intent(out), optional :: ierr interface private module subroutine readattr_num(self, dname, attr, attrval, ierr) Implementation → Arguments Type Intent Optional Attributes Name class( hdf5_file ), intent(in) :: self character(len=*), intent(in) :: dname character(len=*), intent(in) :: attr class(*), intent(out) :: attrval (:) integer, intent(out), optional :: ierr interface private module subroutine writeattr_char(self, dname, attr, attrval, ierr) Implementation → Arguments Type Intent Optional Attributes Name class( hdf5_file ), intent(in) :: self character(len=*), intent(in) :: dname character(len=*), intent(in) :: attr character(len=*), intent(in) :: attrval integer, intent(out), optional :: ierr interface private module subroutine writeattr_num(self, dname, attr, attrval, ierr) Implementation → Arguments Type Intent Optional Attributes Name class( hdf5_file ), intent(in) :: self character(len=*), intent(in) :: dname character(len=*), intent(in) :: attr class(*), intent(in) :: attrval (:) integer, intent(out), optional :: ierr interface private module subroutine writeattr_char_lt(filename, dname, attr, attrval, ierr) Implementation → Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename character(len=*), intent(in) :: dname character(len=*), intent(in) :: attr character(len=*), intent(in) :: attrval integer, intent(out), optional :: ierr interface private module subroutine writeattr_num_lt(filename, dname, attr, attrval, ierr) Implementation → Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename character(len=*), intent(in) :: dname character(len=*), intent(in) :: attr class(*), intent(in) :: attrval (:) integer, intent(out), optional :: ierr interface private module subroutine readattr_char_lt(filename, dname, attr, attrval, ierr) Implementation → Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename character(len=*), intent(in) :: dname character(len=*), intent(in) :: attr character(len=*), intent(inout) :: attrval intent(inout) for character integer, intent(out), optional :: ierr interface private module subroutine readattr_num_lt(filename, dname, attr, attrval, ierr) Implementation → Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename character(len=*), intent(in) :: dname character(len=*), intent(in) :: attr class(*), intent(out) :: attrval (:) integer, intent(out), optional :: ierr Derived Types type, public :: hdf5_file main type Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: filename integer(kind=HID_T), public :: lid = 0 integer(kind=HID_T), public :: gid integer(kind=HID_T), public :: glid integer, public :: comp_lvl = 0 logical, public :: verbose = .true. logical, public :: debug = .false. logical, public :: is_open = .false. logical, public :: is_scratch = .false. will be auto-deleted on close integer, public :: libversion (3) Type-Bound Procedures procedure, public :: softlink => create_softlink define methods (procedures) that don't need generic procedure procedure, public :: is_compact => hdf_is_compact procedure, public :: is_chunked => hdf_is_chunked procedure, public :: is_contig => hdf_is_contig procedure, public :: exists => hdf_check_exist procedure, public :: exist => hdf_check_exist procedure, public :: chunks => hdf_get_chunk procedure, public :: layout => hdf_get_layout procedure, public :: shape => hdf_get_shape procedure, public :: ndims => hdf_get_ndims procedure, public :: flush => hdf_flush procedure, public :: close => hdf_close_group procedure, public :: open => hdf_open_group procedure, public :: create => hdf_create procedure, public :: write_group procedure, public :: finalize => hdf_finalize procedure, public :: initialize => hdf_initialize generic, public :: write => hdf_write_scalar, hdf_write_1d, hdf_write_2d, hdf_write_3d, hdf_write_4d, hdf_write_5d, hdf_write_6d, hdf_write_7d below are procedure that need generic mapping (type or rank agnostic)\n write group or dataset integer/real generic, public :: writeattr => writeattr_char, writeattr_num write attributes generic, public :: readattr => readattr_char, readattr_num read attributes generic, public :: read => hdf_read_scalar, hdf_read_1d, hdf_read_2d, hdf_read_3d, hdf_read_4d, hdf_read_5d, hdf_read_6d, hdf_read_7d read dataset procedure, private :: readattr_num private methods\n each method must be declared here, and above as a generic, public procedure, private :: readattr_char procedure, private :: writeattr_num procedure, private :: writeattr_char procedure, private :: hdf_read_7d procedure, private :: hdf_read_6d procedure, private :: hdf_read_5d procedure, private :: hdf_read_4d procedure, private :: hdf_read_3d procedure, private :: hdf_read_2d procedure, private :: hdf_read_1d procedure, private :: hdf_read_scalar procedure, private :: hdf_write_7d procedure, private :: hdf_write_6d procedure, private :: hdf_write_5d procedure, private :: hdf_write_4d procedure, private :: hdf_write_3d procedure, private :: hdf_write_2d procedure, private :: hdf_write_1d procedure, private :: hdf_write_scalar Functions private function hdf_is_contig (self, dname) Arguments Type Intent Optional Attributes Name class( hdf5_file ), intent(in) :: self character(len=*), intent(in) :: dname Return Value logical private function hdf_is_compact (self, dname) Arguments Type Intent Optional Attributes Name class( hdf5_file ), intent(in) :: self character(len=*), intent(in) :: dname Return Value logical private function hdf_is_chunked (self, dname) Arguments Type Intent Optional Attributes Name class( hdf5_file ), intent(in) :: self character(len=*), intent(in) :: dname Return Value logical public function is_hdf5 (filename) is this file HDF5? Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename Return Value logical public function check (ierr, filename, dname) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ierr character(len=*), intent(in), optional :: filename character(len=*), intent(in), optional :: dname Return Value logical Subroutines private subroutine hdf_initialize (self, filename, ierr, status, action, comp_lvl, verbose, debug) Opens hdf5 file Read more… Arguments Type Intent Optional Attributes Name class( hdf5_file ), intent(inout) :: self character(len=*), intent(in) :: filename integer, intent(out), optional :: ierr character(len=*), intent(in), optional :: status character(len=*), intent(in), optional :: action integer, intent(in), optional :: comp_lvl logical, intent(in), optional :: verbose logical, intent(in), optional :: debug private subroutine hdf_finalize (self, ierr, close_hdf5_interface) This must be called on each HDF5 file to flush buffers to disk\n data loss can occur if program terminates before this procedure Read more… Arguments Type Intent Optional Attributes Name class( hdf5_file ), intent(inout) :: self integer, intent(out), optional :: ierr logical, intent(in), optional :: close_hdf5_interface private subroutine hdf_flush (self, ierr) Arguments Type Intent Optional Attributes Name class( hdf5_file ), intent(in) :: self integer, intent(out), optional :: ierr public subroutine hdf5_close (ierr) this subroutine will close ALL existing file handles\n only call it at end of your program\n \"Flushes all data to disk, closes all open identifiers, and cleans up memory.\"\n \"Should be called by all HDF5 Fortran programs\" Arguments Type Intent Optional Attributes Name integer, intent(out), optional :: ierr private subroutine write_group (self, gname, ierr) Arguments Type Intent Optional Attributes Name class( hdf5_file ), intent(in) :: self character(len=*), intent(in) :: gname integer, intent(out), optional :: ierr public subroutine hdf_wrapup (did, sid, ierr) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: did integer(kind=HID_T), intent(in) :: sid integer, intent(out) :: ierr public subroutine hdf_get_slice (self, dname, did, sid, mem_sid, i0, i1, i2) setup array slices for read and write\n istart\n iend Read more… Arguments Type Intent Optional Attributes Name class( hdf5_file ), intent(in) :: self character(len=*), intent(in) :: dname integer(kind=HID_T), intent(inout) :: did integer(kind=hid_t), intent(out) :: sid integer(kind=hid_t), intent(out) :: mem_sid class(*), intent(in), dimension(:) :: i0 class(*), intent(in), dimension(:) :: i1 class(*), intent(in), optional dimension(:) :: i2 public subroutine hdf_shape_check (self, dname, dims) allow user to specify int4 or int8 dims\n check for matching rank, else bad reads can occur--doesn't always crash without this check\n check for matching size, else bad reads can occur. Arguments Type Intent Optional Attributes Name class( hdf5_file ), intent(in) :: self character(len=*), intent(in) :: dname class(*), intent(in) :: dims (:)","tags":"","loc":"module/h5fortran.html"},{"title":"file_image – Object-oriented Fortran 2008 HDF5 interface","text":"HDF5 file images are an in-RAM fast HDF5 virtual file.\n there are many caveats to their use and they might never be included in h5fortran h5ltopen_file_image_f does NOT exist yet as of HDF5 1.12.0. The API was specified for HDF5 1.8.9,\n but never implemented (yet). Uses iso_fortran_env iso_c_binding hdf5 Contents Subroutines create_file_image write_file_image read_file_image close_file_image Subroutines public subroutine create_file_image (fapl_id) open HDF5 library\n create file property ID \"fapl_id\"\n create and check empty buffer Arguments Type Intent Optional Attributes Name integer(kind=hid_t), intent(out) :: fapl_id public subroutine write_file_image (data, fapl_id) polymorphic in future implementation Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: data (:) integer(kind=hid_t), intent(in) :: fapl_id public subroutine read_file_image (buffer, fapl_id) Arguments Type Intent Optional Attributes Name integer, intent(out), dimension(:), target :: buffer integer(kind=hid_t), intent(in) :: fapl_id public subroutine close_file_image (fapl_id) close file image and library Arguments Type Intent Optional Attributes Name integer(kind=hid_t), intent(in) :: fapl_id","tags":"","loc":"module/file_image.html"},{"title":"h5layout – Object-oriented Fortran 2008 HDF5 interface","text":"Uses iso_fortran_env hdf5 h5lt Contents Functions sysclock2ms Subroutines print_layout write_layout std_unlink bench_write bench_read Functions public impure elemental function sysclock2ms (t) Convert a number of clock ticks, as returned by system_clock() called\n with integer(int64) arguments, to milliseconds Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: t Return Value real(kind=real64) Subroutines public subroutine print_layout (filename, ds_name) prints dataset (variable) layout in a file\n get file size.\n get dataset storage layout\n not truly constants, so select case doesn't work Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename character(len=*), intent(in) :: ds_name public subroutine write_layout (file_id, ds_name, layout, dat) write real data with HDF5 layout type specified Read more… Arguments Type Intent Optional Attributes Name integer(kind=hid_t), intent(in) :: file_id character(len=*), intent(in) :: ds_name integer, intent(in) :: layout real, intent(in) :: dat (:) private subroutine std_unlink (file) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file public subroutine bench_write (file, layout, dat, N) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file integer, intent(in) :: layout real, intent(in) :: dat (:) integer, intent(in) :: N public subroutine bench_read (file, N, dat) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file integer, intent(in) :: N real, intent(out), optional :: dat (:)","tags":"","loc":"module/h5layout.html"},{"title":"attributes – Object-oriented Fortran 2008 HDF5 interface","text":"Uses h5lt Ancestors: h5fortran Contents Subroutines attr_shape_check Module Procedures readattr_char readattr_num writeattr_char writeattr_num writeattr_char_lt writeattr_num_lt readattr_char_lt readattr_num_lt Subroutines subroutine attr_shape_check (self, dname, attr, asize, ierr) check for matching rank, else bad reads can occur--doesn't always crash without this check\n check for matching size, else bad reads can occur. Arguments Type Intent Optional Attributes Name class( hdf5_file ), intent(in) :: self character(len=*), intent(in) :: dname character(len=*), intent(in) :: attr integer, intent(in) :: asize integer, intent(out) :: ierr Module Procedures module procedure readattr_char module subroutine readattr_char(self, dname, attr, attrval, ierr) Interface → NOTE: HDF5 character attributes are scalar. Arguments Type Intent Optional Attributes Name class( hdf5_file ), intent(in) :: self character(len=*), intent(in) :: dname character(len=*), intent(in) :: attr character(len=*), intent(inout) :: attrval intent(inout) for character integer, intent(out), optional :: ierr module procedure readattr_num module subroutine readattr_num(self, dname, attr, attrval, ierr) Interface → NOTE: HDF5 has 1D vector attributes for integer, float and double. Arguments Type Intent Optional Attributes Name class( hdf5_file ), intent(in) :: self character(len=*), intent(in) :: dname character(len=*), intent(in) :: attr class(*), intent(out) :: attrval (:) integer, intent(out), optional :: ierr module procedure writeattr_char module subroutine writeattr_char(self, dname, attr, attrval, ierr) Interface → Arguments Type Intent Optional Attributes Name class( hdf5_file ), intent(in) :: self character(len=*), intent(in) :: dname character(len=*), intent(in) :: attr character(len=*), intent(in) :: attrval integer, intent(out), optional :: ierr module procedure writeattr_num module subroutine writeattr_num(self, dname, attr, attrval, ierr) Interface → NOTE: HDF5 has 1D vector attributes for integer, float and double. Arguments Type Intent Optional Attributes Name class( hdf5_file ), intent(in) :: self character(len=*), intent(in) :: dname character(len=*), intent(in) :: attr class(*), intent(in) :: attrval (:) integer, intent(out), optional :: ierr module procedure writeattr_char_lt module subroutine writeattr_char_lt(filename, dname, attr, attrval, ierr) Interface → Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename character(len=*), intent(in) :: dname character(len=*), intent(in) :: attr character(len=*), intent(in) :: attrval integer, intent(out), optional :: ierr module procedure writeattr_num_lt module subroutine writeattr_num_lt(filename, dname, attr, attrval, ierr) Interface → Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename character(len=*), intent(in) :: dname character(len=*), intent(in) :: attr class(*), intent(in) :: attrval (:) integer, intent(out), optional :: ierr module procedure readattr_char_lt module subroutine readattr_char_lt(filename, dname, attr, attrval, ierr) Interface → Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename character(len=*), intent(in) :: dname character(len=*), intent(in) :: attr character(len=*), intent(inout) :: attrval intent(inout) for character integer, intent(out), optional :: ierr module procedure readattr_num_lt module subroutine readattr_num_lt(filename, dname, attr, attrval, ierr) Interface → Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename character(len=*), intent(in) :: dname character(len=*), intent(in) :: attr class(*), intent(out) :: attrval (:) integer, intent(out), optional :: ierr","tags":"","loc":"module/attributes.html"},{"title":"pathlib – Object-oriented Fortran 2008 HDF5 interface","text":"vendored from Michael Hirsch's Fortran pathlib Uses Ancestors: h5fortran Contents Module Procedures get_tempdir is_absolute_path std_unlink Module Procedures module procedure get_tempdir module function get_tempdir() Interface → Arguments None Return Value character(len=:),\n  allocatable module procedure is_absolute_path module function is_absolute_path(path) Interface → heuristic to determine if is absolute path Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: path Return Value logical module procedure std_unlink module function std_unlink(filename) Interface → deletes file in Fortran standard manner. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename Return Value logical","tags":"","loc":"module/pathlib.html"},{"title":"read – Object-oriented Fortran 2008 HDF5 interface","text":"This submodule is for reading HDF5 via submodules Uses hdf5 H5LT Ancestors: h5fortran Used by Descendants: reader reader_lt reader_ND Contents Functions get_native_dtype Module Procedures hdf_get_ndims hdf_get_shape hdf_get_chunk hdf_get_layout hdf_check_exist Functions function get_native_dtype (ds_id, dname, filename) result(native_dtype) get the dataset variable type\n the \"type\" and \"native_type\" are just IDs, the final native type is composed from:\n * enddianness\n * generic type\n we think endianness is handled by HDF5 ... ?\n compose datatype inferred Arguments Type Intent Optional Attributes Name integer(kind=hid_t), intent(in) :: ds_id character(len=*), intent(in) :: dname character(len=*), intent(in) :: filename Return Value integer(kind=hid_t) Module Procedures module procedure hdf_get_ndims module function hdf_get_ndims(self, dname) result(drank) Interface → get rank or \"ndims\" Arguments Type Intent Optional Attributes Name class( hdf5_file ), intent(in) :: self character(len=*), intent(in) :: dname Return Value integer module procedure hdf_get_shape module subroutine hdf_get_shape(self, dname, dims, ierr) Interface → must get dims before info, as \"dims\" must be allocated or segfault occurs. Arguments Type Intent Optional Attributes Name class( hdf5_file ), intent(in) :: self character(len=*), intent(in) :: dname integer(kind=HSIZE_T), intent(out), allocatable :: dims (:) integer, intent(out), optional :: ierr module procedure hdf_get_chunk module subroutine hdf_get_chunk(self, dname, chunk_size) Interface → Arguments Type Intent Optional Attributes Name class( hdf5_file ), intent(in) :: self character(len=*), intent(in) :: dname integer(kind=hsize_t), intent(out) :: chunk_size (:) module procedure hdf_get_layout module function hdf_get_layout(self, dname) result(layout) Interface → Arguments Type Intent Optional Attributes Name class( hdf5_file ), intent(in) :: self character(len=*), intent(in) :: dname Return Value integer module procedure hdf_check_exist module function hdf_check_exist(self, dname) result(exists) Interface → h5lexists_f can false error with groups--just use h5ltpath_valid Arguments Type Intent Optional Attributes Name class( hdf5_file ), intent(in) :: self character(len=*), intent(in) :: dname Return Value logical","tags":"","loc":"module/read.html"},{"title":"reader – Object-oriented Fortran 2008 HDF5 interface","text":"This submodule is for reading 0-D..7-D data Uses hdf5 h5lt Ancestors: h5fortran : read Contents Module Procedures hdf_read_scalar hdf_read_1d hdf_read_2d hdf_read_3d hdf_read_4d hdf_read_5d hdf_read_6d hdf_read_7d Module Procedures module procedure hdf_read_scalar module subroutine hdf_read_scalar(self, dname, value, ierr) Interface → cast the dataset read from disk to the variable type presented by user h5f%read(\"/my_dataset\", x)\n We only cast when needed to save memory.\n select case doesn't allow H5T_* Arguments Type Intent Optional Attributes Name class( hdf5_file ), intent(in) :: self character(len=*), intent(in) :: dname class(*), intent(inout) :: value intent(inout) for character integer, intent(out), optional :: ierr module procedure hdf_read_1d module subroutine hdf_read_1d(self, dname, value, ierr, istart, iend, stride) Interface → necessary to use this present check for Intel and GCC\n cast the dataset read from disk to the variable type presented by user h5f%read(\"/my_dataset\", x)\n We only cast when needed to save memory.\n select case doesn't allow H5T_* Arguments Type Intent Optional Attributes Name class( hdf5_file ), intent(in) :: self character(len=*), intent(in) :: dname class(*), intent(out) :: value (:) integer, intent(out), optional :: ierr integer, intent(in), optional dimension(:) :: istart integer, intent(in), optional dimension(:) :: iend integer, intent(in), optional dimension(:) :: stride module procedure hdf_read_2d module subroutine hdf_read_2d(self, dname, value, ierr, istart, iend, stride) Interface → necessary to use this present check for Intel and GCC\n cast the dataset read from disk to the variable type presented by user h5f%read(\"/my_dataset\", x)\n We only cast when needed to save memory.\n select case doesn't allow H5T_* Arguments Type Intent Optional Attributes Name class( hdf5_file ), intent(in) :: self character(len=*), intent(in) :: dname class(*), intent(out) :: value (:,:) integer, intent(out), optional :: ierr integer, intent(in), optional dimension(:) :: istart integer, intent(in), optional dimension(:) :: iend integer, intent(in), optional dimension(:) :: stride module procedure hdf_read_3d module subroutine hdf_read_3d(self, dname, value, ierr, istart, iend, stride) Interface → necessary to use this present check for Intel and GCC\n cast the dataset read from disk to the variable type presented by user h5f%read(\"/my_dataset\", x)\n We only cast when needed to save memory.\n select case doesn't allow H5T_* Arguments Type Intent Optional Attributes Name class( hdf5_file ), intent(in) :: self character(len=*), intent(in) :: dname class(*), intent(out) :: value (:,:,:) integer, intent(out), optional :: ierr integer, intent(in), optional dimension(:) :: istart integer, intent(in), optional dimension(:) :: iend integer, intent(in), optional dimension(:) :: stride module procedure hdf_read_4d module subroutine hdf_read_4d(self, dname, value, ierr, istart, iend, stride) Interface → necessary to use this present check for Intel and GCC\n cast the dataset read from disk to the variable type presented by user h5f%read(\"/my_dataset\", x)\n We only cast when needed to save memory.\n select case doesn't allow H5T_* Arguments Type Intent Optional Attributes Name class( hdf5_file ), intent(in) :: self character(len=*), intent(in) :: dname class(*), intent(out) :: value (:,:,:,:) integer, intent(out), optional :: ierr integer, intent(in), optional dimension(:) :: istart integer, intent(in), optional dimension(:) :: iend integer, intent(in), optional dimension(:) :: stride module procedure hdf_read_5d module subroutine hdf_read_5d(self, dname, value, ierr, istart, iend, stride) Interface → necessary to use this present check for Intel and GCC\n cast the dataset read from disk to the variable type presented by user h5f%read(\"/my_dataset\", x)\n We only cast when needed to save memory.\n select case doesn't allow H5T_* Arguments Type Intent Optional Attributes Name class( hdf5_file ), intent(in) :: self character(len=*), intent(in) :: dname class(*), intent(out) :: value (:,:,:,:,:) integer, intent(out), optional :: ierr integer, intent(in), optional dimension(:) :: istart integer, intent(in), optional dimension(:) :: iend integer, intent(in), optional dimension(:) :: stride module procedure hdf_read_6d module subroutine hdf_read_6d(self, dname, value, ierr, istart, iend, stride) Interface → necessary to use this present check for Intel and GCC\n cast the dataset read from disk to the variable type presented by user h5f%read(\"/my_dataset\", x)\n We only cast when needed to save memory.\n select case doesn't allow H5T_* Arguments Type Intent Optional Attributes Name class( hdf5_file ), intent(in) :: self character(len=*), intent(in) :: dname class(*), intent(out) :: value (:,:,:,:,:,:) integer, intent(out), optional :: ierr integer, intent(in), optional dimension(:) :: istart integer, intent(in), optional dimension(:) :: iend integer, intent(in), optional dimension(:) :: stride module procedure hdf_read_7d module subroutine hdf_read_7d(self, dname, value, ierr, istart, iend, stride) Interface → necessary to use this present check for Intel and GCC\n cast the dataset read from disk to the variable type presented by user h5f%read(\"/my_dataset\", x)\n We only cast when needed to save memory.\n select case doesn't allow H5T_* Arguments Type Intent Optional Attributes Name class( hdf5_file ), intent(in) :: self character(len=*), intent(in) :: dname class(*), intent(out) :: value (:,:,:,:,:,:,:) integer, intent(out), optional :: ierr integer, intent(in), optional dimension(:) :: istart integer, intent(in), optional dimension(:) :: iend integer, intent(in), optional dimension(:) :: stride","tags":"","loc":"module/reader.html"},{"title":"reader_lt – Object-oriented Fortran 2008 HDF5 interface","text":"Uses Ancestors: h5fortran : read Contents Module Procedures h5exist lt0read lt1read lt2read lt3read lt4read lt5read lt6read lt7read Module Procedures module procedure h5exist module function h5exist(filename, dname) Interface → Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename character(len=*), intent(in) :: dname Return Value logical module procedure lt0read module subroutine lt0read(filename, dname, value, ierr) Interface → Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename character(len=*), intent(in) :: dname class(*), intent(out) :: value integer, intent(out), optional :: ierr module procedure lt1read module subroutine lt1read(filename, dname, value, ierr) Interface → Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename character(len=*), intent(in) :: dname class(*), intent(out) :: value (:) integer, intent(out), optional :: ierr module procedure lt2read module subroutine lt2read(filename, dname, value, ierr) Interface → Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename character(len=*), intent(in) :: dname class(*), intent(out) :: value (:,:) integer, intent(out), optional :: ierr module procedure lt3read module subroutine lt3read(filename, dname, value, ierr) Interface → Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename character(len=*), intent(in) :: dname class(*), intent(out) :: value (:,:,:) integer, intent(out), optional :: ierr module procedure lt4read module subroutine lt4read(filename, dname, value, ierr) Interface → Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename character(len=*), intent(in) :: dname class(*), intent(out) :: value (:,:,:,:) integer, intent(out), optional :: ierr module procedure lt5read module subroutine lt5read(filename, dname, value, ierr) Interface → Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename character(len=*), intent(in) :: dname class(*), intent(out) :: value (:,:,:,:,:) integer, intent(out), optional :: ierr module procedure lt6read module subroutine lt6read(filename, dname, value, ierr) Interface → Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename character(len=*), intent(in) :: dname class(*), intent(out) :: value (:,:,:,:,:,:) integer, intent(out), optional :: ierr module procedure lt7read module subroutine lt7read(filename, dname, value, ierr) Interface → Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename character(len=*), intent(in) :: dname class(*), intent(out) :: value (:,:,:,:,:,:,:) integer, intent(out), optional :: ierr","tags":"","loc":"module/reader_lt.html"},{"title":"reader_ND – Object-oriented Fortran 2008 HDF5 interface","text":"Uses Ancestors: h5fortran : read Contents Module Procedures hdf_read_8d Module Procedures module procedure hdf_read_8d module procedure hdf_read_8d() Arguments None","tags":"","loc":"module/reader_nd.html"},{"title":"write – Object-oriented Fortran 2008 HDF5 interface","text":"This submodule is for writing HDF5 data via child submodules Uses hdf5 H5LT Ancestors: h5fortran Used by Descendants: writer writer_lt writer_ND Contents Subroutines set_deflate guess_chunk_size Module Procedures hdf_create create_softlink hdf_open_group hdf_close_group Subroutines subroutine set_deflate (self, dims, pid, ierr, chunk_size) guess chunk size, keeping in mind 1 Megabyte recommended maximum chunk size Arguments Type Intent Optional Attributes Name class( hdf5_file ), intent(inout) :: self integer(kind=HSIZE_T), intent(in) :: dims (:) integer(kind=HID_T), intent(out) :: pid integer, intent(out) :: ierr integer, intent(in), optional :: chunk_size (:) subroutine guess_chunk_size (dims, chunk_size) based on https://github.com/h5py/h5py/blob/master/h5py/_hl/filters.py\n refer to https://support.hdfgroup.org/HDF5/Tutor/layout.html\n Repeatedly loop over the axes, dividing them by 2.\n Stop when:\n   1a. We're smaller than the target chunk size, OR\n   1b. We're within 50% of the target chunk size, AND\n    2. The chunk is smaller than the maximum chunk size Read more… Arguments Type Intent Optional Attributes Name integer(kind=HSIZE_T), intent(in) :: dims (:) integer(kind=HSIZE_T), intent(out) :: chunk_size (:) Module Procedures module procedure hdf_create module subroutine hdf_create(self, dname, dtype, dims, sid, did, chunk_size, istart, iend, stride, compact) Interface → h5lexists_f can false error with groups--just use h5ltpath_valid Read more… Arguments Type Intent Optional Attributes Name class( hdf5_file ), intent(inout) :: self character(len=*), intent(in) :: dname integer(kind=HID_T), intent(in) :: dtype class(*), intent(in) :: dims (:) integer(kind=HID_T), intent(out), optional :: sid integer(kind=HID_T), intent(out), optional :: did integer, intent(in), optional :: chunk_size (:) integer, intent(in), optional :: istart (:) integer, intent(in), optional :: iend (:) integer, intent(in), optional :: stride (:) logical, intent(in), optional :: compact keep istart, iend, stride for future slice shape check module procedure create_softlink module subroutine create_softlink(self, target, link) Interface → HDF5 soft link -- to variables in same file\n target need not exist (dangling link)\n linking to external files requires an external link (different function required) Arguments Type Intent Optional Attributes Name class( hdf5_file ), intent(inout) :: self character(len=*), intent(in) :: target character(len=*), intent(in) :: link module procedure hdf_open_group module subroutine hdf_open_group(self, gname, ierr) Interface → Arguments Type Intent Optional Attributes Name class( hdf5_file ), intent(inout) :: self character(len=*), intent(in) :: gname integer, intent(out), optional :: ierr module procedure hdf_close_group module subroutine hdf_close_group(self, ierr) Interface → Arguments Type Intent Optional Attributes Name class( hdf5_file ), intent(inout) :: self integer, intent(out), optional :: ierr","tags":"","loc":"module/write.html"},{"title":"writer – Object-oriented Fortran 2008 HDF5 interface","text":"This submodule is for writing 0-D..7-D data Uses hdf5 Ancestors: h5fortran : write Contents Module Procedures hdf_write_scalar hdf_write_1d hdf_write_2d hdf_write_3d hdf_write_4d hdf_write_5d hdf_write_6d hdf_write_7d Module Procedures module procedure hdf_write_scalar module subroutine hdf_write_scalar(self, dname, value, ierr, compact) Interface → sentinel Read more… Arguments Type Intent Optional Attributes Name class( hdf5_file ), intent(inout) :: self character(len=*), intent(in) :: dname class(*), intent(in) :: value integer, intent(out), optional :: ierr logical, intent(in), optional :: compact module procedure hdf_write_1d module subroutine hdf_write_1d(self, dname, value, ierr, chunk_size, istart, iend, stride, compact) Interface → Arguments Type Intent Optional Attributes Name class( hdf5_file ), intent(inout) :: self character(len=*), intent(in) :: dname class(*), intent(in) :: value (:) integer, intent(out), optional :: ierr integer, intent(in), optional :: chunk_size (1) integer, intent(in), optional dimension(:) :: istart integer, intent(in), optional dimension(:) :: iend integer, intent(in), optional dimension(:) :: stride logical, intent(in), optional :: compact module procedure hdf_write_2d module subroutine hdf_write_2d(self, dname, value, ierr, chunk_size, istart, iend, stride, compact) Interface → Arguments Type Intent Optional Attributes Name class( hdf5_file ), intent(inout) :: self character(len=*), intent(in) :: dname class(*), intent(in) :: value (:,:) integer, intent(out), optional :: ierr integer, intent(in), optional :: chunk_size (2) integer, intent(in), optional dimension(:) :: istart integer, intent(in), optional dimension(:) :: iend integer, intent(in), optional dimension(:) :: stride logical, intent(in), optional :: compact module procedure hdf_write_3d module subroutine hdf_write_3d(self, dname, value, ierr, chunk_size, istart, iend, stride, compact) Interface → Arguments Type Intent Optional Attributes Name class( hdf5_file ), intent(inout) :: self character(len=*), intent(in) :: dname class(*), intent(in) :: value (:,:,:) integer, intent(out), optional :: ierr integer, intent(in), optional :: chunk_size (3) integer, intent(in), optional dimension(:) :: istart integer, intent(in), optional dimension(:) :: iend integer, intent(in), optional dimension(:) :: stride logical, intent(in), optional :: compact module procedure hdf_write_4d module subroutine hdf_write_4d(self, dname, value, ierr, chunk_size, istart, iend, stride, compact) Interface → Arguments Type Intent Optional Attributes Name class( hdf5_file ), intent(inout) :: self character(len=*), intent(in) :: dname class(*), intent(in) :: value (:,:,:,:) integer, intent(out), optional :: ierr integer, intent(in), optional :: chunk_size (4) integer, intent(in), optional dimension(:) :: istart integer, intent(in), optional dimension(:) :: iend integer, intent(in), optional dimension(:) :: stride logical, intent(in), optional :: compact module procedure hdf_write_5d module subroutine hdf_write_5d(self, dname, value, ierr, chunk_size, istart, iend, stride, compact) Interface → Arguments Type Intent Optional Attributes Name class( hdf5_file ), intent(inout) :: self character(len=*), intent(in) :: dname class(*), intent(in) :: value (:,:,:,:,:) integer, intent(out), optional :: ierr integer, intent(in), optional :: chunk_size (5) integer, intent(in), optional dimension(:) :: istart integer, intent(in), optional dimension(:) :: iend integer, intent(in), optional dimension(:) :: stride logical, intent(in), optional :: compact module procedure hdf_write_6d module subroutine hdf_write_6d(self, dname, value, ierr, chunk_size, istart, iend, stride, compact) Interface → Arguments Type Intent Optional Attributes Name class( hdf5_file ), intent(inout) :: self character(len=*), intent(in) :: dname class(*), intent(in) :: value (:,:,:,:,:,:) integer, intent(out), optional :: ierr integer, intent(in), optional :: chunk_size (6) integer, intent(in), optional dimension(:) :: istart integer, intent(in), optional dimension(:) :: iend integer, intent(in), optional dimension(:) :: stride logical, intent(in), optional :: compact module procedure hdf_write_7d module subroutine hdf_write_7d(self, dname, value, ierr, chunk_size, istart, iend, stride, compact) Interface → Arguments Type Intent Optional Attributes Name class( hdf5_file ), intent(inout) :: self character(len=*), intent(in) :: dname class(*), intent(in) :: value (:,:,:,:,:,:,:) integer, intent(out), optional :: ierr integer, intent(in), optional :: chunk_size (7) integer, intent(in), optional dimension(:) :: istart integer, intent(in), optional dimension(:) :: iend integer, intent(in), optional dimension(:) :: stride logical, intent(in), optional :: compact","tags":"","loc":"module/writer.html"},{"title":"writer_lt – Object-oriented Fortran 2008 HDF5 interface","text":"Uses Ancestors: h5fortran : write Contents Module Procedures lt0write lt1write lt2write lt3write lt4write lt5write lt6write lt7write Module Procedures module procedure lt0write module subroutine lt0write(filename, dname, value, ierr) Interface → Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename character(len=*), intent(in) :: dname class(*), intent(in) :: value integer, intent(out), optional :: ierr module procedure lt1write module subroutine lt1write(filename, dname, value, ierr) Interface → Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename character(len=*), intent(in) :: dname class(*), intent(in) :: value (:) integer, intent(out), optional :: ierr module procedure lt2write module subroutine lt2write(filename, dname, value, ierr) Interface → Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename character(len=*), intent(in) :: dname class(*), intent(in) :: value (:,:) integer, intent(out), optional :: ierr module procedure lt3write module subroutine lt3write(filename, dname, value, ierr) Interface → Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename character(len=*), intent(in) :: dname class(*), intent(in) :: value (:,:,:) integer, intent(out), optional :: ierr module procedure lt4write module subroutine lt4write(filename, dname, value, ierr) Interface → Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename character(len=*), intent(in) :: dname class(*), intent(in) :: value (:,:,:,:) integer, intent(out), optional :: ierr module procedure lt5write module subroutine lt5write(filename, dname, value, ierr) Interface → Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename character(len=*), intent(in) :: dname class(*), intent(in) :: value (:,:,:,:,:) integer, intent(out), optional :: ierr module procedure lt6write module subroutine lt6write(filename, dname, value, ierr) Interface → Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename character(len=*), intent(in) :: dname class(*), intent(in) :: value (:,:,:,:,:,:) integer, intent(out), optional :: ierr module procedure lt7write module subroutine lt7write(filename, dname, value, ierr) Interface → Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename character(len=*), intent(in) :: dname class(*), intent(in) :: value (:,:,:,:,:,:,:) integer, intent(out), optional :: ierr","tags":"","loc":"module/writer_lt.html"},{"title":"writer_ND – Object-oriented Fortran 2008 HDF5 interface","text":"Uses Ancestors: h5fortran : write Contents Module Procedures hdf_write_8d Module Procedures module procedure hdf_write_8d module procedure hdf_write_8d() Arguments None","tags":"","loc":"module/writer_nd.html"},{"title":"test_file_image – Object-oriented Fortran 2008 HDF5 interface","text":"Uses iso_fortran_env file_image Contents Variables fapl_id in out Variables Type Attributes Name Initial integer(kind=hid_t) :: fapl_id integer, dimension(1:8) :: in arbitrary user data integer, dimension(1:8) :: out arbitrary user data","tags":"","loc":"program/test_file_image.html"},{"title":"compact – Object-oriented Fortran 2008 HDF5 interface","text":"Uses hdf5 h5layout dummy data Fortran interface Contents Variables N M ierr fn1 fn2 fn3 x Variables Type Attributes Name Initial integer :: N integer :: M integer :: ierr character(len=:), allocatable :: fn1 character(len=:), allocatable :: fn2 character(len=:), allocatable :: fn3 real, allocatable :: x (:)","tags":"","loc":"program/compact.html"},{"title":"main_int64 – Object-oriented Fortran 2008 HDF5 interface","text":"Uses hdf5 iso_fortran_env hdf5 fortran interface can also read/write int64, but it's not in the h5lt interface\n initialize fortran interface and file Contents Variables ierr filename Functions read_int64 Subroutines verify_data write_data write_int64 Variables Type Attributes Name Initial integer :: ierr character(len=:), allocatable :: filename Functions function read_int64 (fid, name) result(i) Arguments Type Intent Optional Attributes Name integer(kind=hid_t), intent(in) :: fid character(len=*), intent(in) :: name Return Value integer(kind=int64) Subroutines subroutine verify_data (filename) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename subroutine write_data (filename) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename subroutine write_int64 (fid, i, name) dataspace Read more… Arguments Type Intent Optional Attributes Name integer(kind=hid_t) :: fid integer(kind=int64), intent(in) :: i character(len=*), intent(in) :: name","tags":"","loc":"program/main_int64.html"},{"title":"read_slice – Object-oriented Fortran 2008 HDF5 interface","text":"example of Fortran reading smaller array into slice of larger array via subroutine should print\n -1 -1 -1 -1\n -1 -1  1  2\n -1 -1  3  4\n -1 -1 -1 -1 Contents Variables i bigA B Derived Types foo Subroutines getter Variables Type Attributes Name Initial integer :: i integer :: bigA (4,4) type( foo ) :: B Derived Types type :: foo Components Type Visibility Attributes Name Initial integer, public :: i44 (4,4) Subroutines subroutine getter (A) Arguments Type Intent Optional Attributes Name integer, intent(out) :: A (2,2)","tags":"","loc":"program/read_slice.html"},{"title":"array_test – Object-oriented Fortran 2008 HDF5 interface","text":"Uses ieee_arithmetic iso_fortran_env h5fortran Contents Variables nan Subroutines test_basic_array test_read_slice test_write_slice test_readwrite_array Variables Type Attributes Name Initial real(kind=real32) :: nan Subroutines subroutine test_basic_array (filename) read\n int32\n verify reading into larger array\n real Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename tests that compression doesn't fail for very small datasets, where it really shouldn't be used (makes file bigger) subroutine test_read_slice (filename) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename subroutine test_write_slice (filename) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename subroutine test_readwrite_array (filename, ng, nn, pn) more group Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename integer, intent(in) :: ng integer, intent(in) :: nn integer, intent(in) :: pn","tags":"","loc":"program/array_test.html"},{"title":"test_attributes – Object-oriented Fortran 2008 HDF5 interface","text":"Uses iso_fortran_env h5fortran Contents Variables filename s32 Subroutines test_write_attributes test_read_attributes Variables Type Attributes Name Initial character(len=*), parameter :: filename = 'test_attr.h5' character(len=8) :: s32 Subroutines subroutine test_write_attributes (path) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: path subroutine test_read_attributes (path) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: path","tags":"","loc":"program/test_attributes.html"},{"title":"test_deflate – Object-oriented Fortran 2008 HDF5 interface","text":"Uses iso_fortran_env h5fortran hdf5 unit tests and registration tests of HDF5 deflate compression write Contents Subroutines test_hdf5_deflate Subroutines subroutine test_hdf5_deflate () Arguments None","tags":"","loc":"program/test_deflate.html"},{"title":"test_error – Object-oriented Fortran 2008 HDF5 interface","text":"Uses iso_fortran_env h5fortran Contents Subroutines test_nonexist_old_file test_nonexist_unknown_file test_nonhdf5_file test_wrong_type Subroutines subroutine test_nonexist_old_file () Arguments None subroutine test_nonexist_unknown_file () Arguments None subroutine test_nonhdf5_file () Arguments None subroutine test_wrong_type () Arguments None","tags":"","loc":"program/test_error.html"},{"title":"exist_tests – Object-oriented Fortran 2008 HDF5 interface","text":"Uses iso_fortran_env h5fortran test \"exist\" variable Contents Subroutines test_is_hdf5 test_exist test_softlink test_scratch test_multifiles Subroutines subroutine test_is_hdf5 () Arguments None subroutine test_exist () Arguments None subroutine test_softlink () test dangling link Arguments None subroutine test_scratch () Arguments None subroutine test_multifiles () Arguments None","tags":"","loc":"program/exist_tests.html"},{"title":"nonexistvar – Object-oriented Fortran 2008 HDF5 interface","text":"Uses h5fortran Contents Variables u h filename Variables Type Attributes Name Initial integer :: u type( hdf5_file ) :: h character(len=*), parameter :: filename = 'bad.h5'","tags":"","loc":"program/nonexistvar.html"},{"title":"fail_slice_mismatch – Object-oriented Fortran 2008 HDF5 interface","text":"Uses h5fortran test writing wrong size Contents Variables h Variables Type Attributes Name Initial type( hdf5_file ) :: h","tags":"","loc":"program/fail_slice_mismatch.html"},{"title":"fail_slice_mismatch – Object-oriented Fortran 2008 HDF5 interface","text":"Uses h5fortran test writing wrong size Contents Variables h Variables Type Attributes Name Initial type( hdf5_file ) :: h","tags":"","loc":"program/fail_slice_mismatch~2.html"},{"title":"fail_unknown_read – Object-oriented Fortran 2008 HDF5 interface","text":"Uses h5fortran Contents Variables h x Variables Type Attributes Name Initial type( hdf5_file ) :: h complex :: x","tags":"","loc":"program/fail_unknown_read.html"},{"title":"fail_unknown_write – Object-oriented Fortran 2008 HDF5 interface","text":"Uses h5fortran Contents Variables h x Variables Type Attributes Name Initial type( hdf5_file ) :: h complex :: x","tags":"","loc":"program/fail_unknown_write.html"},{"title":"test_layout – Object-oriented Fortran 2008 HDF5 interface","text":"Uses iso_fortran_env h5fortran hdf5 read casting Contents Variables h fn d7_32 r7_32 d7_64 r7_64 w32 r32 w64 r64 wi32 ri32 Variables Type Attributes Name Initial type( hdf5_file ) :: h character(len=*), parameter :: fn = 'test_layout.h5' real(kind=real32), dimension(1,1,1,1,1,1,1) :: d7_32 real(kind=real32), dimension(1,1,1,1,1,1,1) :: r7_32 real(kind=real64), dimension(1,1,1,1,1,1,1) :: d7_64 real(kind=real64), dimension(1,1,1,1,1,1,1) :: r7_64 real(kind=real32) :: w32 real(kind=real32) :: r32 real(kind=real64) :: w64 real(kind=real64) :: r64 integer :: wi32 integer :: ri32","tags":"","loc":"program/test_layout.html"},{"title":"test_lt – Object-oriented Fortran 2008 HDF5 interface","text":"Uses h5fortran Contents Variables L L1 L2 L3 L4 L5 L6 L7 Variables Type Attributes Name Initial integer :: L integer :: L1 (8) integer :: L2 (2,1) integer :: L3 (1,1,1) integer :: L4 (1,1,1,1) integer :: L5 (1,1,1,1,1) integer :: L6 (1,1,1,1,1,1) integer :: L7 (1,1,1,1,1,1,1)","tags":"","loc":"program/test_lt.html"},{"title":"test_minimal – Object-oriented Fortran 2008 HDF5 interface","text":"Uses hdf5 h5lt Contents Variables i p lid filename Variables Type Attributes Name Initial integer :: i integer :: p integer(kind=HID_T) :: lid character(len=*), parameter :: filename = 'test_minimal.h5'","tags":"","loc":"program/test_minimal.html"},{"title":"test_hdf5 – Object-oriented Fortran 2008 HDF5 interface","text":"Uses iso_fortran_env h5fortran unit tests and registration tests of HDF5 OO interface Contents Subroutines testGroup test_writeExistingVariable Subroutines subroutine testGroup () Arguments None subroutine test_writeExistingVariable () Arguments None","tags":"","loc":"program/test_hdf5.html"},{"title":"scalar_test – Object-oriented Fortran 2008 HDF5 interface","text":"Uses iso_fortran_env h5fortran hdf5 write\n scalar tests\n vector create then write\n test rewrite\n read read casting -- real to int and int to real\n 1D vector read write\n 1D vector read casting -- real to int and int to real\n check filename property Contents Variables h rr1 rt r1 it i1 i1t it_64 i1_64 i1t_64 dims i fn Variables Type Attributes Name Initial type( hdf5_file ) :: h real(kind=real32), allocatable :: rr1 (:) real(kind=real32) :: rt real(kind=real32) :: r1 (4) integer(kind=int32) :: it integer(kind=int32) :: i1 (4) integer(kind=int32), allocatable :: i1t (:) integer(kind=int64) :: it_64 integer(kind=int64) :: i1_64 (4) integer(kind=int64), allocatable :: i1t_64 (:) integer(kind=HSIZE_T), allocatable :: dims (:) integer :: i character(len=*), parameter :: fn = 'test_scalar.h5'","tags":"","loc":"program/scalar_test.html"},{"title":"test_shape – Object-oriented Fortran 2008 HDF5 interface","text":"Uses h5fortran iso_fortran_env This program shows how HDF5 dimension orders are distinct in different langauges Contents Variables h path dims d2 d7 Variables Type Attributes Name Initial type( hdf5_file ) :: h character(len=*), parameter :: path = 'test_shape.h5' integer(kind=HSIZE_T), allocatable :: dims (:) integer :: d2 (3,4) integer :: d7 (2,1,3,4,7,6,5)","tags":"","loc":"program/test_shape.html"},{"title":"test_string – Object-oriented Fortran 2008 HDF5 interface","text":"Uses iso_fortran_env iso_c_binding h5fortran try reading too much data, then truncating to first C_NULL Contents Variables h i value val1k final path Variables Type Attributes Name Initial type( hdf5_file ) :: h integer :: i character(len=2) :: value character(len=1024) :: val1k character(len=:), allocatable :: final character(len=*), parameter :: path = 'test_string.h5'","tags":"","loc":"program/test_string.html"}]}